<?xml version="1.0"?>
<doc>
    <assembly>
        "GemStone.GemFire.Cache"
    </assembly>
    <members>
        <member name="M:gemfire.SerializationRegistry.deserialize(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte)">
Read the typeid, and pass the rest via a DataInput to obj's fromData.
If this can be deprecated, then we can cut the length out of the serialization.

Read the length, typeid, and run the objs fromData. Returns the New
object.

</member>
        <member name="M:gemfire.SerializationRegistry.serialize(gemfire.Serializable!System.Runtime.CompilerServices.IsConst*,gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
write the length of the serialization, write the typeId of the object,
     * then write whatever the object's toData requires. The length at the
     * front is backfilled after the serialization.

</member>
        <member name="M:GemStone.GemFire.Cache.DelegateWrapper.NativeDelegate">
            <summary>
Returns the native <c>gemfire::Serializable</c> object by invoking the
managed delegate provided in the constructor.
</summary>
            <returns>
Native <c>gemfire::Serializable</c> object after invoking the managed
delegate and wrapping inside a <c>ManagedCacheableKey</c> object.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.DelegateWrapper.#ctor(GemStone.GemFire.Cache.TypeFactoryMethod)">
            <summary>
Constructor to wrap the given managed delegate.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.DelegateWrapper">
            <summary>
Template class to wrap a managed <see cref="T:GemStone.GemFire.Cache.TypeFactoryMethod" />
delegate that returns an <see cref="T:GemStone.GemFire.Cache.IGFSerializable" /> object. It contains
a method that converts the managed object gotten by invoking the
delegate to the native <c>gemfire::Serializable</c> object
(using the provided wrapper class constructor).
</summary>
            <remarks>
This class is to enable interopibility between the managed and unmanaged
worlds when registering types.
In the managed world a user would register a managed type by providing
a factory delegate returning an object of that type. However, the
native implementation requires a factory function that returns an
object implementing <c>gemfire::Serializable</c>. Normally this would not
be possible since we require to dynamically generate a new function
for a given delegate.

Fortunately in the managed world the delegates contain an implicit
'this' pointer. Thus we can have a universal delegate that contains
the given managed delegate (in the 'this' pointer) and returns the
native <c>gemfire::Serializable</c> object. Additionally marshalling
services provide <c>Marshal.GetFunctionPointerForDelegate</c> which gives
a function pointer for a delegate which completes the conversion.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.#ctor(gemfire.PoolFactory*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.Create(gemfire.PoolFactory*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.Create(System.String)">
            <summary>
Create a new Pool for connecting a client to a set of GemFire Cache Servers.
using this factory's settings for attributes.
</summary>
            <param>
name the name of the pool, used when connecting regions to it
</param>
            <exception>
throws IllegalStateException if a pool with name already exists
throws IllegalStateException if a locator or server has not been added.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.Reset">
            <summary>
Resets the configuration of this factory to its defaults.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetMultiuserAuthentication(System.Boolean)">
            <summary>
Sets whether pool is in multiuser mode
If its in multiuser mode then app needs to get instance of cache from pool.getCache("creds"), to do the operations on cache.
</summary>
            <param>
multiuserAuthentication should be true/false. Default value is false;
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetSubscriptionAckInterval(System.Int32)">
            <summary>
Sets the is the interval in milliseconds to wait before sending
acknowledgements to the bridge server for events received from the server subscriptions.
</summary>
            <param>
ackInterval number of milliseconds to wait before sending event acknowledgements.
</param>
            <exception>
throws IllegalArgumentException if ackInterval is less than or equal to 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetSubscriptionMessageTrackingTimeout(System.Int32)">
            <summary>
Sets the messageTrackingTimeout attribute which is the time-to-live period,
in milliseconds, for subscription events the client has received from the server.
</summary>
            <remarks>
It's used to minimize duplicate events. Entries that have not been modified
for this amount of time are expired from the list.
</remarks>
            <param>
messageTrackingTimeout number of milliseconds to set the timeout to.
</param>
            <exception>
throws IllegalArgumentException if messageTrackingTimeout is less than or equal to 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetSubscriptionRedundancy(System.Int32)">
            <summary>
Sets the redundancy level for this pools server-to-client subscriptions.
</summary>
            <remarks>
If 0 then no redundant copies will be kept on the servers.
Otherwise an effort will be made to maintain the requested number of
copies of the server-to-client subscriptions. At most one copy per server will
be made up to the requested level.
</remarks>
            <param>
redundancy the number of redundant servers for this client's subscriptions.
</param>
            <exception>
throws IllegalArgumentException if redundancyLevel is less than -1.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetSubscriptionEnabled(System.Boolean)">
            <summary>
Enable subscriptions.
</summary>
            <remarks>
If set to true then the created pool will have server-to-client
subscriptions enabled. If set to false then all Subscription*
attributes are ignored at create time.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.AddServer(System.String,System.Int32)">
            <summary>
Add a server, given its host and port, to this factory.
</summary>
            <remarks>
The server must be a bridge server and this client will
directly connect to without consulting a server locator.
</remarks>
            <param>
host the host name or ip address that the server is listening on.
</param>
            <param>
port the port that the server is listening on
</param>
            <exception>
throws IllegalArgumentException if host is an unknown host
or if port is outside the valid range of [1..65535] inclusive.
</exception>
            <exception>
throws IllegalStateException if a server has already been added to this factory.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.AddLocator(System.String,System.Int32)">
            <summary>
Add a locator, given its host and port, to this factory.
</summary>
            <remarks>
The locator must be a server locator and will be used to discover other running
bridge servers and locators.
</remarks>
            <param>
host the host name or ip address that the locator is listening on.
</param>
            <param>
port the port that the locator is listening on
</param>
            <exception>
throws IllegalArgumentException if host is an unknown host
or if port is outside the valid range of [1..65535] inclusive.
</exception>
            <exception>
throws IllegalStateException if a locator has already been added to this factory.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetServerGroup(System.String)">
            <summary>
Configures the group that all servers this pool connects to must belong to.
</summary>
            <param>
group the server group that this pool will connect to.
If null or "" then all servers will be connected to.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetStatisticInterval(System.Int32)">
            <summary>
Set how often to send client statistics to the server.
</summary>
            <remarks>
Doing this allows gfmon to monitor clients.
A value of -1 disables the sending of client statistics
to the server.
</remarks>
            <param>
statisticInterval The amount of time in milliseconds between
sends of client statistics to the server.
</param>
            <exception>
throws IllegalArgumentException if statisticInterval
is less than -1.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetPingInterval(System.Int32)">
            <summary>
Set how often to ping servers to verify that they are still alive.
</summary>
            <remarks>
Each server will be sent a ping every pingInterval if there has not
been any other communication with the server.
These pings are used by the server to monitor the health of
the client. Make sure that the pingInterval is less than the
maximum time between pings allowed by the bridge server.
see in CacheServer: setMaximumTimeBetweenPings(int)
</remarks>
            <param>
pingInterval The amount of time in milliseconds between pings.
</param>
            <exception>
throws IllegalArgumentException if pingInterval is less than 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetRetryAttempts(System.Int32)">
            <summary>
Set the number of times to retry a request after timeout/exception.
</summary>
            <param>
retryAttempts The number of times to retry a request
after timeout/exception. -1 indicates that a request should be
tried against every available server before failing.
</param>
            <exception>
throws IllegalArgumentException if idleTimout is less than 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetIdleTimeout(System.Int32)">
            <summary>
Set the amount of time a connection can be idle before expiring the connection.
</summary>
            <remarks>
If the pool size is greater than the minimum specified, connections which have
been idle for longer than the idleTimeout will be closed.
</remarks>
            <param>
idleTimeout The amount of time in milliseconds that an idle connection
should live before expiring. -1 indicates that connections should never expire.
</param>
            <exception>
throws IllegalArgumentException if idleTimout is less than 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetMaxConnections(System.Int32)">
            <summary>
Set the max number of client to server connections that the pool will create.
</summary>
            <remarks>
If all of the connections are in use, an operation requiring a client to
server connection will block until a connection is available.
see setFreeConnectionTimeout(int)
</remarks>
            <param>
maxConnections the maximum number of connections in the pool.
-1 indicates that there is no maximum number of connections.
</param>
            <exception>
throws IllegalArgumentException if maxConnections is less than minConnections.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetMinConnections(System.Int32)">
            <summary>
Set the minimum number of connections to keep available at all times.
</summary>
            <remarks>
When the pool is created, it will create this many connections.
If 0 then connections will not be made until an actual operation
is done that requires client-to-server communication.
</remarks>
            <param>
minConnections the initial number of connections this pool will create.
</param>
            <exception>
throws IllegalArgumentException if minConnections is less than 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetReadTimeout(System.Int32)">
            <summary>
Sets the number of milliseconds to wait for a response from a server before
timing out the operation and trying another server (if any are available).
</summary>
            <param>
timeout number of milliseconds to wait for a response from a server
</param>
            <exception>
throws IllegalArgumentException if timeout
is less than or equal to 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetSocketBufferSize(System.Int32)">
            <summary>
Sets the socket buffer size for each connection made in this pool.
</summary>
            <remarks>
Large messages can be received and sent faster when this buffer is larger.
Larger buffers also optimize the rate at which servers can send events
for client subscriptions.
</remarks>
            <param>
bufferSize the size of the socket buffers used for reading and
writing on each connection in this pool.
</param>
            <exception>
throws IllegalArgumentException if bufferSize
is less than or equal to 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetLoadConditioningInterval(System.Int32)">
            <summary>
Sets the load conditioning interval for this pool.
</summary>
            <remarks>
This interval controls how frequently the pool will check to see if
a connection to a given server should be moved to a different
server to improve the load balance.
</remarks>
            <param>
loadConditioningInterval the connection lifetime in milliseconds
A value of -1 disables load conditioning.
</param>
            <exception>
throws IllegalArgumentException if connectionLifetime
is less than -1.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolFactory.SetFreeConnectionTimeout(System.Int32)">
            <summary>
Sets the free connection timeout for this pool.
</summary>
            <remarks>
If the pool has a max connections setting, operations will block
if all of the connections are in use. The free connection timeout
specifies how long those operations will block waiting for
a free connection before receiving an AllConnectionsInUseException.
If max connections is not set this setting has no effect.
</remarks>
            <param>
connectionTimeout the connection timeout in milliseconds
</param>
            <exception>
IllegalArgumentException if connectionTimeout 
is less than or equal to 0.
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.PoolFactory">
            <summary>
This interface provides for the configuration and creation of instances of Pool.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolManager.Close">
            <summary>
Destroys all created pools.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolManager.Close(System.Boolean)">
            <summary>
Destroys all created pools.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolManager.Find(GemStone.GemFire.Cache.Region)">
            <summary>
Find the pool used by the given region.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolManager.Find(System.String)">
            <summary>
Find by name an existing connection pool.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolManager.GetAll">
            <summary>
Returns a map containing all the pools in this manager.
The keys are pool names and the values are Pool instances.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.PoolManager.CreateFactory">
            <summary>
Creates a new PoolFactory which is used to configure and create Pools.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.PoolManager">
            <summary>
This interface provides for the configuration and creation of instances of PoolFactory.
</summary>
        </member>
        <member name="M:gemfire.PoolManager.close(System.Boolean)">
Unconditionally destroys all created pools that are in this manager.
@param keepAlive defines whether the server should keep the durable client's subscriptions alive for the <code>durable-client-timeout</code>.
@see DistributedSystem#connect for a description of <code>durable-client-timeout</code>.

</member>
        <member name="M:gemfire.PoolManager.find(gemfire.SharedPtr&lt;gemfire.Region&gt;)">
Find the pool used by the given region.
@param region is the region that is using the pool.
@return the pool used by that region or <code> NULLPTR </code> if the region does
not have a pool.

</member>
        <member name="M:gemfire.PoolManager.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Find by name an existing connection pool returning
the existing pool or <code>NULLPTR</code> if it does not exist.
@param name is the name of the connection pool
@return the existing connection pool or <code>NULLPTR</code> if it does not exist.

</member>
        <member name="M:gemfire.PoolManager.createFactory">
Creates a new {@link PoolFactory pool factory},
which is used to configure and create new {@link Pool}s.
@return the new pool factory

</member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesFactory`2.Create">
            <summary>
Creates a <c>CqAttributes</c> with the current settings.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesFactory`2.InitCqListeners(GemStone.GemFire.Cache.Generic.ICqListener`2{`0,`1}[])">
            <summary>
Initialize with an array of listeners
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesFactory`2.AddCqListener(GemStone.GemFire.Cache.Generic.ICqListener`2{`0,`1})">
            <summary>
add a cqListener 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesFactory`2.#ctor">
            <summary>
Creates a new instance of <c>CqAttributesFactory</c> ready
to create a <c>CqAttributes</c> with default settings.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqAttributesFactory`2">
            <summary>
Creates instances of <c>CqAttributes</c>.
</summary>
            <seealso cref="T:GemStone.GemFire.Cache.Generic.CqAttributes`2" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.#ctor(gemfire.PoolFactory*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.Create(gemfire.PoolFactory*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.Create(System.String)">
            <summary>
Create a new Pool for connecting a client to a set of GemFire Cache Servers.
using this factory's settings for attributes.
</summary>
            <param>
name the name of the pool, used when connecting regions to it
</param>
            <exception>
throws IllegalStateException if a pool with name already exists
throws IllegalStateException if a locator or server has not been added.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.Reset">
            <summary>
Resets the configuration of this factory to its defaults.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetMultiuserAuthentication(System.Boolean)">
            <summary>
Sets whether pool is in multiuser mode
If its in multiuser mode then app needs to get instance of cache from pool.getCache("creds"), to do the operations on cache.
</summary>
            <param>
multiuserAuthentication should be true/false. Default value is false;
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetSubscriptionAckInterval(System.Int32)">
            <summary>
Sets the is the interval in milliseconds to wait before sending
acknowledgements to the bridge server for events received from the server subscriptions.
</summary>
            <param>
ackInterval number of milliseconds to wait before sending event acknowledgements.
</param>
            <exception>
throws IllegalArgumentException if ackInterval is less than or equal to 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetSubscriptionMessageTrackingTimeout(System.Int32)">
            <summary>
Sets the messageTrackingTimeout attribute which is the time-to-live period,
in milliseconds, for subscription events the client has received from the server.
</summary>
            <remarks>
It's used to minimize duplicate events. Entries that have not been modified
for this amount of time are expired from the list.
</remarks>
            <param>
messageTrackingTimeout number of milliseconds to set the timeout to.
</param>
            <exception>
throws IllegalArgumentException if messageTrackingTimeout is less than or equal to 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetSubscriptionRedundancy(System.Int32)">
            <summary>
Sets the redundancy level for this pools server-to-client subscriptions.
</summary>
            <remarks>
If 0 then no redundant copies will be kept on the servers.
Otherwise an effort will be made to maintain the requested number of
copies of the server-to-client subscriptions. At most one copy per server will
be made up to the requested level.
</remarks>
            <param>
redundancy the number of redundant servers for this client's subscriptions.
</param>
            <exception>
throws IllegalArgumentException if redundancyLevel is less than -1.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetSubscriptionEnabled(System.Boolean)">
            <summary>
Enable subscriptions.
</summary>
            <remarks>
If set to true then the created pool will have server-to-client
subscriptions enabled. If set to false then all Subscription*
attributes are ignored at create time.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.AddServer(System.String,System.Int32)">
            <summary>
Add a server, given its host and port, to this factory.
</summary>
            <remarks>
The server must be a bridge server and this client will
directly connect to without consulting a server locator.
</remarks>
            <param>
host the host name or ip address that the server is listening on.
</param>
            <param>
port the port that the server is listening on
</param>
            <exception>
throws IllegalArgumentException if host is an unknown host
or if port is outside the valid range of [1..65535] inclusive.
</exception>
            <exception>
throws IllegalStateException if a server has already been added to this factory.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.AddLocator(System.String,System.Int32)">
            <summary>
Add a locator, given its host and port, to this factory.
</summary>
            <remarks>
The locator must be a server locator and will be used to discover other running
bridge servers and locators.
</remarks>
            <param>
host the host name or ip address that the locator is listening on.
</param>
            <param>
port the port that the locator is listening on
</param>
            <exception>
throws IllegalArgumentException if host is an unknown host
or if port is outside the valid range of [1..65535] inclusive.
</exception>
            <exception>
throws IllegalStateException if a locator has already been added to this factory.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetServerGroup(System.String)">
            <summary>
Configures the group that all servers this pool connects to must belong to.
</summary>
            <param>
group the server group that this pool will connect to.
If null or "" then all servers will be connected to.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetStatisticInterval(System.Int32)">
            <summary>
Set how often to send client statistics to the server.
</summary>
            <remarks>
Doing this allows gfmon to monitor clients.
A value of -1 disables the sending of client statistics
to the server.
</remarks>
            <param>
statisticInterval The amount of time in milliseconds between
sends of client statistics to the server.
</param>
            <exception>
throws IllegalArgumentException if statisticInterval
is less than -1.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetPingInterval(System.Int32)">
            <summary>
Set how often to ping servers to verify that they are still alive.
</summary>
            <remarks>
Each server will be sent a ping every pingInterval if there has not
been any other communication with the server.
These pings are used by the server to monitor the health of
the client. Make sure that the pingInterval is less than the
maximum time between pings allowed by the bridge server.
see in CacheServer: setMaximumTimeBetweenPings(int)
</remarks>
            <param>
pingInterval The amount of time in milliseconds between pings.
</param>
            <exception>
throws IllegalArgumentException if pingInterval is less than 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetRetryAttempts(System.Int32)">
            <summary>
Set the number of times to retry a request after timeout/exception.
</summary>
            <param>
retryAttempts The number of times to retry a request
after timeout/exception. -1 indicates that a request should be
tried against every available server before failing.
</param>
            <exception>
throws IllegalArgumentException if idleTimout is less than 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetIdleTimeout(System.Int32)">
            <summary>
Set the amount of time a connection can be idle before expiring the connection.
</summary>
            <remarks>
If the pool size is greater than the minimum specified, connections which have
been idle for longer than the idleTimeout will be closed.
</remarks>
            <param>
idleTimeout The amount of time in milliseconds that an idle connection
should live before expiring. -1 indicates that connections should never expire.
</param>
            <exception>
throws IllegalArgumentException if idleTimout is less than 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetMaxConnections(System.Int32)">
            <summary>
Set the max number of client to server connections that the pool will create.
</summary>
            <remarks>
If all of the connections are in use, an operation requiring a client to
server connection will block until a connection is available.
see setFreeConnectionTimeout(int)
</remarks>
            <param>
maxConnections the maximum number of connections in the pool.
-1 indicates that there is no maximum number of connections.
</param>
            <exception>
throws IllegalArgumentException if maxConnections is less than minConnections.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetMinConnections(System.Int32)">
            <summary>
Set the minimum number of connections to keep available at all times.
</summary>
            <remarks>
When the pool is created, it will create this many connections.
If 0 then connections will not be made until an actual operation
is done that requires client-to-server communication.
</remarks>
            <param>
minConnections the initial number of connections this pool will create.
</param>
            <exception>
throws IllegalArgumentException if minConnections is less than 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetReadTimeout(System.Int32)">
            <summary>
Sets the number of milliseconds to wait for a response from a server before
timing out the operation and trying another server (if any are available).
</summary>
            <param>
timeout number of milliseconds to wait for a response from a server
</param>
            <exception>
throws IllegalArgumentException if timeout
is less than or equal to 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetSocketBufferSize(System.Int32)">
            <summary>
Sets the socket buffer size for each connection made in this pool.
</summary>
            <remarks>
Large messages can be received and sent faster when this buffer is larger.
Larger buffers also optimize the rate at which servers can send events
for client subscriptions.
</remarks>
            <param>
bufferSize the size of the socket buffers used for reading and
writing on each connection in this pool.
</param>
            <exception>
throws IllegalArgumentException if bufferSize
is less than or equal to 0.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetLoadConditioningInterval(System.Int32)">
            <summary>
Sets the load conditioning interval for this pool.
</summary>
            <remarks>
This interval controls how frequently the pool will check to see if
a connection to a given server should be moved to a different
server to improve the load balance.
</remarks>
            <param>
loadConditioningInterval the connection lifetime in milliseconds
A value of -1 disables load conditioning.
</param>
            <exception>
throws IllegalArgumentException if connectionLifetime
is less than -1.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolFactory.SetFreeConnectionTimeout(System.Int32)">
            <summary>
Sets the free connection timeout for this pool.
</summary>
            <remarks>
If the pool has a max connections setting, operations will block
if all of the connections are in use. The free connection timeout
specifies how long those operations will block waiting for
a free connection before receiving an AllConnectionsInUseException.
If max connections is not set this setting has no effect.
</remarks>
            <param>
connectionTimeout the connection timeout in milliseconds
</param>
            <exception>
IllegalArgumentException if connectionTimeout 
is less than or equal to 0.
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.PoolFactory">
            <summary>
This interface provides for the configuration and creation of instances of Pool.
</summary>
        </member>
        <member name="F:gemfire.ManagedAuthInitialize.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheLoader
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedAuthInitialize.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedAuthInitialize.getCredentials(gemfire.SharedPtr&lt;gemfire.Properties&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Initialize with the given set of security properties and return the
credentials for the given client as properties.
</summary>
            <param name="securityprops">Given set of properties with which
to initialize
</param>
            <param name="server">It is the ID of the endpoint
</param>
        </member>
        <member name="M:gemfire.ManagedAuthInitialize.close">
            <summary>
Called when the cache is going down
</summary>
            <remarks>
Implementations should clean up any external
resources, such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
        </member>
        <member name="M:gemfire.ManagedAuthInitialize.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedAuthInitialize</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>IAuthInitialize</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>IAuthInitialize</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedAuthInitialize.#ctor(GemStone.GemFire.Cache.IAuthInitialize)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedAuthInitialize">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IAuthInitialize" />
object and implements the native <c>gemfire::AuthInitialize</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.#ctor(gemfire_statistics.StatisticsFactory*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.Create(gemfire_statistics.StatisticsFactory*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticsFactory.ID">
            <summary>
Returns a numeric id that can be used to identify the manager
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticsFactory.Name">
            <summary>
Returns a name that can be used to identify the manager
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.FindFirstStatisticsByType(GemStone.GemFire.Cache.Generic.StatisticsType)">
            <summary>
Return the first instance that matches the type, or NULL
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateAtomicStatistics(GemStone.GemFire.Cache.Generic.StatisticsType,System.String,System.Int64)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Generic.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> type, <c>textId</c>, and <c>numericId</c>.
</summary>
            <para>
The created instance will be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateAtomicStatistics(GemStone.GemFire.Cache.Generic.StatisticsType,System.String)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Generic.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> type, <c>textId</c>, and with a default numeric id.
</summary>
            <para>
The created instance will be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateAtomicStatistics(GemStone.GemFire.Cache.Generic.StatisticsType)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Generic.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> type, <c>textId</c>, and with default ids.
</summary>
            <para>
The created instance will be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateStatistics(GemStone.GemFire.Cache.Generic.StatisticsType,System.String,System.Int64)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Generic.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> type, <c>textId</c>, and <c>numericId</c>.
</summary>
            <para>
The created instance may not be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateStatistics(GemStone.GemFire.Cache.Generic.StatisticsType,System.String)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Generic.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> type, <c>textId</c>, and with a default numeric id.
</summary>
            <para>
The created instance may not be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateStatistics(GemStone.GemFire.Cache.Generic.StatisticsType)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Generic.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> type, <c>textId</c>, and with default ids.
</summary>
            <para>
The created instance may not be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.FindType(System.String)">
            <summary>
Finds and returns an already created <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> 
with the given <c>name</c>. Returns <c>null</c> if the type does not exist.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateType(System.String,System.String,GemStone.GemFire.Cache.Generic.StatisticDescriptor[],System.Int32)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> 
with the given <c>name</c>, <c>description</c>,and <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" /></summary>
            <exception cref="T:gemfire.IllegalArgumentException">
if a type with the given <c>name</c> already exists.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateDoubleGauge(System.String,System.String,System.String)">
            <summary>
Creates and returns an double gauge <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateDoubleGauge(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an double gauge <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with smaller values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateLongGauge(System.String,System.String,System.String)">
            <summary>
Creates and returns an long gauge <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateLongGauge(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an long gauge <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with smaller values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateIntGauge(System.String,System.String,System.String)">
            <summary>
Creates and returns an int gauge  <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateIntGauge(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an int gauge  <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with smaller values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateDoubleCounter(System.String,System.String,System.String)">
            <summary>
Creates and returns an double counter  <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateDoubleCounter(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an double counter  <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with larger values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateLongCounter(System.String,System.String,System.String)">
            <summary>
Creates and returns an long counter  <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateLongCounter(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an long counter  <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with larger values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateIntCounter(System.String,System.String,System.String)">
            <summary>
Creates and returns an int counter  <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.CreateIntCounter(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an int counter  <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with larger values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsFactory.GetExistingInstance">
            <summary>
Return a pre-existing statistics factory. Typically configured through
creation of a distributed system.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.StatisticsFactory">
            <summary>
Instances of this interface provide methods that create instances
of <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" /> and <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" />.
Every <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsFactory" /> is also a type factory.
</summary>
            <para>
A <c>StatisticsFactory</c> can create a <see cref="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor" />
statistic of three numeric types:
<c>int</c>, <c>long</c>, and <c>double</c>.  A
statistic (<c>StatisticDescriptor</c>) can either be a
<I>gauge</I> meaning that its value can increase and decrease or a
<I>counter</I> meaning that its value is strictly increasing.
Marking a statistic as a counter allows the GemFire Manager Console
to properly display a statistics whose value "wraps around" (that
is, exceeds its maximum value).
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheAttributesFactory.CreateCacheAttributes">
            <summary>
Creates a <c>CacheAttributes</c> with the current settings.
</summary>
            <returns>The newly created <c>CacheAttributes</c></returns>
            <exception cref="!:IllegalStateException">
if the current settings violate the <a href="compability.html">
compatibility</a> rules.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheAttributesFactory.SetEndpoints(System.String)">
            <summary>
Sets endpoints list to be used at the cache-level.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheAttributesFactory.SetRedundancyLevel(System.Int32)">
            <summary>
Sets redundancy level to use for regions in the cache.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheAttributesFactory.#ctor">
            <summary>
Creates a new instance of <c>CacheAttributesFactory</c> ready
to create a <c>CacheAttributes</c> with default settings.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheAttributesFactory">
            <summary>
Creates instances of <c>CacheAttributes</c>.
</summary>
            <seealso cref="T:GemStone.GemFire.Cache.Generic.CacheAttributes" />
        </member>
        <member name="F:gemfire.ManagedAuthInitializeGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheLoader
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedAuthInitializeGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedAuthInitializeGeneric.getCredentials(gemfire.SharedPtr&lt;gemfire.Properties&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Initialize with the given set of security properties and return the
credentials for the given client as properties.
</summary>
            <param name="securityprops">Given set of properties with which
to initialize
</param>
            <param name="server">It is the ID of the endpoint
</param>
        </member>
        <member name="M:gemfire.ManagedAuthInitializeGeneric.close">
            <summary>
Called when the cache is going down
</summary>
            <remarks>
Implementations should clean up any external
resources, such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
        </member>
        <member name="M:gemfire.ManagedAuthInitializeGeneric.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedAuthInitialize</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>IAuthInitialize</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>IAuthInitialize</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedAuthInitializeGeneric.#ctor(System.Object)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="userptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedAuthInitializeGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IAuthInitialize" />
object and implements the native <c>gemfire::AuthInitialize</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IAuthInitialize.Close">
            <summary>
Invoked before the cache goes down.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IAuthInitialize.GetCredentials(GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.String^},System.String)">
            <summary>
Initialize with the given set of security properties
return the credentials for the client as properties.
</summary>
            <param name="props">
the set of <c>security-*</c> properties provided to the
<see cref="!:DistributedSystem.connect" /> method
</param>
            <param name="server">
the ID of the current endpoint in the format "host:port"
</param>
            <returns>
the credentials to be used for the given server
</returns>
            <remarks>
This method can modify the given set of properties. For
example it may invoke external agents or even interact with
the user.
</remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IAuthInitialize">
            <summary>
Specifies the mechanism to obtain credentials for a client.
It is mandantory for clients when the server is running in secure
mode having a <c>security-client-authenticator</c> module specified.
Implementations should register the library path as
<c>security-client-auth-library</c> system property and factory
function (a zero argument function returning pointer to an
AuthInitialize object) as the <c>security-client-auth-factory</c>
system property.

For a managed class implementing <c>IAuthInitialize</c> the fully
qualified name of the factory function should be provided in the
form {Namespace}.{Class Name}.{Method Name} as the
<c>security-client-auth-factory</c> property.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IAuthInitialize.Close">
            <summary>
Invoked before the cache goes down.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IAuthInitialize.GetCredentials(GemStone.GemFire.Cache.Properties,System.String)">
            <summary>
Initialize with the given set of security properties
return the credentials for the client as properties.
</summary>
            <param name="props">
the set of <c>security-*</c> properties provided to the
<see cref="!:DistributedSystem.connect" /> method
</param>
            <param name="server">
the ID of the current endpoint in the format "host:port"
</param>
            <returns>
the credentials to be used for the given server
</returns>
            <remarks>
This method can modify the given set of properties. For
example it may invoke external agents or even interact with
the user.
</remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.IAuthInitialize">
            <summary>
Specifies the mechanism to obtain credentials for a client.
It is mandantory for clients when the server is running in secure
mode having a <c>security-client-authenticator</c> module specified.
Implementations should register the library path as
<c>security-client-auth-library</c> system property and factory
function (a zero argument function returning pointer to an
AuthInitialize object) as the <c>security-client-auth-factory</c>
system property.

For a managed class implementing <c>IAuthInitialize</c> the fully
qualified name of the factory function should be provided in the
form {Namespace}.{Class Name}.{Method Name} as the
<c>security-client-auth-factory</c> property.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolManager.Close">
            <summary>
Destroys all created pools.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolManager.Close(System.Boolean)">
            <summary>
Destroys all created pools.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolManager.Find(GemStone.GemFire.Cache.Generic.Region`2{System.Object^,System.Object^})">
            <summary>
Find the pool used by the given region.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolManager.Find(System.String)">
            <summary>
Find by name an existing connection pool.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolManager.GetAll">
            <summary>
Returns a map containing all the pools in this manager.
The keys are pool names and the values are Pool instances.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.PoolManager.CreateFactory">
            <summary>
Creates a new PoolFactory which is used to configure and create Pools.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.PoolManager">
            <summary>
This interface provides for the configuration and creation of instances of PoolFactory.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Pool.#ctor(gemfire.Pool*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Pool.Create(gemfire.Pool*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Pool.GetQueryService``2">
            <summary>
Returns the QueryService for this Pool.
</summary>
            <remarks>
The query operations performed using this QueryService will be executed
on the servers that are associated with this pool.
To perform Query operation on the local cache obtain the QueryService
instance from the Cache.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.Destroyed">
            <summary>
Indicates whether this Pool has been
destroyed.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Pool.Destroy">
            <summary>
Destroys this pool closing any connections it produced.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the pool is still in use
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Pool.Destroy(System.Boolean)">
            <summary>
Destroys this pool closing any connections it produced.
</summary>
            <param name="keepAlive">
whether the server should keep the durable client's
subscriptions alive for the timeout period
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the pool is still in use
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.Locators">
            <summary>
Returns an unmodifiable list of locators
this pool is using. Each locator is either one
added explicitly when the pool was created or
were discovered using the explicit locators.
</summary>
            <remarks>
If a pool has no locators then it can not discover servers or locators at runtime.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.ServerGroup">
            <summary>
Returns the server group of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.SubscriptionAckInterval">
            <summary>
Returns the subscription ack interval of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.SubscriptionMessageTrackingTimeout">
            <summary>
Returns the subscription message tracking timeout of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.SubscriptionRedundancy">
            <summary>
Returns the subscription redundancy level of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.PRSingleHopEnabled">
            <summary>
Returns the true if a pr-single-hop is set to true on this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.SubscriptionEnabled">
            <summary>
Returns the true if a server-to-client subscriptions are enabled on this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.RetryAttempts">
            <summary>
Get the retry attempts for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.StatisticInterval">
            <summary>
Get the statistic interval for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.PingInterval">
            <summary>
Get the ping interval for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.IdleTimeout">
            <summary>
Get the Idle connection timeout for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.MaxConnections">
            <summary>
Get the maximum connections for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.MinConnections">
            <summary>
Get the minimum connections for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.ReadTimeout">
            <summary>
Returns the read timeout of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.SocketBufferSize">
            <summary>
Returns the socket buffer size of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.LoadConditioningInterval">
            <summary>
Returns the load conditioning interval of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.FreeConnectionTimeout">
            <summary>
Returns the connection timeout of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Pool.Name">
            <summary>
Get the name of the pool
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Pool">
            <summary>
A pool of connections.
</summary>
            <remarks>
A pool of connections from a GemFire client to a set of GemFire servers.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.#ctor(gemfire_statistics.Statistics*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.Create(gemfire_statistics.Statistics*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncDouble(System.String,System.Double)">
            <summary>
Increments the value of the statistic of type <c>double</c> with
the given name by a given amount.
</summary>
            <param name="name">statistic name</param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncDouble(GemStone.GemFire.Cache.Generic.StatisticDescriptor,System.Double)">
            <summary>
Increments the value of the described statistic of type <c>double</c>
by the given amount.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncDouble(System.Int32,System.Double)">
            <summary>
Increments the value of the identified statistic of type <c>double</c>
by the given amount.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="delta">the value of the statistic after it has been incremented</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncLong(System.String,System.Int64)">
            <summary>
Increments the value of the statistic of type <c>long</c> with
the given name by a given amount.
</summary>
            <param name="name">statistic name</param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncLong(GemStone.GemFire.Cache.Generic.StatisticDescriptor,System.Int64)">
            <summary>
Increments the value of the described statistic of type <c>long</c>
by the given amount.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncLong(System.Int32,System.Int64)">
            <summary>
Increments the value of the identified statistic of type <c>long</c>
by the given amount.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="delta">the value of the statistic after it has been incremented</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncInt(System.String,System.Int32)">
            <summary>
Increments the value of the statistic of type <c>int</c> with
the given name by a given amount.
</summary>
            <param name="name">statistic name</param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncInt(GemStone.GemFire.Cache.Generic.StatisticDescriptor,System.Int32)">
            <summary>
Increments the value of the described statistic of type <c>int</c>
by the given amount.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.IncInt(System.Int32,System.Int32)">
            <summary>
Increments the value of the identified statistic of type <c>int</c>
by the given amount.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="delta">the value of the statistic after it has been incremented</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetRawBits(GemStone.GemFire.Cache.Generic.StatisticDescriptor)">
            <summary>
Returns the bits that represent the raw value of the described statistic.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <exception cref="!:IllegalArgumentException">
If the described statistic does not exist
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetDouble(System.String)">
            <summary>
Returns the value of the statistic of type <c>double</c> at
the given name.
</summary>
            <param name="name">statistic name</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetDouble(GemStone.GemFire.Cache.Generic.StatisticDescriptor)">
            <summary>
Returns the value of the described statistic of type <c>double</c>.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists with the specified <c>descriptor</c> or
if the described statistic is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetDouble(System.Int32)">
            <summary>
Returns the value of the identified statistic of type <c>double</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetLong(System.String)">
            <summary>
Returns the value of the statistic of type <c>long</c> at
the given name.
</summary>
            <param name="name">statistic name</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetLong(GemStone.GemFire.Cache.Generic.StatisticDescriptor)">
            <summary>
Returns the value of the described statistic of type <c>long</c>.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists with the specified <c>descriptor</c> or
if the described statistic is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetLong(System.Int32)">
            <summary>
Returns the value of the identified statistic of type <c>long</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetInt(System.String)">
            <summary>
Returns the value of the statistic of type <code>int</code> at
the given name.
</summary>
            <param name="name">statistic name</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetInt(GemStone.GemFire.Cache.Generic.StatisticDescriptor)">
            <summary>
Returns the value of the described statistic of type <code>int</code>.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists with the specified <c>descriptor</c> or
if the described statistic is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.GetInt(System.Int32)">
            <summary>
Returns the value of the identified statistic of type <c>int</c>.
whose type is <c>double</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetDouble(GemStone.GemFire.Cache.Generic.StatisticDescriptor,System.Double)">
            <summary>
Sets the value of a described statistic of type <c>double</c></summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetDouble(System.String,System.Double)">
            <summary>
Sets the value of a named statistic of type <c>double</c></summary>
            <param name="name">statistic name</param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetDouble(System.Int32,System.Double)">
            <summary>
Sets the value of a statistic with the given <c>id</c>
whose type is <c>double</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetLong(System.String,System.Int64)">
            <summary>
Sets the value of a named statistic of type <c>long</c>.
</summary>
            <param name="name">statistic name</param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetLong(GemStone.GemFire.Cache.Generic.StatisticDescriptor,System.Int64)">
            <summary>
Sets the value of a described statistic of type <c>long</c></summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetLong(System.Int32,System.Int64)">
            <summary>
Sets the value of a statistic with the given <c>id</c>
whose type is <c>long</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" /> 
or <see cref="!:#StatisticsType#nameToId" />. </param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetInt(GemStone.GemFire.Cache.Generic.StatisticDescriptor,System.Int32)">
            <summary>
Sets the value of a described statistic of type <c>int</c></summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:#StatisticsType#nameToDescriptor" /></param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetInt(System.String,System.Int32)">
            <summary>
Sets the value of a named statistic of type <c>int</c></summary>
            <param name="name">statistic name</param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.SetInt(System.Int32,System.Int32)">
            <summary>
Sets the value of a statistic with the given <c>id</c>
whose type is <c>int</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="value">value to set</param>
            <exception cref="!:IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Statistics.IsClosed">
            <summary>
Returns true if the instance has been <see cref="!:#close" /> closed.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Statistics.IsShared">
            <summary>
Returns true if the data for this instance is stored in shared memory.
Returns false if the data is store in local memory.
</summary>
            <para>
Note that all instances that are <see cref="!:#isShared" /> shared are also atomic.
</para>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Statistics.IsAtomic">
            <summary>
Returns true if modifications are atomic. This means that multiple threads
can safely modify this instance without additional synchronization.
</summary>
            <para>
Returns false if modifications are not atomic. This means that modifications
to this instance are cheaper but not thread safe.
</para>
            <para>
Note that all instances that are <see cref="!:#isShared" /> shared are also atomic.
</para>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Statistics.NumericId">
            <summary>
Gets the number associated with this instance that helps identify it.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Statistics.TextId">
            <summary>
Gets the text associated with this instance that helps identify it.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Statistics.Type">
            <summary>
Gets the <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> of this instance.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Statistics.UniqueId">
            <summary>
Gets a value that uniquely identifies this statistics.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.NameToDescriptor(System.String)">
            <summary>
Returns the descriptor of the statistic with the given name in this
statistics instance.
</summary>
            <param name="name">the statistic name</param>
            <returns>the descriptor of the statistic with the given name</returns>
            <exception cref="!:IllegalArgumentException">
if no statistic named <c>name</c> exists in this
statistics instance.
</exception>
            <see cref="!:StatisticsType#nameToId" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.NameToId(System.String)">
            <summary>
Returns the id of the statistic with the given name in this
statistics instance.
</summary>
            <param name="name">the statistic name</param>
            <returns>the id of the statistic with the given name</returns>
            <exception cref="!:IllegalArgumentException">
if no statistic named <c>name</c> exists in this
statistics instance.
</exception>
            <see cref="!:StatisticsType#nameToDescriptor" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Statistics.Close">
            <summary>
Closes these statistics.  After statistics have been closed, they
are no longer archived.
A value access on a closed statistics always results in zero.
A value modification on a closed statistics is ignored.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Statistics">
            <summary>
An instantiation of an existing <c>StatisticsType</c> object with methods for
setting, incrementing and getting individual <c>StatisticDescriptor</c> values.
</summary>
            <para>
The class is purposefully inherited from UMWrapN and not UMWrap as the destructor
of the class is protected, and so it is now not called from inside the InternalCleanup
method.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticDescriptor.#ctor(gemfire_statistics.StatisticDescriptor*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticDescriptor.Create(gemfire_statistics.StatisticDescriptor*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticDescriptor.Unit">
            <summary>
Returns the unit in which this statistic is measured.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticDescriptor.IsLargerBetter">
            <summary>
Returns true if a larger statistic value indicates better performance.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticDescriptor.IsCounter">
            <summary>
Returns true if this statistic is a counter; false if its a gauge.
Counter statistics have values that always increase.
Gauge statistics have unconstrained values.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticDescriptor.Description">
            <summary>
Returns the description of this statistic
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticDescriptor.Name">
            <summary>
Returns the name of this statistic
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticDescriptor.ID">
            <summary>
Returns the id of this statistic in a <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> class.
The id is initialized when its statistics
type is created.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.StatisticDescriptor">
            <summary>
A class that describes an individual statistic whose value is updated by an
application and may be archived by GemFire. These descriptions are gathered
together in a <see cref="T:GemStone.GemFire.Cache.Generic.StatisticsType" /> class.
</summary>
            <para>
To get an instance of this interface use an instance of
<see cref="T:GemStone.GemFire.Cache.StatisticsFactory" /> class.
</para>
            <para>
StatisticDescriptors are naturally ordered by their name.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsType.#ctor(gemfire_statistics.StatisticsType*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsType.Create(gemfire_statistics.StatisticsType*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticsType.DescriptorsCount">
            <summary>
Returns the total number of statistics descriptors in the type.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsType.NameToDescriptor(System.String)">
            <summary>
Returns the descriptor of the statistic with the given name in this
statistics instance.
</summary>
            <param name="name">the statistic name</param>
            <returns>the descriptor of the statistic with the given name</returns>
            <exception cref="!:IllegalArgumentException">
if no statistic named <c>name</c> exists in this
statistic instance.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StatisticsType.NameToId(System.String)">
            <summary>
Returns the id of the statistic with the given name in this
statistics instance.
</summary>
            <param name="name">the statistic name</param>
            <returns>the id of the statistic with the given name</returns>
            <exception cref="!:IllegalArgumentException">
if no statistic named <c>name</c> exists in this
statistic instance.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticsType.Statistics">
            <summary>
Returns descriptions of the statistics that this statistics type
gathers together.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticsType.Description">
            <summary>
Returns a description of this statistics type.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StatisticsType.Name">
            <summary>
Returns the name of this statistics type.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.StatisticsType">
            <summary>
This class is used to describe a logical collection of StatisticDescriptors.These descriptions
are used to create an instance of <see cref="P:GemStone.GemFire.Cache.Generic.StatisticsType.Statistics" /> class.
</summary>
            <para>
To get an instance of this interface use an instance of
<see cref="T:GemStone.GemFire.Cache.StatisticsFactory" /> class.
</para>
            <para>
The class is purposefully inherited from UMWrapN and not UMWrap as the destructor
of the class is protected, and so it is now not called from inside the InternalCleanup
method.
</para>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheWriterAdapter`2">
            <summary>
Utility class that implements all methods in <c>ICacheWriter</c>
with empty implementations. Applications can subclass this class
and only override the methods for the events of interest.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheListenerAdapter`2">
            <summary>
Utility class that implements all methods in <c>ICacheListener</c>
with empty implementations. Applications can subclass this class
and only override the methods for the events of interest.
</summary>
        </member>
        <member name="M:_memccpy(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)">
@file

</member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.#ctor(gemfire.AttributesMutator*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.Create(gemfire.AttributesMutator*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetCacheWriter(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the writer of the region.
The previous cache writer will be replaced with a writer created
using the factory function provided in the given library.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheWriter</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheWriter</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetCacheWriter(GemStone.GemFire.Cache.ICacheWriter)">
            <summary>
Sets the CacheListener for the region.
The previous cache writer (if any) will be replaced with the given <c>cacheWriter</c>.
</summary>
            <param name="cacheWriter">
user-defined cache writer, or null for no cache writer
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetCacheLoader(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the loader of the region.
The previous cache loader will be replaced with a loader created
using the factory function provided in the given library.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheLoader</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheLoader</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetCacheLoader(GemStone.GemFire.Cache.ICacheLoader)">
            <summary>
Sets the CacheLoader for the region.
The previous cache loader (if any) will be replaced with the given <c>cacheLoader</c>.
</summary>
            <param name="cacheLoader">
user-defined cache loader, or null for no cache loader
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetCacheListener(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the listener of the region.
The previous cache listener will be replaced with a listener created
using the factory function provided in the given library.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheListener</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheListener</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)">
            <summary>
Sets the CacheListener for the region.
The previous cache listener (if any) will be replaced with the given <c>cacheListener</c>.
</summary>
            <param name="cacheListener">
user-defined cache listener, or null for no cache listener
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetLruEntriesLimit(System.UInt32)">
            <summary>
Sets the maximum entry count in the region before LRU eviction.
</summary>
            <param name="entriesLimit">the number of entries to allow, or 0 to disable LRU</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the new entriesLimit changes LRU from
disabled to enabled or enabled to disabled.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetRegionTimeToLiveAction(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Sets the timeToLive action for the region itself.
</summary>
            <param name="action">
the timeToLiv eaction for this region
</param>
            <returns>the previous action</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetRegionTimeToLive(System.Int32)">
            <summary>
Sets the timeToLive duration for the region itself.
</summary>
            <param name="timeToLive">
the timeToLive for this region, in seconds, or 0 to disable time-to-live
</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the new timeToLive changes region expiration from
disabled to enabled or enabled to disabled.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetRegionIdleTimeoutAction(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Sets the idleTimeout action for the region itself.
</summary>
            <param name="action">
the idleTimeout action for this region
</param>
            <returns>the previous action</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetRegionIdleTimeout(System.Int32)">
            <summary>
Sets the idleTimeout duration for the region itself.
</summary>
            <param name="idleTimeout">
the idleTimeout for this region, in seconds, or 0 to disable idle timeout
</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the new idleTimeout changes region expiration from
disabled to enabled or enabled to disabled.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetEntryTimeToLiveAction(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Set the timeToLive action for region entries.
</summary>
            <param name="action">
the timeToLive action for entries in this region
</param>
            <returns>the previous action</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetEntryTimeToLive(System.Int32)">
            <summary>
Sets the timeToLive duration for region entries.
</summary>
            <param name="timeToLive">
the timeToLive in seconds for entries in this region, or 0 to disable time-to-live
</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the new timeToLive changes entry expiration from
disabled to enabled or enabled to disabled
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetEntryIdleTimeoutAction(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Sets the idleTimeout action for region entries.
</summary>
            <param name="action">
the idleTimeout action for entries in this region
</param>
            <returns>the previous action</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesMutator.SetEntryIdleTimeout(System.Int32)">
            <summary>
Sets the idleTimeout duration for region entries.
</summary>
            <param name="idleTimeout">
the idleTimeout in seconds for entries in this region, or 0 for no idle timeout
</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the new idleTimeout changes entry expiration from
disabled to enabled or enabled to disabled.
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.AttributesMutator">
            <summary>
Supports modification of certain region attributes after the region
has been created.
</summary>
            <remarks>
                <para>
It is required that the attributes be completely initialized using an
<see cref="T:GemStone.GemFire.Cache.AttributesFactory" /> before creating the region.
AttributesMutator can be applied to adjusting and tuning a subset of
attributes that are modifiable at runtime.
</para>
                <para>
The setter methods all return the previous value of the attribute.
</para>
            </remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Region.GetAttributesMutator" />
            <seealso cref="T:GemStone.GemFire.Cache.RegionAttributes" />
            <seealso cref="T:GemStone.GemFire.Cache.AttributesFactory" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DelegateWrapperGeneric.NativeDelegateGeneric">
            <summary>
Returns the native <c>gemfire::Serializable</c> object by invoking the
managed delegate provided in the constructor.
</summary>
            <returns>
Native <c>gemfire::Serializable</c> object after invoking the managed
delegate and wrapping inside a <c>ManagedCacheableKey</c> object.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DelegateWrapperGeneric.#ctor(GemStone.GemFire.Cache.Generic.TypeFactoryMethodGeneric)">
            <summary>
Constructor to wrap the given managed delegate.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DelegateWrapperGeneric">
            <summary>
Template class to wrap a managed <see cref="D:gemfire.TypeFactoryMethod" />
delegate that returns an <see cref="T:GemStone.GemFire.Cache.Generic.IGFSerializable" /> object. It contains
a method that converts the managed object gotten by invoking the
delegate to the native <c>gemfire::Serializable</c> object
(using the provided wrapper class constructor).
</summary>
            <remarks>
This class is to enable interopibility between the managed and unmanaged
worlds when registering types.
In the managed world a user would register a managed type by providing
a factory delegate returning an object of that type. However, the
native implementation requires a factory function that returns an
object implementing <c>gemfire::Serializable</c>. Normally this would not
be possible since we require to dynamically generate a new function
for a given delegate.

Fortunately in the managed world the delegates contain an implicit
'this' pointer. Thus we can have a universal delegate that contains
the given managed delegate (in the 'this' pointer) and returns the
native <c>gemfire::Serializable</c> object. Additionally marshalling
services provide <c>Marshal.GetFunctionPointerForDelegate</c> which gives
a function pointer for a delegate which completes the conversion.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Struct.Create(gemfire.Serializable*)">
            <summary>
Factory function to register wrapper
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Struct.#ctor(gemfire.Serializable*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Struct.Next">
            <summary>
Get the next field value item available in this <c>Struct</c>.
</summary>
            <returns>
A reference to the next item in the <c>Struct</c>
or null if no more available.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Struct.Length">
            <summary>
Get the number of field values available.
</summary>
            <returns>the number of field values available.</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Struct.HasNext">
            <summary>
Check whether another field value is available to iterate over
in this <c>Struct</c>.
</summary>
            <returns>true if available otherwise false.</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Struct.Set">
            <summary>
Get the parent <c>StructSet</c> of this <c>Struct</c>.
</summary>
            <returns>
A reference to the parent <c>StructSet</c> of this <c>Struct</c>.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Struct.default(System.String)">
            <summary>
Get the field value for the given field name.
</summary>
            <returns>The value of the field.</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the field name is not found.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Struct.Item(System.UInt32)">
            <summary>
Get the field value for the given index number.
</summary>
            <returns>
The value of the field or null if index is out of bounds.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Struct">
            <summary>
Encapsulates a row of query struct set.
</summary>
            <remarks>
A Struct has a StructSet as its parent. It contains the field values
returned after executing a Query obtained from a QueryService which in turn
is obtained from a Cache.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableUndefined.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableUndefined.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableUndefined.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableUndefined.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableUndefined.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableUndefined.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableUndefined.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableUndefined">
            <summary>
Encapsulate an undefined result.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashTable.Create(System.Object)">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashTable.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableHashTable.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashTable.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the HashTable.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashTable.#ctor(System.Object)">
            <summary>
Allocates a new instance copying from the given dictionary.
</summary>
            <param name="dictionary">
The dictionary whose elements are copied to this HashTable.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashTable.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableHashTable">
            <summary>
A mutable <c>ICacheableKey</c> to <c>IGFSerializable</c> hash table
that can serve as a distributable object for caching. This class
extends .NET generic <c>Dictionary</c> class.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableLinkedHashSet">
            <summary>
A mutable <c>ICacheableKey</c> hash set wrapper that can serve as
a distributable object for caching. This is provided for compability
with java side though is functionally identical to
<c>CacheableHashSet</c> i.e. does not provide the linked semantics of
java <c>LinkedHashSet</c>.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableHashSet">
            <summary>
A mutable <c>ICacheableKey</c> hash set wrapper that can serve as
a distributable object for caching.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObject.#ctor(System.Object)">
            <summary>
Allocates a new instance from the given object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObject.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableObject.Value">
            <summary>
Gets the object value.
</summary>
            <remarks>
The user can modify the object and the changes shall be reflected
immediately in the local cache. For this change to be propagate to
other members of the distributed system, the object needs to be
put into the cache.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableObject.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableObject.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObject.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserializes the <see cref="T:System.Object" /> using
<see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" /> class.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObject.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this <see cref="T:System.Object" /> using
<see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" /> class.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObject.Create(System.Object)">
            <summary>
Static function to create a new instance from the given object.
</summary>
            <remarks>
If the given object is null then this method returns null.
</remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableObject">
            <summary>
An mutable generic <see cref="T:System.Object" /> wrapper that can
serve as a distributable value for caching.
</summary>
            <remarks>
                <para>
This class can serialize any class which has either the
[Serializable] attribute set or implements
<see cref="T:System.Runtime.Serialization.ISerializable" /> interface.
However, for better efficiency the latter should be avoided and the
user should implement <see cref="!:../../IGFSerializable" /> instead.
</para>
                <para>
The user must keep in mind that the rules that apply to runtime
serialization would be the rules that apply to this class. For
the serialization will be carried out by serializing all the
members (public/private/protected) of the class. Each of the
contained classes should also have either the [Serializable]
attribute set or implement <c>ISerializable</c> interface.
</para>
            </remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheAttributesFactory.CreateCacheAttributes">
            <summary>
Creates a <c>CacheAttributes</c> with the current settings.
</summary>
            <returns>The newly created <c>CacheAttributes</c></returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the current settings violate the <a href="compability.html">
compatibility</a> rules.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheAttributesFactory.SetEndpoints(System.String)">
            <summary>
Sets endpoints list to be used at the cache-level.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheAttributesFactory.SetRedundancyLevel(System.Int32)">
            <summary>
Sets redundancy level to use for regions in the cache.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheAttributesFactory.#ctor">
            <summary>
Creates a new instance of <c>CacheAttributesFactory</c> ready
to create a <c>CacheAttributes</c> with default settings.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheAttributesFactory">
            <summary>
Creates instances of <c>CacheAttributes</c>.
</summary>
            <seealso cref="T:GemStone.GemFire.Cache.CacheAttributes" />
        </member>
        <member name="M:gemfire.CacheAttributesFactory.createCacheAttributes">
Creates a <code>CacheAttributes</code> with the current settings.
@return the newly created <code>CacheAttributes</code>
@throws IllegalStateException if the current settings violate the
<a href="compatibility.html">compatibility rules</a></member>
        <member name="M:gemfire.CacheAttributesFactory.setEndpoints(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the end points for this native client.
@deprecated since 3.5, use {@link PoolFactory#addServer} or {@link PoolFactory#addLocator}instead.

</member>
        <member name="M:gemfire.CacheAttributesFactory.setRedundancyLevel(System.Int32)">
Sets the redundancy level for this native client. Notification
queues are attempted to be maintained on n servers ( if possible )
where n = redundancy level.
@deprecated since 3.5, use {@link PoolFactory#setSubscriptionRedundancy} instead.

</member>
        <member name="M:gemfire.CacheAttributesFactory.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.CacheAttributesFactory.#ctor">
@brief public methods

@brief constructor
Creates a new instance of CacheAttributesFactory ready to create a
      <code>CacheAttributes</code> with default settings.

</member>
        <member name="T:gemfire.CacheAttributesFactory">
 Creates instances of <code>CacheAttributes</code>.

 @see CacheAttributes

</member>
        <member name="P:GemStone.GemFire.Utils.LastError">
            <summary>
Utility method to get the calling thread's last system error code.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Utils.LoadMethodFrom(System.String,System.String,System.String)">
            <summary>
Load a method from the given assembly name using the default
constructor (if not a static method) of the given type.
</summary>
            <param name="assemblyName">The name of the assembly.</param>
            <param name="typeName">
The name of the class containing the method.
</param>
            <param name="methodName">The name of the method.</param>
            <returns>
The <c>System.Reflection.MethodInfo</c> for the given method,
or null if the method is not found.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Utils.LoadMethod(System.String,System.String,System.String)">
            <summary>
Load a method from the given assembly path using the default
constructor (if not a static method) of the given type.
</summary>
            <param name="assemblyPath">The path of the assembly.</param>
            <param name="typeName">
The name of the class containing the method.
</param>
            <param name="methodName">The name of the method.</param>
            <returns>
The <c>System.Reflection.MethodInfo</c> for the given method,
or null if the method is not found.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Utils">
            <summary>
Some static utility methods.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionEntry.#ctor(gemfire.RegionEntry*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionEntry.Create(gemfire.RegionEntry*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionEntry.IsDestroyed">
            <summary>
True if this entry has been destroyed.
</summary>
            <remarks>
Does not throw a <c>EntryDestroyedException</c> if this entry
has been destroyed.
</remarks>
            <returns>true if this entry has been destroyed</returns>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache is closed at the time of invocation
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionEntry.Statistics">
            <summary>
Returns the statistics for this entry.
</summary>
            <returns>the CacheStatistics for this entry</returns>
            <exception cref="T:GemStone.GemFire.Cache.StatisticsDisabledException">
if statistics have been disabled for this region
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionEntry.Region">
            <summary>
Returns the region that contains this entry.
</summary>
            <returns>the region that contains this entry</returns>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache is closed at the time of invocation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryDestroyedException">
if the entry has been destroyed
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionEntry.Value">
            <summary>
Returns the value of this entry in the local cache. Does not invoke
an <c>ICacheLoader</c>, does not do a netSearch, netLoad, etc.
</summary>
            <returns>
the value, or null if this entry is invalid -- see <see cref="P:GemStone.GemFire.Cache.RegionEntry.IsDestroyed" /></returns>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache is closed at the time of invocation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryDestroyedException">
if the entry has been destroyed
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionEntry.Key">
            <summary>
Returns the key for this entry.
</summary>
            <returns>the key for this entry</returns>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache is closed at the time of invocation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryDestroyedException">
if the entry has been destroyed
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.RegionEntry">
            <summary>
An object in a region that represents an <em>entry</em>, that is, a key-value pair.
</summary>
            <remarks>
This object's operations are not distributed, do not acquire any locks, and do not affect
<c>CacheStatistics</c>.

Unless otherwise noted, all of these methods throw a
<c>CacheClosedException</c> if the cache is closed at the time of
invocation, or an <c>EntryDestroyedException</c> if the entry has been
destroyed.

Call <see cref="P:GemStone.GemFire.Cache.RegionEntry.IsDestroyed" /> to see if an entry has already been destroyed.
</remarks>
        </member>
        <member name="M:gemfire.ManagedVisitorGeneric.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedVisitorGeneric.visit(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Invokes the managed <c>PropertyVisitor</c> delegate for the given
<c>Property</c> key and value.
</summary>
        </member>
        <member name="M:gemfire.ManagedVisitorGeneric.#ctor(System.Object)">
            <summary>
Create a <c>gemfire::Properties::Visitor</c> from the given managed
<c>PropertyVisitor</c> delegate.
</summary>
        </member>
        <member name="T:gemfire.ManagedVisitorGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.PropertyVisitor" />
delegate and implements the native <c>gemfire::Properties::Visitor</c> interface.
</summary>
        </member>
        <member name="F:ACE_5_6_0.ACE_Handle_Set_Iterator.word_num_">
Number of the word we're iterating over (typically between 0..7).
</member>
        <member name="T:ACE_5_6_0.ACE_Handle_Set_Iterator.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set_Iterator.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set_Iterator.reset_state">
Reset the state of the iterator by reinitializing the state
that we maintain.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set_Iterator.Dispose">
Default dtor.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set_Iterator.#ctor(ACE_5_6_0.ACE_Handle_Set!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Handle_Set_Iterator">
 @class ACE_Handle_Set_Iterator

 @brief Iterator for the ACE_Handle_Set abstraction.

</member>
        <member name="F:ACE_5_6_0.ACE_Handle_Set.nbits_">
Table that maps bytes to counts of the enabled bits in each value
from 0 to 255.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.count_bits(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Counts the number of bits enabled in N.  Uses a table lookup to
speed up the count.
</member>
        <member name="F:ACE_5_6_0.ACE_Handle_Set.mask_">
Bitmask.
</member>
        <member name="F:ACE_5_6_0.ACE_Handle_Set.max_handle_">
Current max handle.
</member>
        <member name="F:ACE_5_6_0.ACE_Handle_Set.size_">
Size of the set, i.e., a count of the number of enabled bits.
</member>
        <member name="T:ACE_5_6_0.ACE_Handle_Set.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.max_set">
Returns the number of the large bit.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.num_set">
Returns a count of the number of enabled bits.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.clr_bit(System.Void*)">
Disables the @a handle.  No range checking is performed so
@a handle must be less than @c ACE_DEFAULT_SELECT_REACTOR_SIZE.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.set_bit(System.Void*)">
Enables the @a handle.  No range checking is performed so @a handle
must be less than @c ACE_DEFAULT_SELECT_REACTOR_SIZE.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.is_set(System.Void*)">
Checks whether @a handle is enabled.  No range checking is
performed so @a handle must be less than
@c ACE_DEFAULT_SELECT_REACTOR_SIZE.

</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.reset">
Initialize the bitmask to all 0s and reset the associated fields.
</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.#ctor(fd_set!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor, initializes the handle set from a given mask.

</member>
        <member name="M:ACE_5_6_0.ACE_Handle_Set.#ctor">
Constructor, initializes the bitmask to all 0s.
</member>
        <member name="F:gemfire.DistributedSystemImpl.m_authLock">
Guard for getAuthLoader()

</member>
        <member name="M:gemfire.DistributedSystemImpl.currentInstances">
The current number of connection instances created using
connectionOrGetInstance().

</member>
        <member name="M:gemfire.DistributedSystemImpl.disconnectInstance">
To disconnect appdomain instance

</member>
        <member name="M:gemfire.DistributedSystemImpl.connectInstance">
To connect new appdomain instance

</member>
        <member name="M:gemfire.DistributedSystemImpl.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.DistributedSystem*)">
@brief constructors

</member>
        <member name="M:gemfire.DistributedSystemImpl.disconnect">
Retrieve the MemberId used to create this Cache. 
</member>
        <member name="M:gemfire.DistributedSystemImpl.Dispose">
@brief public methods

@brief destructor

</member>
        <member name="T:gemfire.DistributedSystemImpl">
@class DistributedSystemImpl DistributedSystemImpl.hpp
A "connection" to a GemFire distributed system.
The connection will be through a (host, port) pair.

</member>
        <member name="M:gemfire.CacheXmlParser.startPool(System.Byte!System.Runtime.CompilerServices.IsConst**)">
Pool handlers 
</member>
        <member name="M:gemfire.CacheXmlParser.setPoolInfo(gemfire.PoolFactory*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Pool helper 
</member>
        <member name="F:gemfire.CacheXmlCreation.pools">
This cache's pools 
</member>
        <member name="F:gemfire.CacheXmlCreation.rootRegions">
This cache's roots 
</member>
        <member name="M:gemfire.CacheXmlCreation.create(gemfire.Cache*)">
 Fills in the contents of a {@link Cache} based on this creation
 object's state.

 @param  cache
         The cache which is to be populated
 @throws OutOfMemoryException if the memory allocation failed
 @throws NotConnectedException if the cache is not connected
 @throws InvalidArgumentException if the attributePtr is NULL.
         or if RegionAttributes is null or if regionName is null,
         the empty   string, or contains a '/'
 @throws RegionExistsException
 @throws CacheClosedException if the cache is closed
         when the region is created.
 @throws UnknownException otherwise


</member>
        <member name="M:gemfire.CacheXmlCreation.addPool(gemfire.PoolXmlCreation*)">
Adds a pool to the cache 
</member>
        <member name="M:gemfire.CacheXmlCreation.addRootRegion(gemfire.RegionXmlCreation*)">
Adds a root region to the cache

</member>
        <member name="M:gemfire.CacheXmlCreation.#ctor">
Creates a new <code>CacheXmlCreation</code> with no root region

</member>
        <member name="T:gemfire.CacheXmlCreation">
Represents a {@link Cache} that is created declaratively.
@author Sonal Gadkari
@since 1.0

</member>
        <member name="M:gemfire.PoolXmlCreation.create">
Add a locator 
Add a server 
 Creates a {@link Pool} using the 
 description provided by this <code>PoolXmlCreation</code>.

 @throws OutOfMemoryException if the memory allocation failed
 @throws NotConnectedException if the cache is not connected
 @throws InvalidArgumentException if the attributePtr is NULL.
 or if PoolAttributes is null or if poolName is null or
 the empty string
 @throws PoolExistsException
 @throws CacheClosedException if the cache is closed
         at the time of region creation
 @throws UnknownException otherwise


</member>
        <member name="M:gemfire.PoolXmlCreation.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.PoolFactory&gt;)">
Creates a new <code>PoolXmlCreation</code> with the given pool name.

</member>
        <member name="F:gemfire.PoolXmlCreation.poolName">
The name of this pool 
</member>
        <member name="F:gemfire.PoolXmlCreation.poolFactory">
An <code>AttributesFactory</code> for creating default
   * <code>PoolAttribute</code>s 
</member>
        <member name="T:gemfire.PoolXmlCreation">
Represents a {@link Pool} that is created declaratively.
@author Vishal Rao
@since 3.0

</member>
        <member name="M:gemfire.RegionXmlCreation.create(gemfire.SharedPtr&lt;gemfire.Region&gt;)">
 Creates a {@link Region} with the given parent using the
 description provided by this <code>RegionCreation</code>.

 @throws OutOfMemoryException if the memory allocation failed
 @throws NotConnectedException if the cache is not connected
 @throws InvalidArgumentException if the attributePtr is NULL.
 or if RegionAttributes is null or if regionName is null,
 the empty string,or contains a '/'
 @throws RegionExistsException
 @throws CacheClosedException if the cache is closed
         at the time of region creation
 @throws UnknownException otherwise


</member>
        <member name="M:gemfire.RegionXmlCreation.createRoot(gemfire.Cache*)">
 Creates a root {@link Region} in a given <code>Cache</code>
 based on the description provided by this
 <code>RegionCreation</code>

 @throws OutOfMemoryException if the memory allocation failed
 @throws NotConnectedException if the cache is not connected
 @throws InvalidArgumentException if the attributePtr is NULL.
 or if RegionAttributes is null or if regionName is null,
 the empty   string, or contains a '/'
 @throws RegionExistsException
 @throws CacheClosedException if the cache is closed
         at the time of region creation
 @throws UnknownException otherwise

</member>
        <member name="M:gemfire.RegionXmlCreation.getAttributes">
Gets the attributes of this region

</member>
        <member name="M:gemfire.RegionXmlCreation.setAttributes(gemfire.SharedPtr&lt;gemfire.RegionAttributes&gt;)">
Sets the attributes of this region

</member>
        <member name="M:gemfire.RegionXmlCreation.addSubregion(gemfire.RegionXmlCreation*)">
Adds a subregion with the given name to this region

</member>
        <member name="M:gemfire.RegionXmlCreation.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Boolean)">
Creates a new <code>RegionCreation</code> with the given name.

</member>
        <member name="M:gemfire.RegionXmlCreation.fillIn(gemfire.SharedPtr&lt;gemfire.Region&gt;)">
 Fills in the state (that is, creates subregions)
 of a given <code>Region</code> based on the description provided
 by this <code>RegionXmlCreation</code>.


</member>
        <member name="F:gemfire.RegionXmlCreation.subRegions">
This region's subregions 
</member>
        <member name="F:gemfire.RegionXmlCreation.regAttrs">
The attributes of this region 
</member>
        <member name="F:gemfire.RegionXmlCreation.isRoot">
True if region is a root 
</member>
        <member name="F:gemfire.RegionXmlCreation.attrId">
attributeId mentioned in XML file" 
</member>
        <member name="F:gemfire.RegionXmlCreation.regionName">
The name of this region 
</member>
        <member name="F:gemfire.RegionXmlCreation.attrFactory">
An <code>AttributesFactory</code> for creating default
   * <code>RegionAttribute</code>s 
</member>
        <member name="T:gemfire.RegionXmlCreation">
Represents a {@link Region} that is created declaratively.
@author Sonal Gadkari
@since 1.0

</member>
        <member name="F:gemfire.CacheXml.REFID">
reference to a named attribute 
</member>
        <member name="F:gemfire.CacheXml.ID">
Name of the named region attributes 
</member>
        <member name="F:gemfire.CacheXml.POOL_NAME">
Pool elements and attributes 
</member>
        <member name="F:gemfire.CacheXml.PROPERTY">
The name of the <code>property</code> value 
</member>
        <member name="F:gemfire.CacheXml.PROPERTIES">
The name of the <code>properties</code> value 
</member>
        <member name="F:gemfire.CacheXml.PERSISTENCE_MANAGER">
The name of the <code>persistence-manager</code> value 
</member>
        <member name="F:gemfire.CacheXml.LOCAL_DESTROY">
The name of the <code>local-destroy</code> value 
</member>
        <member name="F:gemfire.CacheXml.LOCAL_INVALIDATE">
The name of the <code>local-invalidate</code> value 
</member>
        <member name="F:gemfire.CacheXml.NONE">
The name of the <code>none</code> value 
</member>
        <member name="F:gemfire.CacheXml.PERSIST">
The name of the <code>persist</code> value 
</member>
        <member name="F:gemfire.CacheXml.OVERFLOWS">
The name of the <code>overflows</code> value 
</member>
        <member name="F:gemfire.CacheXml.DESTROY">
The name of the <code>destroy</code> value 
</member>
        <member name="F:gemfire.CacheXml.INVALIDATE">
The name of the <code>invalidate</code> value 
</member>
        <member name="F:gemfire.CacheXml.GLOBAL">
The name of the <code>global</code> value 
</member>
        <member name="F:gemfire.CacheXml.DISTRIBUTED_ACK">
The name of the <code>distributed-ack</code> value 
</member>
        <member name="F:gemfire.CacheXml.DISTRIBUTED_NO_ACK">
The name of the <code>distributed-no-ack</code> value 
</member>
        <member name="F:gemfire.CacheXml.LOCAL">
The name of the <code>local</code> value 
</member>
        <member name="F:gemfire.CacheXml.ACTION">
The name of the <code>action</code> attribute 
</member>
        <member name="F:gemfire.CacheXml.TIMEOUT">
The name of the <code>timeout</code> attribute 
</member>
        <member name="F:gemfire.CacheXml.STATISTICS_ENABLED">
The name of the <code>statistics-enabled</code> attribute 
</member>
        <member name="F:gemfire.CacheXml.LOAD_FACTOR">
The name of the <code>serialize-values</code> attribute 
The name of the <code>load-factor</code> attribute 
</member>
        <member name="F:gemfire.CacheXml.CONCURRENCY_LEVEL">
The name of the <code>initial-capacity</code> attribute 
</member>
        <member name="F:gemfire.CacheXml.INITIAL_CAPACITY">
The name of the <code>keep-alive-timeout</code> attribute 
The name of the <code>initial-capacity</code> attribute 
</member>
        <member name="F:gemfire.CacheXml.CLIENT_NOTIFICATION_ENABLED">
The name of the <code>client-notification</code> attribute 
</member>
        <member name="F:gemfire.CacheXml.SCOPE">
The name of the <code>scope</code> attribute 
</member>
        <member name="F:gemfire.CacheXml.PARTITION_RESOLVER">
The name of the <code>partition-resolver</code> element 
</member>
        <member name="F:gemfire.CacheXml.CACHE_LISTENER">
The name of the <code>cache-listener</code> element 
</member>
        <member name="F:gemfire.CacheXml.CACHE_WRITER">
The name of the <code>cache-writer</code> element 
</member>
        <member name="F:gemfire.CacheXml.CACHE_LOADER">
The name of the <code>cache-loader</code> element 
</member>
        <member name="F:gemfire.CacheXml.EXPIRATION_ATTRIBUTES">
The name of the <code>expiration-attributes</code> element 
</member>
        <member name="F:gemfire.CacheXml.ENTRY_IDLE_TIME">
The name of the <code>entry-idle-time</code> element 
</member>
        <member name="F:gemfire.CacheXml.ENTRY_TIME_TO_LIVE">
The name of the <code>entry-time-to-live</code> element 
</member>
        <member name="F:gemfire.CacheXml.REGION_IDLE_TIME">
The name of the <code>region-idle-time</code> element 
</member>
        <member name="F:gemfire.CacheXml.REGION_TIME_TO_LIVE">
The name of the <code>region-time-to-live</code> element 
</member>
        <member name="F:gemfire.CacheXml.ENDPOINTS">
The name of the <code>endpoints</code> attribute *
</member>
        <member name="F:gemfire.CacheXml.DISK_POLICY">
The name of the <code>lru-eviction-action</code> attribute *
</member>
        <member name="F:gemfire.CacheXml.LRU_ENTRIES_LIMIT">
The name of the <code>key-constraint</code> element 
</member>
        <member name="F:gemfire.CacheXml.REGION_ATTRIBUTES">
The name of the <code>region-attributes</code> element 
</member>
        <member name="F:gemfire.CacheXml.ROOT_REGION">
The name of the <code>vm-root-region</code> element 
</member>
        <member name="F:gemfire.CacheXml.PDX">
The name of the <code>pdx</code> element 
</member>
        <member name="F:gemfire.CacheXml.REGION">
The name of the <code>region</code> element 
</member>
        <member name="F:gemfire.CacheXml.REDUNDANCY_LEVEL">
The name of the <code>redundancy-level</code> attribute *
</member>
        <member name="F:gemfire.CacheXml.CACHE">
The name of the <code>cache</code> element 
</member>
        <member name="M:gemfire.PooledBase.postPool">
called just after removing an object from the pool. 
</member>
        <member name="M:gemfire.PooledBase.prePool">
called just prior to inserting an object back into the pool. 
</member>
        <member name="T:gemfire.PooledBase">
 @class PooledBase PooledBase.hpp

 This abstract base class is the base class of all user objects
 that have the shared capability of reference counting.

</member>
        <member name="M:gemfire.CacheImpl.readyForEvents">
Send the "client ready" message to the server.

</member>
        <member name="M:gemfire.CacheImpl.#ctor(gemfire.Cache*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.DistributedSystem&gt;,System.Boolean)">
@brief constructors

</member>
        <member name="M:gemfire.CacheImpl.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.CacheImpl.setSearchTimeout(System.Int32)">
 FUTURE: not used currently. Gets the number of seconds a cache
 {@link Region::get} operation
 can spend searching for a value before it times out.
 The search includes any time spent loading the object.
 When the search times out, it causes the get to fail by throwing
 an exception.
 This method does not throw
 <code>CacheClosedException</code> if the cache is closed.
 Sets the number of seconds a cache get operation can spend searching
 for a value.

 @throws IllegalArgumentException if <code>seconds</code> is less than zero

</member>
        <member name="M:gemfire.CacheImpl.rootRegions(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.Region&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Returns a set of root regions in the cache. Does not cause any
 shared regions to be mapped into the cache. This set is a snapshot and
 is not backed by the Cache. The regions passed in are cleared.

 @param regions the region collection object containing the returned set of regions when the function returns

</member>
        <member name="M:gemfire.CacheImpl.createRegion(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.RegionAttributes&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Region&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Creates a region  using the specified
 RegionAttributes.

 @param name the name of the region to create
 @param aRegionAttributes the attributes of the root region
 @todo change return to param for regionPtr...
 @param regionPtr the pointer object pointing to the returned region object when the function returns
 @throws InvalidArgumentException if the attributePtr is NULL.
 @throws RegionExistsException if a region is already in
 this cache
 @throws CacheClosedException if the cache is closed
 @throws OutOfMemoryException if the memory allocation failed
 @throws NotConnectedException if the cache is not connected
 @throws UnknownException otherwise

</member>
        <member name="M:gemfire.CacheImpl.close(System.Boolean)">
Terminates this object cache and releases all the local resources.
After this cache is closed, any further
method call on this cache or any region object will throw
<code>CacheClosedException</code>, unless otherwise noted.
@param keepalive whether to keep a durable client's queue alive.
@throws CacheClosedException,  if the cache is already closed.

</member>
        <member name="M:gemfire.CacheImpl.getDistributedSystem(gemfire.SharedPtr&lt;gemfire.DistributedSystem&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the distributed system that this cache was
{@link CacheFactory::create created} with.

</member>
        <member name="M:gemfire.CacheImpl.setAttributes(gemfire.SharedPtr&lt;gemfire.CacheAttributes&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the <code>CacheAttributes</code> for this cache. 
</member>
        <member name="M:gemfire.CacheImpl.getAttributes">
Get the <code>CacheAttributes</code> for this cache. 
</member>
        <member name="M:gemfire.CacheImpl.isClosed">
 Indicates if this cache has been closed.
 After a new cache object is created, this method returns false;
 After the close is called on this cache object, this method
 returns true.

 @return true, if this cache is closed; false, otherwise

</member>
        <member name="M:gemfire.CacheImpl.getName">
Returns the name of this cache.
   * @return the string name of this cache

</member>
        <member name="M:gemfire.CacheImpl.netDown">
@brief public methods

</member>
        <member name="T:gemfire.CachePerfStats">
hold statistics for cache.. 
</member>
        <member name="M:gemfire.RemoteQueryService.executeAllCqs(gemfire.TcrEndpoint*)">
execute all cqs on the endpoint after failover

</member>
        <member name="M:gemfire.CqService.getOperation(System.Int32)">
Returns the Operation for the given EnumListenerEvent type.
@param eventType
@return Operation

</member>
        <member name="M:gemfire.CqService.invokeCqListeners(stlp_std.map&lt;stlp_std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,stlp_std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},stlp_std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;,gemfire.SharedPtr&lt;gemfire.Serializable&gt;,gemfire.SharedArrayPtr&lt;System.Byte,0x2e&gt;,gemfire.SharedPtr&lt;gemfire.EventId&gt;)">
Invokes the CqListeners for the given CQs.
@param cqs list of cqs with the cq operation from the Server.
@param messageType base operation
@param key
@param value

</member>
        <member name="M:gemfire.CqService.cleanup">
Cleans up the CqService.

</member>
        <member name="M:gemfire.CqService.closeCqService">
 Close the CQ Service after cleanup if any.


</member>
        <member name="M:gemfire.CqService.getCqServiceStatistics">
Get statistics information for all CQs
@return the CqServiceStatistics

</member>
        <member name="M:gemfire.CqService.closeAllCqs">
Close all CQs executing in this client, and release resources
associated with executing CQs.
CqQuerys created by other client are unaffected.

</member>
        <member name="M:gemfire.CqService.stopCqs(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CqQuery&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Stops all the specified cqs.

</member>
        <member name="M:gemfire.CqService.stopAllClientCqs">
Stops all the cqs

</member>
        <member name="M:gemfire.CqService.executeCqs(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CqQuery&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.TcrEndpoint*)">
Executes all the given cqs on the specified endpoint after failover.

</member>
        <member name="M:gemfire.CqService.executeCqs(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CqQuery&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Executes all the given cqs.

</member>
        <member name="M:gemfire.CqService.executeAllClientCqs(gemfire.TcrEndpoint*)">
Executes all CQs on the specified endpoint after failover.

</member>
        <member name="M:gemfire.CqService.executeAllClientCqs(System.Boolean)">
Executes all the cqs on this client.

</member>
        <member name="M:gemfire.CqService.getAllCqs(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CqQuery&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve  all registered CQs

</member>
        <member name="M:gemfire.CqService.clearCqQueryMap">
Clears the CQ Query Map.

</member>
        <member name="M:gemfire.CqService.getCq(stlp_std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,stlp_std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},stlp_std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Retrieve a CqQuery by name.
@return the CqQuery or null if not found

</member>
        <member name="M:gemfire.CqService.removeCq(stlp_std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,stlp_std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},stlp_std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes given CQ from the cqMap..

</member>
        <member name="M:gemfire.CqService.addCq(stlp_std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,stlp_std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},stlp_std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.CqQuery&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds the given CQ and cqQuery object into the CQ map.

</member>
        <member name="M:gemfire.CqService.newCq(stlp_std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,stlp_std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},stlp_std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,stlp_std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,stlp_std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},stlp_std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.CqAttributes&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Syste">
 Constructs a new named continuous query, represented by an instance of
 CqQuery. The CqQuery is not executed, however, until the execute method
 is invoked on the CqQuery. The name of the query will be used
 to identify this query in statistics archival.

 @param cqName the String name for this query
 @param queryString the OQL query
 @param cqAttributes the CqAttributes
 @param isDurable true if the CQ is durable
 @return the newly created CqQuery object
 @throws CqExistsException if a CQ by this name already exists on this
 client
 @throws IllegalArgumentException if queryString or cqAttr is null
 @throws IllegalStateException if this method is called from a cache
         server
 @throws QueryInvalidException if there is a syntax error in the query
 @throws CqException if failed to create cq, failure during creating
         managing cq metadata info.
 @throws CqInvalidException if the query doesnot meet the CQ constraints.
   E.g.: Query string should refer only one region, join not supported.
         The query must be a SELECT statement.
         DISTINCT queries are not supported.
         Projections are not supported.
         Only one iterator in the FROM clause is supported, and it must be a region path.
         Bind parameters in the query are not supported for the initial release.


</member>
        <member name="M:gemfire.CqService.checkAndAcquireLock">
Returns the state of the cqService.

</member>
        <member name="M:gemfire.CqService.#ctor(gemfire.ThinClientBaseDM*)">
Constructor.

</member>
        <member name="T:gemfire.CqService">
 @class CqService CqService.hpp

 Implements the CqService functionality.


</member>
        <member name="M:gemfire.CqServiceVsdStats.Dispose">
disable stat collection for this item. 
</member>
        <member name="M:gemfire.CqServiceVsdStats.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
hold statistics for a cq. 
</member>
        <member name="T:gemfire.TcrMessage">
@brief Distribute data between caches


@brief Distribute data between caches

</member>
        <member name="T:gemfire.TcrConnectionManager">
@brief transport data between caches

</member>
        <member name="M:gemfire.TcrConnection.receiveData(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.UInt32,System.Boolean)">
Read data from the connection till receiveTimeoutSec

</member>
        <member name="M:gemfire.TcrConnection.sendData(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32,System.Boolean)">
Send data to the connection till sendTimeoutSec

</member>
        <member name="M:gemfire.TcrConnection.readHandshakeByteArray(System.UInt32)">
Reads a byte array (using initial length) from socket and handles error conditions in case of Handshake.

</member>
        <member name="M:gemfire.TcrConnection.readHandshakeString(System.UInt32)">
Reads a string from socket and handles error conditions in case of Handshake.

</member>
        <member name="M:gemfire.TcrConnection.readHandshakeRawData(System.UInt32,System.UInt32)">
Reads raw bytes (without appending NULL terminator) from socket and handles error conditions in case of Handshake.

</member>
        <member name="M:gemfire.TcrConnection.readHandshakeData(System.UInt32,System.UInt32)">
Reads bytes from socket and handles error conditions in case of Handshake.

</member>
        <member name="M:gemfire.TcrConnection.createConnection(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.Int32)">
Create a normal or SSL connection 
</member>
        <member name="M:gemfire.TcrConnection.readHandShakeInt(System.UInt32)">
To read the from stream

</member>
        <member name="M:gemfire.TcrConnection.getOverrides(gemfire.SystemProperties*)">
Packs the override settings bits into bytes - currently a single byte for
conflation, remove-unresponsive-client and notify-by-subscription.

</member>
        <member name="M:gemfire.TcrConnection.readHandshakeInstantiatorMsg(System.UInt32)">
To read Intantiator message(which meant for java client), here we are ignoring it

</member>
        <member name="M:gemfire.TcrConnection.close">
Send close connection message to the server.

</member>
        <member name="M:gemfire.TcrConnection.readMessageChunked(gemfire.TcrMessage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Boolean)">
This method reads an interest list response  message from the socket connection and sets the reply message
parameter.
@param      reply response message
@param      receiveTimeoutSec read timeout in sec
@param      doHeaderTimeoutRetries retry when header receive times out
@exception  GemfireIOException  if an I/O error occurs (socket failure).
@exception  TimeoutException  if timeout happens during read

</member>
        <member name="M:gemfire.TcrConnection.readMessage(System.UInt32*,System.UInt32,System.Boolean,System.Boolean,System.Int32)">
This method reads a message from the socket connection and returns the byte array of response.
@param      recvLen output parameter for length of the received message
@param      receiveTimeoutSec read timeout in seconds
@param      doHeaderTimeoutRetries retry when header receive times out
@return     byte array of response. '0' ended.
@exception  GemfireIOException  if an I/O error occurs (socket failure).
@exception  TimeoutException  if timeout happens during read

</member>
        <member name="M:gemfire.TcrConnection.receive(System.UInt32*,System.UInt32)">
 This method is for receiving client notification. It will read 2 times as reading reply in sendRequest()

 @param      recvLen output parameter for length of the received message
 @param      receiveTimeoutSec read timeout in sec
 @return     byte arrary of response. '0' ended.
 @exception  GemfireIOException  if an I/O error occurs (socket failure).
 @exception  TimeoutException  if timeout happens at any of the 3 socket operation: 1 write, 2 read

</member>
        <member name="M:gemfire.TcrConnection.send(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32,System.Boolean)">
 send an asynchronized request to server. No response is expected.
 we need to use it to send CLOSE_CONNECTION msg

 @param      buffer the buffer to send
             len length of the data to send
             sendTimeoutSec write timeout in sec
 @return     no return. Because it either succeeds, or throw exception.
 @exception  GemfireIOException  if an I/O error occurs (socket failure).
 @exception  TimeoutException  if timeout happens at any of the 3 socket operation: 1 write, 2 read

</member>
        <member name="M:gemfire.TcrConnection.sendRequestForChunkedResponse(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,gemfire.TcrMessage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32)">
 send a synchronized request to server for REGISTER_INTEREST_LIST.

 @param      buffer the buffer to send
             len length of the data to send
             message vector, which will return chunked TcrMessage.
             sendTimeoutSec write timeout in sec
             receiveTimeoutSec read timeout in sec
 @exception  GemfireIOException  if an I/O error occurs (socket failure).
 @exception  TimeoutException  if timeout happens at any of the 3 socket operation: 1 write, 2 read

</member>
        <member name="M:gemfire.TcrConnection.sendRequest(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32*,System.UInt32,System.UInt32,System.Int32)">
 send a synchronized request to server.

 It will send the buffer, then wait to receive 17 bytes and save in msg_header.
 msg_header[0] is message type.
 msg_header[1],msg_header[2],msg_header[3],msg_header[4] will be a 4 bytes integer,
 let's say, msgLen, which specifies the length of next read. byteReads some number of
 call read again for msgLen bytes, and save the bytes into msg_body.
 concatenate the msg_header and msg_body into buffer, msg. The msg should be a '0' ended
 string. i.e. If the msg_header plus msg_body has 100 chars, msg should be a 101 char array
 to contain the '0' in the end. We need it to get length of the msg.
 Return the msg.

 @param      buffer the buffer to send
 @param      len length of the data to send
 @param      sendTimeoutSec write timeout in sec
 @param      recvLen output parameter for length of the received message
 @param      receiveTimeoutSec read timeout in sec
 @return     byte arrary of response. '0' ended.
 @exception  GemfireIOException  if an I/O error occurs (socket failure).
 @exception  TimeoutException  if timeout happens at any of the 3 socket operation: 1 write, 2 read

</member>
        <member name="M:gemfire.TcrConnection.#ctor(gemfire.TcrEndpoint*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Set&lt;System.UInt16&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean|System.Runtime.CompilerServices.IsVolatile!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,System.UInt32)">
Create one connection, endpoint is in format of hostname:portno
    * It will do handshake with j-server. There're 2 types of handshakes:
    * 1) handshake for request
    *    send following bytes:
    *    CLIENT_TO_SERVER
    *    REPLY_OK
    *    2 bytes for the length of idenfifier
    *    a string with "hostname:processId" as identifier
    *
    *    if send succeeds, handshake succeeds. Otherwise, construction
    *    fails.
    *
    * 2) handshake for client notification
    *    send following bytes:
    *    SERVER_TO_CLIENT
    *    1 (4 bytes, we can hard-code)
    *    12345 (4 bytes, we can hard-code)
    *
    *    So the total bytes to send are 9
    *    read one byte from server, it should be CLIENT_TO_SERVER
    *    Otherwise, construction fails.
    * @param     ports     List of local ports for connections to endpoint
    * @param     numPorts  Size of ports list

</member>
        <member name="M:ACE_5_6_0.ACE_OS.waitpid(System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Int32,System.Void*)">
Calls @c ::waitpid on UNIX/POSIX platforms Does not work on Vxworks 5.5.x.
On Win32, @a pid is ignored if the @a handle is not equal to 0.
Passing the process @a handle is prefer on Win32 because using
@a pid to wait on the project doesn't always work correctly
if the waited process has already terminated.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.wait(System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Int32,System.Void*)">
Calls @c ::WaitForSingleObject on Win32 and ACE::waitpid ()
otherwise.  Returns the passed in @a pid_t on success and -1 on
failure.
On Win32, @a pid is ignored if the @a handle is not equal to 0.
Passing the process @a handle is prefer on Win32 because using
@a pid to wait on the project doesn't always work correctly
if the waited process has already terminated.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.wait(System.Int32*)">
Calls OS @c ::wait function, so it's only portable to UNIX/POSIX
platforms.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strncasecmp(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Compares two arrays (case insensitive const wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strncasecmp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Compares two arrays (case insensitive const char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcasecmp(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Compares two strings (case insensitive const wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcasecmp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Compares two strings (case insensitive const char version).
</member>
        <member name="T:ACE_5_6_0.ACE_OS.macaddr_node_t">
Get the first adapter found on the machine.
@todo: this is really useless except for UUID, move there? dhinton

</member>
        <member name="M:gemfire.Connector.getPort">
Returns local port for this TCP connection

</member>
        <member name="M:gemfire.Connector.close">
Closes the connection.

</member>
        <member name="M:gemfire.Connector.init">
Initialises the connection.

</member>
        <member name="M:gemfire.Connector.send(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)">
 Writes <code>len</code> bytes from the specified byte array
 to the underlying output stream.

 @param      b     the data.
 @param      len   the number of bytes to write.
 @param      waitSeconds   the number of seconds to allow the write to complete.
 @return     the actual number of bytes written.
 @exception  GemfireIOException, TimeoutException, IllegalArgumentException.

</member>
        <member name="M:gemfire.TcrMessageHelper.readChunkPartHeader(gemfire.TcrMessage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte)">
Reads header of a chunk part. Returns true if header was successfully
read and false if it is a chunk exception part.
Throws a MessageException with relevant message if an unknown
message type is encountered in the header.

</member>
        <member name="M:gemfire.TcrMessageHelper.readExceptionPart(gemfire.TcrMessage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte)">
Tries to read an exception part and returns true if the exception
was successfully read.

</member>
        <member name="T:gemfire.TcrMessageHelper.ChunkObjectType">
result types returned by readChunkPartHeader

</member>
        <member name="T:gemfire.TcrMessageHelper">
Helper class to invoke some internal methods of TcrMessage. Add any
methods that response processor methods require to access here.

</member>
        <member name="M:gemfire.TcrMessage.forPrimary">
Whether the request is meant to be
sent to PR primary node for single hop.

</member>
        <member name="F:ACE_5_6_0.ACE_Addr.addr_size_">
Number of bytes in the address.
</member>
        <member name="F:ACE_5_6_0.ACE_Addr.addr_type_">
e.g., AF_UNIX, AF_INET, AF_SPIPE, etc.
</member>
        <member name="T:ACE_5_6_0.ACE_Addr.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.hash">
Returns a hash value.  This should be overwritten by a subclass
that can produce a better hash value.
</member>
        <member name="F:ACE_5_6_0.ACE_Addr.sap_any">
Wild-card address.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.base_set(System.Int32,System.Int32)">
Initializes instance variables.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.op_Inequality(ACE_5_6_0.ACE_Addr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check for address inequality.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.op_Equality(ACE_5_6_0.ACE_Addr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check for address equality.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.set_addr(System.Void*,System.Int32)">
Set a pointer to the address.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.get_addr">
Return a pointer to the address.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.set_type(System.Int32)">
Set the type of the address.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.get_type">
Get the type of the address.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.set_size(System.Int32)">
Sets the size of the address.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.get_size">
Return the size of the address.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Addr.#ctor(System.Int32,System.Int32)">
Initializes instance variables.
</member>
        <member name="T:ACE_5_6_0.ACE_Addr">
 @class ACE_Addr

 @brief Defines the base class for the "address family independent"
 address format.

</member>
        <member name="T:gemfire.TcrChunkedContext">
Holds the context for a chunk including the chunk bytes, length and the
{@link TcrChunkedResult} object.

</member>
        <member name="M:gemfire.TcrChunkedResult.waitFinalize">
Wait for the chunk processor thread to complete processing
of the chunks

</member>
        <member name="M:gemfire.TcrChunkedResult.finalize">
Send signal from chunk processor thread that processing of chunks
is complete

</member>
        <member name="M:gemfire.TcrChunkedResult.handleChunk(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Byte)">
handle a chunk of response message from server 
</member>
        <member name="M:gemfire.TcrChunkedResult.reset">
Any cleanup to be done before starting chunk processing, or after
failover to a new endpoint.

</member>
        <member name="T:gemfire.TcrChunkedResult">
Base class for holding chunked results, processing a chunk
and signalling end of chunks using semaphore.

</member>
        <member name="M:gemfire.Utils.convertBytesToString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)">
Convert the byte array to a string as "%d %d ...".
<code>maxLength</code> as zero implies no limit.

</member>
        <member name="M:gemfire.Utils.convertBytesToString(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)">
Convert the byte array to a string as "%d %d ...".
<code>maxLength</code> as zero implies no limit.

</member>
        <member name="M:gemfire.Utils.getCacheableKeyString(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The only operations that is well defined on the result is "asChar".

</member>
        <member name="M:gemfire.Utils.getEnv(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Get the value of an environment variable.
On windows the maximum length of value supported is 8191.

</member>
        <member name="F:gemfire.Utils.s_pNew">
 utilities


</member>
        <member name="T:gemfire.InterestResultPolicy">
@class InterestResultPolicy InterestResultPolicy.hpp
Policy class for interest result.

</member>
        <member name="M:gemfire.AtomicInc.value">
@brief  Explicitly return m_value. 
</member>
        <member name="M:gemfire.AtomicInc.op_SubtractionAssignment(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  Atomically decrement m_value by rhs. 
</member>
        <member name="M:gemfire.AtomicInc.op_Decrement(System.Int32)">
@brief  Atomically post-decrement m_value. 
</member>
        <member name="M:gemfire.AtomicInc.op_Decrement">
@brief  Atomically pre-decrement m_value. 
</member>
        <member name="M:gemfire.AtomicInc.op_AdditionAssignment(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  Atomically increment m_value by rhs. 
</member>
        <member name="M:gemfire.AtomicInc.op_Increment(System.Int32)">
@brief  Atomically post-increment m_value. 
</member>
        <member name="M:gemfire.AtomicInc.op_Increment">
@brief  Atomically pre-increment m_value. 
</member>
        <member name="M:gemfire.AtomicInc.resetValue(System.Int32!System.Runtime.CompilerServices.IsConst)">
@brief reset m_value to c. 
</member>
        <member name="M:gemfire.AtomicInc.#ctor(System.Int32!System.Runtime.CompilerServices.IsConst)">
@brief Initialize m_value to c. 
</member>
        <member name="T:gemfire.AtomicInc">
@brief Atomic type wrapper for thread safe arithmetic limited to addition.

</member>
        <member name="T:gemfire.EventSequence">
@class EventSequence
 *
 * EventSequence is the combination of SequenceNum from EventId, a timestamp and
 * a flag indicating whether or not it is ACKed

</member>
        <member name="T:gemfire.EventSource">
@class EventSource
 *
 * EventSource is the combination of MembershipId and ThreadId from the EventId

</member>
        <member name="M:gemfire.EventIdMap.expire(System.Boolean)">
Remove entries whos deadlines have passed and return the number of entries removed
   * @param onlyacked Either check only entries whos acked flag is true otherwise check all entries
   * @return The number of entries removed

</member>
        <member name="M:gemfire.EventIdMap.clearAckedFlags(stlp_std.vector&lt;stlp_std.pair&lt;gemfire.SharedPtr&lt;gemfire.EventSource&gt;,gemfire.SharedPtr&lt;gemfire.EventSequence&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Clear all acked flags in the list and return the number of entries cleared
   * @param entries List of entries whos flags are to be cleared
   * @return The number of entries whos flags were cleared

</member>
        <member name="M:gemfire.EventIdMap.getUnAcked">
Collect all map entries who acked flag is false and set their acked flags to true 
</member>
        <member name="M:gemfire.EventIdMap.remove(gemfire.SharedPtr&lt;gemfire.EventSource&gt;)">
Remove an item from the map
   *  @return true if the entry was found and removed else return false

</member>
        <member name="M:gemfire.EventIdMap.touch(gemfire.SharedPtr&lt;gemfire.EventSource&gt;)">
Update the deadline for the entry
   * @return true if the entry exists else false

</member>
        <member name="M:gemfire.EventIdMap.put(gemfire.SharedPtr&lt;gemfire.EventSource&gt;,gemfire.SharedPtr&lt;gemfire.EventSequence&gt;,System.Boolean)">
Put an item and return true if it is new or false if it existed and was updated
   * @param onlynew Only put if the sequence id does not exist or is higher
   * @return true if the entry was updated or inserted otherwise false

</member>
        <member name="M:gemfire.EventIdMap.make(gemfire.SharedPtr&lt;gemfire.EventId&gt;)">
Construct an EventIdMapEntry from an EventIdPtr 
</member>
        <member name="M:gemfire.EventIdMap.isDuplicate(gemfire.SharedPtr&lt;gemfire.EventSource&gt;,gemfire.SharedPtr&lt;gemfire.EventSequence&gt;)">
Find out if entry is duplicate
   * @return true if the entry exists else false

</member>
        <member name="M:gemfire.EventIdMap.init(System.Int32)">
Initialize with preset expiration time in seconds 
</member>
        <member name="T:gemfire.EventIdMap">
@class EventIdMap EventIdMap.hpp
 *
 * This is the class that encapsulates a HashMap and
 * provides the operations for duplicate checking and
 * expiry of idle event IDs from notifications.

</member>
        <member name="M:gemfire.EventId.#ctor(System.Boolean,System.UInt32,System.Boolean)">
Constructor, used for deserialization. 
</member>
        <member name="M:gemfire.EventId.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,System.Int64,System.Int64)">
Constructor, given the values. 
</member>
        <member name="M:gemfire.EventId.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
used to render as a string for logging. 
</member>
        <member name="M:gemfire.EventId.Dispose">
Destructor. 
</member>
        <member name="M:gemfire.EventId.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,System.Int64,System.Int64)">
Returns a pointer to a new eventid value. 
</member>
        <member name="M:gemfire.EventId.DSFID">
Internal Data Serializable Fixed ID size type - since GFE 5.7

</member>
        <member name="M:gemfire.EventId.typeId">
@brief return the typeId of the instance being serialized.
 This is used by deserialization to determine what instance
 type to create and derserialize into.

</member>
        <member name="M:gemfire.EventId.classId">
@brief return the classId of the instance being serialized.
 This is used by deserialization to determine what instance
 type to create and derserialize into.

</member>
        <member name="M:gemfire.EventId.createDeserializable">
@brief creation function for strings.

</member>
        <member name="M:gemfire.EventId.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief deserialize this object

</member>
        <member name="M:gemfire.EventId.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief serialize this object

</member>
        <member name="M:gemfire.EventId.getMemId">
@brief Accessor methods

</member>
        <member name="T:gemfire.EventId">
EventID "token" with a Distributed Member ID, Thread ID and per-thread Sequence ID

</member>
        <member name="T:gemfire.SpinLockGuard">
 Example:
  class Foo {
    private:
 
    SpinLock m_lock;
   
    public:

    Bool doSomething( )
    { SpinLockGuard __guard( m_lock );
      if ( ?? ) {
        return false;
      } else {
        if ( ?? ) throw ??
        return true;
      }
    }
  };
  
 The lock is automatically released no matter what return path is taken.

</member>
        <member name="T:gemfire.SpinLock">
For an object that needs to be protected by spinlock, declare a field of type
SpinLock. To protect the operation, use a SpinLockGuard on the stack to
automatically lock and then release when the stack is unwound.. 

</member>
        <member name="M:gemfire.HostAsm.atomicClearBits(System.UInt32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Atomically set masked bits to 0 in data.

</member>
        <member name="M:gemfire.HostAsm.atomicSet(System.UInt32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Atomically set value of data to the given value.

</member>
        <member name="M:gemfire.HostAsm.atomicSetBits(System.UInt32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Atomically set masked bits to 1 in data.

</member>
        <member name="M:gemfire.HostAsm.atomicOr(System.UInt32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Name - AtomicOr
 Atomically OR the mask value into the given address

</member>
        <member name="M:gemfire.HostAsm.atomicAnd(System.UInt32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
Name - AtomicAnd
  Atomically AND the mask value into the given address

</member>
        <member name="M:gemfire.HostAsm.atomicAddPostfix(System.Int32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Name - atomicAddPostfix
Purpose -
  Add 'increment' to  the counter pointed to be 'ctrPtr'.
  Returns the value of the counter before the addition

</member>
        <member name="M:gemfire.HostAsm.atomicAdd(System.Int32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Name - atomicAdd
Purpose -
  Add 'increment' to  the counter pointed to be 'ctrPtr'.
  Returns the value of the counter after the addition

</member>
        <member name="M:gemfire.HostAsm.spinLockRelease(System.UInt32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Name - SpinUnlock
Purpose -
     Release the specified spinlock.

</member>
        <member name="M:gemfire.HostAsm.spinLockTryAcquire(System.UInt32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Try to get exclusive access to the lock in the specified amount of time.
Return whether the lock is granted.

</member>
        <member name="M:gemfire.HostAsm.spinLockAcquire(System.UInt32|System.Runtime.CompilerServices.IsVolatile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get exclusive access to the lock, return when the lock is granted.

</member>
        <member name="T:gemfire.HostAsm">
hold static wrappers for spinlocks and atomic updates..

</member>
        <member name="D:gemfire.MapOfRegionGuard">
Guard type for locking a MapOfRegionWithLock while iterating or performing
 * other composite operations. ex.. MapOfRegionGuard guard( map-&gt;mutex() );

</member>
        <member name="D:gemfire.MapOfRegionWithLock">
Map type used to hold root regions in the Cache, and subRegions. 
</member>
        <member name="M:ACE_5_6_0.ACE_Command_Base.execute(System.Void*)">
Invokes the method encapsulated by the command, passing along the
passed argument (if any).  Users of classes derived from this
class must ensure that the resulting invocation can tolerate a
null void pointer being passed, or otherwise ensure that this
will never occur.

</member>
        <member name="M:ACE_5_6_0.ACE_Command_Base.Dispose">
Virtual destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Command_Base.#ctor">
Default constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Command_Base">
 @class ACE_Command_Base

 @brief Defines an abstract class that allows us to invoke commands
 without knowing anything about the implementation.

 This class declares an interface to execute a command
 independent of the effect of the command, or the objects used
 to implement it.

</member>
        <member name="M:gemfire.Condition.reset">
Must be called with the mutex held. 
</member>
        <member name="M:gemfire.Condition.signal">
The mutex for this condition should be locked/held by the thread calling
this signal method.

</member>
        <member name="M:gemfire.Condition.waitFor(System.UInt32)">
Convenience to derive absolute time.

</member>
        <member name="M:gemfire.Condition.waitUntil(ACE_5_6_0.ACE_Time_Value*)">
Release the given mutex, and wait for condition to be signaled, then
re-acquire the mutex.
Returns true only if the condition is signaled. 
Returns false only if the time is passed.

</member>
        <member name="M:gemfire.Condition.#ctor(ACE_5_6_0.ACE_Recursive_Thread_Mutex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a Condition protected by the mutex provided.

</member>
        <member name="T:gemfire.Condition">
Condition wrapper when you want an absolute signal or timeout condition.

</member>
        <member name="M:ACE_5_6_0.ACE_Null_Condition.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Condition.broadcast">
Returns 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Condition.signal">
Returns 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Condition.wait(ACE_5_6_0.ACE_Null_Mutex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)">
Returns -1 with @c errno == @c ETIME.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Condition.wait(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)">
Returns -1 with @c errno == @c ETIME.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Condition.remove">
Returns 0.
</member>
        <member name="T:ACE_5_6_0.ACE_Null_Condition">
 @class ACE_Null_Condition

 @brief Implement a do nothing ACE_Condition variable wrapper,
 i.e., all methods are no ops.  This class is necessary since
 some C++ compilers are *very* lame...

</member>
        <member name="F:ACE_5_6_0.ACE_Null_Mutex.lock_">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.tryacquire_read">
Return 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.acquire_read">
Return 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.tryacquire_write_upgrade">
Return 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.tryacquire_write">
Return 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.acquire_write">
Return 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.release">
Return 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.tryacquire">
Return 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*)">
Return -1 with @c errno == @c ETIME.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return -1 with @c errno == @c ETIME.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.acquire">
Return 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Null_Mutex.remove">
Return 0.
</member>
        <member name="T:ACE_5_6_0.ACE_Null_Mutex">
 @class ACE_Null_Mutex

 @brief Implement a do nothing ACE_Mutex, i.e., all the methods are
 no ops.

</member>
        <member name="F:M_FLAGS_NOT_SET">
Indicates that the flags have not been set
</member>
        <member name="T:ACE_5_6_0.ACE_Module_Base">
 @class ACE_Module_Base

 @brief Workaround HP/C++ compiler bug with enums in templates.

 Certain C++ compilers, e.g., the HP/UX 10.x and 9.x compilers,
 seem to fail if enums are defined inside a template, hence we
 have to move them into a base class.

</member>
        <member name="F:ACE_DIR.started_reading_">
A flag to remember if we started reading already.
</member>
        <member name="F:ACE_DIR.fdata_">
The struct for intermediate results.
</member>
        <member name="F:ACE_DIR.dirent_">
The struct for the results
</member>
        <member name="F:ACE_DIR.current_handle_">
Remember the handle between calls.
</member>
        <member name="F:ACE_DIR.directory_name_">
The name of the directory we are looking into
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Queue_NT.completion_port_">
Underlying NT IoCompletionPort.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Queue_NT.lock_">
Synchronizer.  This should really be an ACE_Recursive_Thread_Mutex
but since this class is only supported on NT, it's okay to use
ACE_Thread_Mutex here.

</member>
        <member name="F:ACE_5_6_0.ACE_Message_Queue_NT.cur_count_">
Current number of messages in the queue.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Queue_NT.cur_length_">
Current length of messages in queue.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Queue_NT.cur_bytes_">
Current number of bytes in queue.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Queue_NT.cur_thrs_">
Current number of threads waiting to dequeue messages.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Queue_NT.max_cthrs_">
Maximum threads that can be released (and run) concurrently.
</member>
        <member name="T:ACE_5_6_0.ACE_Message_Queue_NT.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.completion_port">
Get the handle to the underlying completion port.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.pulse">
 Pulse the queue to wake up any waiting threads.  Changes the
 queue state to PULSED; future enqueue/dequeue operations proceed
 as in ACTIVATED state.

 @retval  The queue's state before this call.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.activate">
Reactivate the queue so that threads can enqueue and dequeue
messages again.  Returns the state of the queue before the call.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.deactivate">
 Deactivate the queue and wake up all threads waiting on the queue
 so they can continue.  No messages are removed from the queue,
 however.  Any other operations called until the queue is
 activated again will immediately return -1 with @c errno
 ESHUTDOWN.

 @retval  The queue's state before this call.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.max_threads">
Get the max concurrent thread number.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.message_length(System.UInt32)">
New value of the number of total length on the queue, i.e., sum
of the message block lengths.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.message_bytes(System.UInt32)">
New value of the number of total bytes on the queue, i.e., sum of
the message block sizes.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.message_count">
Number of total messages on the queue.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.message_length">
Number of total length on the queue, i.e., sum of the message
block lengths.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.message_bytes">
Number of total bytes on the queue, i.e., sum of the message
block sizes.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.is_empty">
True if queue is empty, else false.  Notice the return value is
only transient.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.is_full">
Always return false.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.Dispose">
Close down the message queue and release all resources.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.close">
Close down the underlying I/O completion port.  You need to
re-open the MQ after this function is executed.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_NT.open(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Initialize the Message Queue by creating a new NT I/O completion
port.  The first arguemnt specifies the number of threads
released by the MQ that are allowed to run concurrently.  Return
0 when succeeds, -1 otherwise.

</member>
        <member name="F:ACE_5_6_0.ACE_Notification_Strategy.mask_">
The reactor mask.
</member>
        <member name="F:ACE_5_6_0.ACE_Notification_Strategy.eh_">
The event handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Notification_Strategy.mask(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the reactor mask.
</member>
        <member name="M:ACE_5_6_0.ACE_Notification_Strategy.mask">
Get the reactor mask.
</member>
        <member name="M:ACE_5_6_0.ACE_Notification_Strategy.event_handler(ACE_5_6_0.ACE_Event_Handler*)">
Set the event handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Notification_Strategy.event_handler">
Get the event handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Notification_Strategy.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Notification_Strategy.#ctor(ACE_5_6_0.ACE_Event_Handler*,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Notification_Strategy">
 @class ACE_Notification_Strategy

 @brief Abstract class used for notifying an interested party

 A vehicle for extending the behavior of ACE_Message_Queue wrt
 notification *without subclassing*.  Thus, it's an example of
 the Bridge/Strategy patterns.

</member>
        <member name="T:ACE_5_6_0.ACE_Message_Queue_Base.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.deactivated">
Returns 1 if the state of the queue is DEACTIVATED,
and 0 if the queue's state is ACTIVATED or PULSED.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.state">
Returns the current state of the queue.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.pulse">
 Pulse the queue to wake up any waiting threads.  Changes the
 queue state to PULSED; future enqueue/dequeue operations proceed
 as in ACTIVATED state.

 @retval  The queue's state before this call.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.activate">
 Reactivate the queue so that threads can enqueue and dequeue
 messages again.

 @retval  The queue's state before this call.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.deactivate">
 Deactivate the queue and wake up all threads waiting on the queue
 so they can continue.  No messages are removed from the queue,
 however.  Any other operations called until the queue is
 activated again will immediately return -1 with @c errno
 ESHUTDOWN.

 @retval  The queue's state before this call.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.message_length(System.UInt32)">
New value of the number of total length on the queue, i.e.,
sum of the message block lengths.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.message_bytes(System.UInt32)">
New value of the number of total bytes on the queue, i.e.,
sum of the message block sizes.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.message_count">
Number of total messages on the queue.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.message_length">
Number of total length on the queue, i.e., sum of the message
block lengths.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.message_bytes">
Number of total bytes on the queue, i.e., sum of the message
block sizes.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.is_empty">
True if queue is empty, else false.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.is_full">
True if queue is full, else false.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.Dispose">
Close down the message queue and release all resources.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Queue_Base.close">
Close down the message queue and release all resources.
</member>
        <member name="F:PULSED">
Message queue was pulsed; enqueue and dequeue may proceed normally.
</member>
        <member name="F:DEACTIVATED">
Queue is deactivated; no enqueue or dequeue operations allowed.
</member>
        <member name="F:WAS_INACTIVE">
@deprecated Use DEACTIVATED instead.
</member>
        <member name="F:ACTIVATED">
Message queue is active and processing normally
</member>
        <member name="F:WAS_ACTIVE">
@deprecated Use ACTIVATED instead.
</member>
        <member name="F:DEFAULT_LWM">
Default low watermark (same as high water mark).
</member>
        <member name="F:DEFAULT_HWM">
Default high watermark (16 K).
</member>
        <member name="T:ACE_5_6_0.ACE_Message_Queue_Base">
 @class ACE_Message_Queue_Base

 @brief Base class for ACE_Message_Queue, which is the central
 queueing facility for messages in the ACE framework.

 For all the ACE_Time_Value pointer parameters the caller will
 block until action is possible if @a timeout == 0.  Otherwise, it
 will wait until the absolute time specified in *@a timeout
 elapses.

 A queue is always in one of three states:
 . ACTIVATED
 . DEACTIVATED
 . PULSED

</member>
        <member name="F:ACE_5_6_0.ACE_IO_Cntl_Msg.rval_">
Return value
</member>
        <member name="F:ACE_5_6_0.ACE_IO_Cntl_Msg.error_">
Error.
</member>
        <member name="F:ACE_5_6_0.ACE_IO_Cntl_Msg.count_">
Count.
</member>
        <member name="F:ACE_5_6_0.ACE_IO_Cntl_Msg.cmd_">
Command.
</member>
        <member name="T:ACE_5_6_0.ACE_IO_Cntl_Msg.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.rval(System.Int32)">
Set return value.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.rval">
Get return value.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.error(System.Int32)">
Set error.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.error">
Get error.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.count(System.UInt32)">
Set count.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.count">
Get count.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.cmd(System.UInt16)">
Set command.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.cmd">
Get command.
</member>
        <member name="M:ACE_5_6_0.ACE_IO_Cntl_Msg.#ctor(System.UInt16)">
Initialize the control message.
</member>
        <member name="F:MOD_UNLINK">
Unlink modules
</member>
        <member name="F:MOD_LINK">
Link modules
</member>
        <member name="F:GET_HWM">
Get the high water mark.
</member>
        <member name="F:SET_HWM">
Set the high water mark.
</member>
        <member name="F:GET_LWM">
Get the low water mark.
</member>
        <member name="F:SET_LWM">
Set the low water mark.
</member>
        <member name="T:ACE_5_6_0.ACE_IO_Cntl_Msg">
 @class ACE_IO_Cntl_Msg

 @brief Data format for IOCTL messages

</member>
        <member name="M:ACE_5_6_0.ACE_Laxity_Message_Strategy.dump">
Dump the state of the strategy.
</member>
        <member name="M:ACE_5_6_0.ACE_Laxity_Message_Strategy.convert_priority(ACE_5_6_0.ACE_Time_Value*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dynamic priority conversion function based on laxity.
</member>
        <member name="M:ACE_5_6_0.ACE_Laxity_Message_Strategy.Dispose">
virtual dtor.
</member>
        <member name="M:ACE_5_6_0.ACE_Laxity_Message_Strategy.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Ctor, with all arguments defaulted.
</member>
        <member name="T:ACE_5_6_0.ACE_Laxity_Message_Strategy">
 @class ACE_Laxity_Message_Strategy

 @brief Laxity based message priority strategy.

 Assigns dynamic message priority according to laxity (time to
 deadline minus worst case execution time).  The message priority is
 divided into high and low order bit fields.  The high order
 bit field is used for dynamic message priority, which is
 updated whenever the convert_priority() method is called.  The
 low order bit field is used for static message priority and is left
 unchanged.  The partitioning of the priority value into high and low
 order bit fields is done according to the arguments passed to the
 strategy object's constructor.

</member>
        <member name="M:ACE_5_6_0.ACE_Deadline_Message_Strategy.dump">
Dump the state of the strategy.
</member>
        <member name="M:ACE_5_6_0.ACE_Deadline_Message_Strategy.convert_priority(ACE_5_6_0.ACE_Time_Value*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Dynamic priority conversion function based on time to deadline.
</member>
        <member name="M:ACE_5_6_0.ACE_Deadline_Message_Strategy.Dispose">
Virtual dtor.
</member>
        <member name="M:ACE_5_6_0.ACE_Deadline_Message_Strategy.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Ctor, with all arguments defaulted.
</member>
        <member name="T:ACE_5_6_0.ACE_Deadline_Message_Strategy">
 @class ACE_Deadline_Message_Strategy

 @brief Deadline based message priority strategy.

 Assigns dynamic message priority according to time to deadline.  The
 message priority is divided into high and low order bit fields.  The
 high order bit field is used for dynamic message priority, which is
 updated whenever the convert_priority() method is called.  The
 low order bit field is used for static message priority and is left
 unchanged.  The partitioning of the priority value into high and low
 order bit fields is done according to the arguments passed to the
 strategy object's constructor.

</member>
        <member name="F:ACE_5_6_0.ACE_Dynamic_Message_Strategy.pending_shift_">
Time value by which to shift pending priority.
</member>
        <member name="F:ACE_5_6_0.ACE_Dynamic_Message_Strategy.min_pending_">
Minimum pending time value that can be represented.
</member>
        <member name="F:ACE_5_6_0.ACE_Dynamic_Message_Strategy.max_late_">
Maximum late time value that can be represented.
</member>
        <member name="F:ACE_5_6_0.ACE_Dynamic_Message_Strategy.dynamic_priority_offset_">
Offset to boundary between signed range and unsigned range.
</member>
        <member name="F:ACE_5_6_0.ACE_Dynamic_Message_Strategy.dynamic_priority_max_">
Maximum supported priority value.
</member>
        <member name="F:ACE_5_6_0.ACE_Dynamic_Message_Strategy.static_bit_field_shift_">
This is a left shift value to make room for static bit field:
this value should be the logarithm base 2 of
(static_bit_field_mask_ + 1).

</member>
        <member name="F:ACE_5_6_0.ACE_Dynamic_Message_Strategy.static_bit_field_mask_">
This is a bit mask with all ones in the static bit field.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.convert_priority(ACE_5_6_0.ACE_Time_Value*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Hook method for dynamic priority conversion.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.dump">
Dump the state of the strategy.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.dynamic_priority_offset(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set offset to boundary between signed range and unsigned range.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.dynamic_priority_offset">
Get offset to boundary between signed range and unsigned range.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.dynamic_priority_max(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set maximum supported priority value.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.dynamic_priority_max">
Get maximum supported priority value.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.static_bit_field_shift(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set left shift value to make room for static bit field.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.static_bit_field_shift">
Get left shift value to make room for static bit field.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.static_bit_field_mask(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set static bit field mask.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.static_bit_field_mask">
Get static bit field mask.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.priority_status(ACE_5_6_0.ACE_Message_Block*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Updates the message's priority and returns its priority status.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.Dispose">
Virtual destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Dynamic_Message_Strategy.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Constructor.
</member>
        <member name="F:ANY_STATUS">
Mask to match any priority status
</member>
        <member name="F:BEYOND_LATE">
Message is so late its priority is undefined
</member>
        <member name="F:LATE">
Message cannot make its deadline
</member>
        <member name="F:PENDING">
Message can still make its deadline
</member>
        <member name="T:ACE_5_6_0.ACE_Dynamic_Message_Strategy">
 @class ACE_Dynamic_Message_Strategy

 @brief An abstract base class which provides dynamic priority
 evaluation methods for use by the ACE_Dynamic_Message_Queue
 class or any other class which needs to manage the priorities
 of a collection of ACE_Message_Blocks dynamically.

 Methods for deadline and laxity based priority evaluation are
 provided.  These methods assume a specific partitioning of
 the message priority number into a higher order dynamic bit
 field and a lower order static priority bit field.  The
 default partitioning assumes an unsigned dynamic message
 priority field of 22 bits and an unsigned static message
 priority field of 10 bits.  This corresponds to the initial
 values of the static class members.  To provide a different
 partitioning, assign a different set of values to the static
 class memebers before using the static member functions.

</member>
        <member name="F:ACE_5_6_0.ACE_Data_Block.data_block_allocator_">
The allocator use to destroy ourselves.
</member>
        <member name="F:ACE_5_6_0.ACE_Data_Block.locking_strategy_">
Pointer to the locking strategy defined for this
ACE_Data_Block.  This is used to protect regions of code that
access shared ACE_Data_Block state.  Note that this lock is
shared by all owners of the ACE_Data_Block's data.

</member>
        <member name="F:ACE_5_6_0.ACE_Data_Block.allocator_strategy_">
Pointer to the allocator defined for this ACE_Data_Block.  Note
that this pointer is shared by all owners of this
ACE_Data_Block.

</member>
        <member name="F:ACE_5_6_0.ACE_Data_Block.base_">
Pointer To beginning of message payload.
</member>
        <member name="F:ACE_5_6_0.ACE_Data_Block.flags_">
Misc flags (e.g., DONT_DELETE and USER_FLAGS).
</member>
        <member name="F:ACE_5_6_0.ACE_Data_Block.max_size_">
Total size of buffer.
</member>
        <member name="F:ACE_5_6_0.ACE_Data_Block.cur_size_">
Current size of message block.
</member>
        <member name="F:ACE_5_6_0.ACE_Data_Block.type_">
Type of message.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.reference_count_i">
Internal get the current reference count.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.release_i">
Internal release implementation
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.data_block_allocator">
Get the allocator used to create this object
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.reference_count">
Get the current reference count.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.locking_strategy(ACE_5_6_0.ACE_Lock*)">
Set a new locking strategy and return the hold one.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.locking_strategy">
Get the locking strategy.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.allocator_strategy">
Obtain the allocator strategy.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.flags">
Get the current message flags.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.duplicate">
Return a "shallow" copy that increments our reference count by 1.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.clone_nocopy(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32)">
As clone above, but it does not copy the contents of the buffer,
i.e., create a new Data_Block of the same dynamic type, with the
same allocator, locking_strategy, and with the same amount of
storage available (if @a max_size is zero) but the buffer is unitialized.
If @a max_size is specified other than zero, it will be used when
creating the new data block.

</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.clone(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Return an exact "deep copy" of the message, i.e., create fresh
new copies of all the Data_Blocks and continuations.
Notice that Data_Blocks can act as "Prototypes", i.e. derived
classes can override this method and create instances of
themselves.

</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.capacity">
Get the total amount of allocated space.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.size(System.UInt32)">
Set the total amount of space in the message.  Returns 0 if
successful, else -1.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.size">
Get the total amount of allotted space in the message.  The amount of
allotted space may be less than allocated space.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.end">
Return a pointer to 1 past the end of the allocated data in a message.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.base(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set message data pointer (doesn't reallocate).
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.base">
Get message data pointer
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.msg_type(System.Int32)">
Set type of the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.msg_type">
Get type of the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.Dispose">
Delete all the resources held in the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.#ctor(System.UInt32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Lock*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Allocator*)">
Initialize.
</member>
        <member name="M:ACE_5_6_0.ACE_Data_Block.#ctor">
Default "do-nothing" constructor.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.message_block_allocator_">
The allocator used to destroy ourselves when release is called
and create new message blocks on duplicate.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.data_block_">
Pointer to the reference counted data structure that contains the
actual memory buffer.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.flags_">
Misc flags (e.g., DONT_DELETE and USER_FLAGS).
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.prev_">
Pointer to previous message in the list.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.next_">
Pointer to next message in the list.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.cont_">
Pointer to next message block in the chain.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.priority_">
Priority of message.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.wr_ptr_">
Pointer to beginning of next write.
</member>
        <member name="F:ACE_5_6_0.ACE_Message_Block.rd_ptr_">
Pointer to beginning of next read.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.init_i(System.UInt32,System.Int32,ACE_5_6_0.ACE_Message_Block*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Lock*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Data_Block*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Allocator*)">
Perform the actual initialization.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.release_i(ACE_5_6_0.ACE_Lock*)">
Internal release implementation
Returns 1 if the data block has to be destroyed.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.#ctor(System.UInt32,System.Int32,ACE_5_6_0.ACE_Message_Block*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Lock*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Data_Block*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Allocator*)">
Perform the actual initialization.
</member>
        <member name="T:ACE_5_6_0.ACE_Message_Block.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.reference_count">
Get the current reference count.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.locking_strategy(ACE_5_6_0.ACE_Lock*)">
Set a new locking strategy and return the hold one.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.locking_strategy">
Get the locking strategy.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.prev(ACE_5_6_0.ACE_Message_Block*)">
Set link to prev message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.prev">
Get link to prev message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.next(ACE_5_6_0.ACE_Message_Block*)">
Set link to next message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.next">
Get link to next message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.cont(ACE_5_6_0.ACE_Message_Block*)">
Set the continuation field.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.cont">
Get the continuation field.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.data_block">
Get a pointer to the data block. Note that the ACE_Message_Block
still references the block; this call does not change the reference
count.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.length(System.UInt32)">
Set the length of the message
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.length">
@name Message length and size operations
   *
   * Message length is (wr_ptr - rd_ptr).
   *
   * Message size is capacity of the message, including data outside
   * the [rd_ptr,wr_ptr] range.

Get the length of the message
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.wr_ptr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
Set the write pointer to @a ptr.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.wr_ptr">
Get the write pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.rd_ptr(System.UInt32)">
Set the read pointer ahead @a n bytes.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.rd_ptr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
Set the read pointer to @a ptr.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.rd_ptr">
Get the read pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.mark">
Return a pointer to 1 past the end of the allotted data in a message.
Allotted data may be less than allocated data  if a value smaller than
capacity() to is passed to size().

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.end">
Return a pointer to 1 past the end of the allocated data in a message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.base(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set message data (doesn't reallocate).
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.base">
Get message data.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.reset_allocators(ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Allocator*)">
Reset all the allocators in the message block.
@@todo: Not sure whether we would need finer control while
trying to reset allocators ie. a method for every allocator.
This method resets the allocators in all the message blocks in
the chain.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.access_allocators(ACE_5_6_0.ACE_Allocator**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Allocator**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Allocator**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Access all the allocators in the message block.
@@todo: Not sure whether we would need finer control while
trying to access allocators ie. a method for every allocator.
 This method returns the allocators only from the first message
 block in the chain.

 @param allocator_strategy Strategy used to allocate the
                           underlying buffer

 @param data_block_allocator Strategy used to allocate the
                             underlying data block

 @param message_block_allocator Strategy used to allocate the
                                message block

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.reset">
Resets the Message Block data to contain nothing, i.e., sets the
read and write pointers to align with the base.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.copy(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Copies a 0-terminated character string into this ACE_Message_Block.
 The string is copied into the block starting at the current write
 pointer. The 0-terminator is included in the copied data.

 @param buf  Pointer to the character string to copy from.

 @retval 0  on success; the write pointer is advanced by the string's
            length, including the 0 terminator.
 @retval -1 if the amount of free space following the write pointer
            in the block is less than required to hold the entire string.
            Free space can be checked by calling space().

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.copy(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Copies data into this ACE_Message_Block. Data is copied into the
 block starting at the current write pointer.

 @param buf  Pointer to the buffer to copy from.
 @param n    The number of bytes to copy.

 @retval 0  on success; the write pointer is advanced by @arg n.
 @retval -1 if the amount of free space following the write pointer
            in the block is less than @arg n. Free space can be checked
            by calling space().

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.duplicate">
Return a "shallow" copy that increments our reference count by 1.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.clone(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Return an exact "deep copy" of the message, i.e., create fresh
new copies of all the Data_Blocks and continuations.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_deadline_time(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set absolute time of deadline associated with the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_deadline_time">
Get absolute time of deadline associated with the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_execution_time(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set execution time associated with the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_execution_time">
Get execution time associated with the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_priority(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set priority of the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_priority">
Get priority of the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.self_flags">
Get the current message flags.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.clr_self_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Clear the message flag bits specified in @a less_flags and return
the new value.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.flags">
Get the current message flags.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.clr_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Clear the message flag bits specified in @a less_flags and return
the new value.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.set_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Bitwise-or the @a more_flags into the existing message flags and
return the new value.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_class">
Find out what class of message this is (there are two classes,
@c normal messages and @c high-priority messages).
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.is_data_msg">
Find out what type of message this is.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_type(System.Int32)">
Set type of the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.msg_type">
Get type of the message.
</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.#ctor(ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
A copy constructor. This constructor is a bit different. If the
incoming Message Block has a data block from the stack this
constructor does a deep copy ie. allocates a new data block on
the heap and does a copy of the data from the incoming message
block. As a final note, the alignment information is used to
align the data block if it is created afresh. If the incoming
@a mb has a data block has a data block allocated from the heap,
then this constructor just duplicates (ie. a shallow copy) the
data block of the incoming @a mb.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.#ctor(System.UInt32,System.Int32,ACE_5_6_0.ACE_Message_Block*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Lock*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Allocator*)">
Create an initialized message of type @a type containing @a size
bytes.  The @a cont argument initializes the continuation field in
the ACE_Message_Block.  If @a data == 0 then this block allocates and
owns the block's memory, using @a allocator to get the data if it's
non-0.  If @a data != 0 then this block refers to that memory until
this this block ceases to exist; this object will not free @a data on
destruction.  If @a locking_strategy is non-0 then this is used
to protect regions of code that access shared state (e.g.,
reference counting) from race conditions.  Note that the @c size
of the ACE_Message_Block will be @a size, but the @c length will be 0
until the write pointer is set. The @a data_block_allocator is used to
allocate the data blocks while the @a allocator_strategy is used
to allocate the buffers contained by those. The
@a message_block_allocator is used to allocate new ACE_Message_Block
objects when the duplicate() method is called. If a
@a message_block_allocator is given, this ACE_Message_Block and
future ACE_Message_Block objects created by duplicate() will be
freed using this allocator when they are released.
@note If you use this allocator, the ACE_Message_Block you created
should have been created using this allocator because it will be
released to the same allocator.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Create an ACE_Message_Block that refers to @a data without
copying it. The @a data memory will not be freed when this block is
destroyed; memory management of @a data is left to the caller.
Note that the @c size of the new ACE_Message_Block will be @a size, but
the @c length will be 0 until the write pointer is changed.

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.#ctor(ACE_5_6_0.ACE_Data_Block*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Allocator*)">
Create an ACE_Message_Block that owns the specified ACE_Data_Block
without copying it. If the @a flags is set to @c DONT_DELETE we
don't delete the ACE_Data_Block. It is left to the client's
responsibility to take care of the memory allocated for the
data_block

</member>
        <member name="M:ACE_5_6_0.ACE_Message_Block.#ctor(ACE_5_6_0.ACE_Allocator*)">
Create an empty message.
</member>
        <member name="F:USER_FLAGS">
user defined flags start here
</member>
        <member name="F:DONT_DELETE">
Don't delete the data on exit since we don't own it.
</member>
        <member name="F:MB_USER">
User-defined message mask
</member>
        <member name="F:MB_PRIORITY">
High priority control message mask
</member>
        <member name="F:MB_NORMAL">
Normal priority message mask
</member>
        <member name="F:MB_PCEVENT">
Post an event to an event queue
</member>
        <member name="F:MB_ERROR">
Fatal error used to set u.u_error
</member>
        <member name="F:MB_HANGUP">
Line disconnect
</member>
        <member name="F:MB_START">
Restart transmission after stop
</member>
        <member name="F:MB_STOP">
Stop transmission immediately
</member>
        <member name="F:MB_FLUSH">
Flush your queues
</member>
        <member name="F:MB_READ">
Generate read notification
</member>
        <member name="F:MB_PCSIG">
Generate process signal
</member>
        <member name="F:MB_PCPROTO">
Priority proto message
</member>
        <member name="F:MB_IOCNAK">
Negative ioctl acknowledge
</member>
        <member name="F:MB_IOCACK">
Acknowledge ioctl (high priority; go to head of queue)
</member>
        <member name="F:MB_SETOPTS">
Set various stream head options
</member>
        <member name="F:MB_IOCTL">
ioctl; set/get params
</member>
        <member name="F:MB_SIG">
Generate process signal
</member>
        <member name="F:MB_EVENT">
Post an event to an event queue
</member>
        <member name="F:MB_PASSFP">
Pass file pointer
</member>
        <member name="F:MB_BREAK">
Line break (regular and priority)
</member>
        <member name="F:MB_PROTO">
Undifferentiated protocol control
</member>
        <member name="F:MB_DATA">
Undifferentiated data message
</member>
        <member name="T:ACE_5_6_0.ACE_Message_Block">
 @class ACE_Message_Block

 @brief Stores messages for use throughout ACE (particularly
 in an ACE_Message_Queue).

 An ACE_Message_Block is modeled after the message data
 structures used in System V STREAMS.  Its purpose is to
 enable efficient manipulation of arbitrarily large messages
 without incurring much memory copying overhead.  Here are the
 main characteristics of an ACE_Message_Block:
 - Contains a pointer to a reference-counted
   ACE_Data_Block, which in turn points to the actual data
   buffer.  This allows very flexible and efficient sharing of
   data by multiple ACE_Message_Block objects.
 - One or more ACE_Message_Blocks can be linked to form a
    ``fragment chain.''
 - ACE_Message_Blocks can be linked together in a doubly linked fashion
   to form a queue of messages (this is how ACE_Message_Queue works).

 @see C++NPv1, section 4.2; APG, section 12.3.2.

</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Manager.thr_exit_">
Global ACE_TSS (ACE_Thread_Exit) object ptr.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Manager.thr_mgr_">
Pointer to a process-wide ACE_Thread_Manager.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Manager.zero_cond_">
Keep track of when there are no more threads.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Manager.automatic_wait_">
Set if we want the Thread_Manager to wait on all threads before
being closed, reset otherwise.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Manager.grp_id_">
Keeps track of the next group id to assign.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Manager.thr_to_be_removed_">
Collect pointers to thread descriptors of threads to be removed later.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Manager.terminated_thr_list_">
Collect terminated but not yet joined thread entries.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Manager.thr_list_">
Keeping a list of thread descriptors within the thread manager.
Double-linked list enables us to cache the entries in TSS
and adding/removing thread descriptor entries without
affecting other thread's descriptor entries.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.set_thr_exit(ACE_5_6_0.ACE_TSS&lt;ACE_5_6_0.ACE_Thread_Exit&gt;*)">
Setting the static ACE_TSS_TYPE (ACE_Thread_Exit) *thr_exit_ pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.remove_thr_all">
Remove all threads from the table.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.remove_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)">
Remove thread from the table.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.append_thr(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32,System.Int32,ACE_5_6_0.ACE_Task_Base*,System.Int32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Thread_Descriptor*)">
Append a thread in the table (adds at the end, growing the table
if necessary).
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.insert_thr(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsLong)">
Insert a thread in the table (checks for duplicates).
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.run_thread_exit_hooks(System.Int32)">
Run the registered hooks when the thread exits.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.spawn_i(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void**,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*,System.UInt32,ACE_5_6_0.ACE_Task_Base*)">
Create a new thread (must be called with locks held).
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.hthread_descriptor(System.Void*)">
Return a pointer to the thread's Thread_Descriptor,
0 if fail.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.thread_descriptor(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Return a pointer to the thread's Thread_Descriptor,
0 if fail.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.thread_desc_self">
Get a pointer to the calling thread's own thread_descriptor.
This must be called from a spawn thread.  This function will
fetch the info from TSS.

</member>
        <member name="T:ACE_5_6_0.ACE_Thread_Manager.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.wait_on_exit(System.Int32)">
Access function to determine whether the Thread_Manager will
wait for its thread to exit or not when being closing down.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.at_exit(ACE_5_6_0.ACE_At_Thread_Exit*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Register an At_Thread_Exit hook and the ownership is retained for the
caller. Normally used when the at_exit hook is created in stack.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.at_exit(ACE_5_6_0.ACE_At_Thread_Exit*)">
Register an At_Thread_Exit hook and the ownership is acquire by
Thread_Descriptor, this is the usual case when the AT is dynamically
allocated.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.thr_state(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the state of the thread. Returns false if the thread is not
managed by this thread manager.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.get_grp(ACE_5_6_0.ACE_Task_Base*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get group ids for a particular task.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.set_grp(ACE_5_6_0.ACE_Task_Base*,System.Int32)">
Set group ids for a particular task.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.thread_all_list(System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32)">
Returns in @a thread_list a list of up to @a n thread ids.  The
caller must allocate the memory for @a thread_list.  In case of an
error, -1 is returned. If no requested values are found, 0 is
returned, otherwise correct number of retrieved values are
returned.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.task_all_list(ACE_5_6_0.ACE_Task_Base**,System.UInt32)">
 Returns a list of ACE_Task_Base pointers corresponding to the tasks
 that have active threads managed by this instance.

 @param task_list is a pointer to an array to receive the list of pointers.
                  The caller is responsible for supplying an array with at
                  least @arg n entries.

 @param n         The maximum number of ACE_Task_Base pointers to write
                  in @arg task_list.

 @retval  If successful, the number of pointers returned, which will be
          no greater than @arg n. Returns -1 on error.

 @note    This method has no way to indicate if there are more than
          @arg n ACE_Task_Base pointers available. Therefore, it may be
          wise to guess a larger value of @arg n than one thinks in cases
          where the exact number of tasks is not known.

 @sa      count_threads()

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.thread_list(ACE_5_6_0.ACE_Task_Base*,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32)">
Returns in @a thread_list a list of up to @a n thread ids in an
ACE_Task_Base.  The caller must allocate the memory for
@a thread_list.  In case of an error, -1 is returned. If no
requested values are found, 0 is returned, otherwise correct
number of retrieved values are returned.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.task_list(System.Int32,ACE_5_6_0.ACE_Task_Base**,System.UInt32)">
 Returns a list of ACE_Task_Base pointers corresponding to the tasks
 that have active threads in a specified thread group.

 @param grp_id    The thread group ID to obtain task pointers for.

 @param task_list is a pointer to an array to receive the list of pointers.
                  The caller is responsible for supplying an array with at
                  least @arg n entries.

 @param n         The maximum number of ACE_Task_Base pointers to write
                  in @arg task_list.

 @retval  If successful, the number of pointers returned, which will be
          no greater than @arg n. Returns -1 on error.

 @note    This method has no way to indicate if there are more than
          @arg n ACE_Task_Base pointers available. Therefore, it may be
          wise to guess a larger value of @arg n than one thinks in cases
          where the exact number of tasks is not known.

 @sa      num_tasks_in_group(), task_all_list()

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.num_threads_in_task(ACE_5_6_0.ACE_Task_Base*)">
Returns the number of threads in an ACE_Task_Base.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.num_tasks_in_group(System.Int32)">
Returns the number of ACE_Task_Base in a group.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.hthread_within(System.Void*)">
Check if the thread is managed by the thread manager.  Return true if
the thread is found, false otherwise.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.kill_task(ACE_5_6_0.ACE_Task_Base*,System.Int32)">
Send a signal @a signum to all threads in an ACE_Task.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.resume_task(ACE_5_6_0.ACE_Task_Base*)">
Resume all threads in an ACE_Task.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.suspend_task(ACE_5_6_0.ACE_Task_Base*)">
Suspend all threads in an ACE_Task.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.wait_task(ACE_5_6_0.ACE_Task_Base*)">
 Block until there are no more threads running in a specified task.
 This method will not wait for either detached or daemon threads;
 the threads must have been spawned with the @c THR_JOINABLE flag.
 Upon successful completion, the threads have been joined, so further
 attempts to join with any of the waited-for threads will fail.

 @param task  The ACE_Task_Base object whose threads are to waited for.

 @retval 0  Success.
 @retval -1 Failure (consult errno for further information).

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.get_grp(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get group ids for a particular thread id.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.set_grp(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
Set group ids for a particular thread id.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.cancel_grp(System.Int32,System.Int32)">
Cancel a group of threads.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.cancel(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
Cancel a single thread.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.cancel_all(System.Int32)">
Cancel's all the threads.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.kill_all(System.Int32)">
Send @a signum to all stopped threads.  Not supported on platforms
that do not have advanced signal support, such as Win32.
Send the @a signum to a single thread.  Not supported on platforms
that do not have advanced signal support, such as Win32.
Send @a signum to a group of threads, not supported on platforms
that do not have advanced signal support, such as Win32.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.resume_grp(System.Int32)">
Resume a group of threads.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.resume(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Resume a single thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.resume_all">
Resume all stopped threads
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.suspend_grp(System.Int32)">
Suspend a group of threads.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.suspend(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Suspend a single thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.suspend_all">
Suspend all threads
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.task">
Returns a pointer to the current ACE_Task_Base we're executing
in if this thread is indeed running in an ACE_Task_Base, else
return 0.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.thr_self(System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the "real" handle to the calling thread, caching it if
necessary in TSS to speed up subsequent lookups. This is
necessary since on some platforms (e.g., Win32) we can't get this
handle via direct method calls.  Notice that you should *not*
close the handle passed back from this method.  It is used
internally by Thread Manager.  On the other hand, you *have to*
use this internal thread handle when working on Thread_Manager.
Return -1 if fail.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.wait_grp(System.Int32)">
Block until there are no more threads running in a group.
Returns 0 on success and -1 on failure.  Notice that wait_grp
will not wait on detached threads.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.wait(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
 Block until there are no more threads running in this thread
 manager or @c timeout expires.

 @param timeout is treated as "absolute" time by default, but this
                can be changed to "relative" time by setting the @c
                use_absolute_time to 0.
 @param abandon_detached_threads If non-0, @c wait() will first
                                 check thru its thread list for
                                 threads with THR_DETACHED or
                                 THR_DAEMON flags set and remove
                                 these threads.  Notice that
                                 unlike other @c wait_*() methods,
                                 by default, @c wait() does wait on
                                 all thread spawned by this
                                 thread manager no matter the detached
                                 flags are set or not unless it is
                                 called with @c
                                 abandon_detached_threads flag set.
 @param use_absolute_time If non-0 then treat @c timeout as
                          absolute time, else relative time.
 @return 0 on success * and -1 on failure.

 NOTE that if this function is called while the @c
 ACE_Object_Manager is shutting down (as a result of program
 rundown via @c ACE::fini()), it will not wait for any threads to
 complete. If you must wait for threads spawned by this thread
 manager to complete and you are in a ACE rundown situation (such
 as your object is being destroyed by the @c ACE_Object_Manager)
 you can use @c wait_grp() instead.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.exit(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
 Called to clean up when a thread exits.

 @param do_thread_exit If non-0 then ACE_Thread::exit is called to
                       exit the thread
 @param status         If ACE_Thread_Exit is called, this is passed as
                       the exit value of the thread.
 Should _not_ be called by main thread.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.open(System.UInt32)">
No-op.  Currently unused.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.close_singleton">
Delete the dynamically allocated Singleton
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.instance(ACE_5_6_0.ACE_Thread_Manager*)">
Set pointer to a process-wide ACE_Thread_Manager and return
existing pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.instance">
Get pointer to a process-wide ACE_Thread_Manager.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Manager.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
 @brief Initialization and termination methods.

 Internally, ACE_Thread_Manager keeps a freelist for caching
 resources it uses to keep track of managed threads (not the
 threads themselves.)  @a prealloc, @a lwm, @a inc, @hwm
 determine the initial size, the low water mark, increment step,
 and high water mark of the freelist.

 @sa ACE_Free_List

</member>
        <member name="F:ACE_THR_JOINING">
Join operation has been invoked on the thread by thread manager.
</member>
        <member name="F:ACE_THR_TERMINATED">
Thread has shutdown, but the slot in the thread manager hasn't
been reclaimed yet.
</member>
        <member name="F:ACE_THR_CANCELLED">
Thread has been cancelled (which is an indiction that it needs to
terminate...).
</member>
        <member name="F:ACE_THR_SUSPENDED">
Thread is suspended.
</member>
        <member name="F:ACE_THR_RUNNING">
Thread is active (naturally, we don't know if it's actually
*running* because we aren't the scheduler...).
</member>
        <member name="F:ACE_THR_SPAWNED">
Created but not yet running.
</member>
        <member name="F:ACE_THR_IDLE">
Uninitialized.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor.terminated_">
Keep track of termination status.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor.sync_">
Registration lock to prevent premature removal of thread descriptor.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor.tm_">
Pointer to an ACE_Thread_Manager or NULL if there's no
ACE_Thread_Manager&gt;
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor.cleanup_info_">
Stores the cleanup info for a thread.
@note This should be generalized to be a stack of ACE_Cleanup_Info's.

</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor.at_exit_list_">
The AT_Thread_Exit list
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor.log_msg_">
Thread_Descriptor is the ownership of ACE_Log_Msg if log_msg_!=0
This can occur because ACE_TSS_cleanup was executed before terminate.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.terminate">
Terminate realize the cleanup process to thread termination
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.do_at_exit">
Run the AT_Thread_Exit hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.at_push(ACE_5_6_0.ACE_At_Thread_Exit*,System.Int32)">
Push an At_Thread_Exit to at thread termination list and set the
ownership of at.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.at_pop(System.Int32)">
Pop an At_Thread_Exit from at thread termination list, apply the at
if apply is true.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.reset(ACE_5_6_0.ACE_Thread_Manager*)">
Reset this thread descriptor.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.set_next(ACE_5_6_0.ACE_Thread_Descriptor*)">
Set/get the @c next_ pointer.  These are required by the
ACE_Free_List.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.acquire_release">
Do nothing but to acquire the thread descriptor's lock and
release.  This will first check if the thread is registered or
not.  If it is already registered, there's no need to reacquire
the lock again.  This is used mainly to get newly spawned thread
in synch with thread manager and prevent it from accessing its
thread descriptor before it gets fully built.  This function is
only called from ACE_Log_Msg::thr_desc.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.Dispose">
Do nothing destructor to keep some compilers happy
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.at_exit(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)">
Register an object (or array) for cleanup at thread termination.
"cleanup_hook" points to a (global, or static member) function
that is called for the object or array when it to be destroyed.
It may perform any necessary cleanup specific for that object or
its class.  "param" is passed as the second parameter to the
"cleanup_hook" function; the first parameter is the object (or
array) to be destroyed.  Returns 0 on success, non-zero on
failure: -1 if virtual memory is exhausted or 1 if the object (or
arrayt) had already been registered.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.at_exit(ACE_5_6_0.ACE_At_Thread_Exit*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Register an At_Thread_Exit hook and the ownership is retained for the
caller. Normally used when the at_exit hook is created in stack.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.at_exit(ACE_5_6_0.ACE_At_Thread_Exit*)">
Register an At_Thread_Exit hook and the ownership is acquire by
Thread_Descriptor, this is the usual case when the AT is dynamically
allocated.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.log_msg_cleanup(ACE_5_6_0.ACE_Log_Msg*)">
This cleanup function must be called only for ACE_TSS_cleanup.
The ACE_TSS_cleanup delegate Log_Msg instance destruction when
Log_Msg cleanup is called before terminate.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.self(System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Unique handle to thread (used by Win32 and AIX).
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor.self">
Unique thread id.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor_Base.next_">
We need these pointers to maintain the double-linked list in a
thread managers.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor_Base.task_">
Pointer to an ACE_Task_Base or NULL if there's no
ACE_Task_Base.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor_Base.thr_state_">
Current state of the thread.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor_Base.grp_id_">
Group ID.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor_Base.thr_handle_">
Unique handle to thread (used by Win32 and AIX).
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Descriptor_Base.thr_id_">
Unique thread ID.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor_Base.reset">
Reset this base thread descriptor.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor_Base.task">
Return the pointer to an ACE_Task_Base or NULL if there's no
ACE_Task_Base associated with this thread.;
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor_Base.state">
Current state of the thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor_Base.grp_id">
Group ID.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor_Base.op_Inequality(ACE_5_6_0.ACE_Thread_Descriptor_Base!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inequality operator.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Descriptor_Base.op_Equality(ACE_5_6_0.ACE_Thread_Descriptor_Base!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Equality operator.
</member>
        <member name="T:ACE_5_6_0.ACE_Thread_Descriptor_Base">
 @class ACE_Thread_Descriptor_Base

 @brief Basic information for thread descriptors.  These information
 gets extracted out because we need it after a thread is
 terminated.

 @internal

</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit_Func.apply">
The apply method
</member>
        <member name="F:ACE_5_6_0.ACE_At_Thread_Exit_Func.param_">
A param if required
</member>
        <member name="F:ACE_5_6_0.ACE_At_Thread_Exit_Func.func_">
The cleanup func
</member>
        <member name="F:ACE_5_6_0.ACE_At_Thread_Exit_Func.object_">
The object to be cleanup
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit_Func.#ctor(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)">
Constructor
</member>
        <member name="F:ACE_5_6_0.ACE_At_Thread_Exit.is_owner_">
The at has the ownership of this?
</member>
        <member name="F:ACE_5_6_0.ACE_At_Thread_Exit.was_applied_">
The at was applied?
</member>
        <member name="F:ACE_5_6_0.ACE_At_Thread_Exit.td_">
The Thread_Descriptor where this at is registered.
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit.apply">
The apply method.
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit.do_apply">
Do the apply if necessary
</member>
        <member name="F:ACE_5_6_0.ACE_At_Thread_Exit.next_">
The next At_Thread_Exit hook in the list.
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit.was_applied(System.Int32)">
Set applied state of At_Thread_Exit.
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit.was_applied">
This At_Thread_Exit was applied?
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit.is_owner(System.Int32)">
Set the ownership of the At_Thread_Exit.
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit.is_owner">
At_Thread_Exit has the ownership?
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit.Dispose">
The destructor
</member>
        <member name="M:ACE_5_6_0.ACE_At_Thread_Exit.#ctor">
Default constructor
</member>
        <member name="T:ACE_5_6_0.ACE_At_Thread_Exit">
 @class ACE_At_Thread_Exit

 @brief Contains a method to be applied when a thread is terminated.

</member>
        <member name="T:ACE_5_6_0.ACE_DLList_Node.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="T:ACE_5_6_0.ACE_DLList_Node">
 @class ACE_DLList_Node

 @brief Base implementation of element in a DL list.  Needed for
 ACE_Double_Linked_List.

</member>
        <member name="F:ACE_5_6_0.ACE_Condition_Thread_Mutex.mutex_">
Reference to mutex lock.
</member>
        <member name="F:ACE_5_6_0.ACE_Condition_Thread_Mutex.cond_">
Condition variable.
</member>
        <member name="T:ACE_5_6_0.ACE_Condition_Thread_Mutex.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.mutex">
Returns a reference to the underlying mutex;
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.broadcast">
Signal *all* waiting threads.
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.signal">
Signal one waiting thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.wait">
Block on condition.
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.remove">
Explicitly destroy the condition variable.  Note that only one
thread should call this method since it doesn't protect against
race conditions.

</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.Dispose">
Implicitly destroy the condition variable.
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.#ctor(ACE_5_6_0.ACE_Thread_Mutex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Condition_Attributes*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*)">
Initialize the condition variable.
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Thread_Mutex.#ctor(ACE_5_6_0.ACE_Thread_Mutex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*)">
Initialize the condition variable.
</member>
        <member name="T:ACE_5_6_0.ACE_Condition_Thread_Mutex">
 @class ACE_Condition_Thread_Mutex

 @brief ACE_Condition variable wrapper written using ACE_Mutexes This
 allows threads to block until shared data changes state.
 A condition variable enables threads to atomically block and
 test the condition under the protection of a mutual exclu-
 sion lock (mutex) until the condition is satisfied.  That is,
 the mutex must have been held by the thread before calling
 wait or signal on the condition.  If the condition is false,
 a thread blocks on a condition variable and atomically
 releases the mutex that is waiting for the condition to
 change.  If another thread changes the condition, it may wake
 up waiting threads by signaling the associated condition
 variable.  The waiting threads, upon awakening, reacquire the
 mutex and re-evaluate the condition.

 This should be an instantiation of ACE_Condition but problems
 with compilers precludes this...

</member>
        <member name="F:ACE_5_6_0.ACE_Condition_Attributes.attributes_">
The attributes
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Attributes.Dispose">
Destructor
</member>
        <member name="M:ACE_5_6_0.ACE_Condition_Attributes.#ctor(System.Int32)">
Constructor
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Exit_Maybe.instance_">
Holds the underlying instance.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit_Maybe.instance">
Returns the underlying instance.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit_Maybe.op_MemberSelection">
Delegates to underlying instance.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit_Maybe.Dispose">
Destroys the underlying ACE_Thread_Exit instance if it exists.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit_Maybe.#ctor(System.Int32)">
Don't create an ACE_Thread_Exit instance by default.
</member>
        <member name="T:ACE_5_6_0.ACE_Thread_Exit_Maybe">
 @class ACE_Thread_Exit_Maybe

 @brief A version of ACE_Thread_Exit that is created dynamically
 under the hood if the flag is set to TRUE.

 Allows the appearance of a "smart pointer", but is not
 always created.

</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Exit.is_constructed_">
Used to detect whether we should create a new instance (or not)
within the instance method -- we don't trust the instance_ ptr
because the destructor may have run (if ACE::fini() was called).
See bug #526.
We don't follow the singleton pattern due to dependency issues.

</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Exit.thread_control_">
Automatically add/remove the thread from the
ACE_Thread_Manager.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit.cleanup(System.Void*)">
Cleanup method, used by the ACE_Object_Manager to destroy the
singleton.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit.instance">
Singleton access point.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit.Dispose">
Destructor calls the thread-specific exit hooks when a thread
exits.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit.thr_mgr(ACE_5_6_0.ACE_Thread_Manager*)">
Set the ACE_Thread_Manager.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Exit.#ctor">
Capture the Thread that will be cleaned up automatically.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Control.status_">
Keeps track of the exit status for the thread.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Control.tm_">
Pointer to the thread manager for this block of code.
</member>
        <member name="T:ACE_5_6_0.ACE_Thread_Control.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Control.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Control.status">
Get the current exit status.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Control.status(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the exit status (and return existing status).
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Control.exit(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
Remove this thread from its associated ACE_Thread_Manager and exit
the thread if @a do_thr_exit is enabled.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Object_Ptr.service_object_">
Holds the service object until we're done.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Object_Ptr.op_MemberSelection">
Smart pointer to access the underlying ACE_Service_Object.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Object_Ptr.#ctor(ACE_5_6_0.ACE_Service_Object*)">
Acquire ownership of the @a so.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Type.active_">
1 if svc is currently active, otherwise 0.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Type.dll_">
ACE_DLL representing the shared object file (non-zero if
dynamically linked).
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Type.type_">
Pointer to C++ object that implements the svc.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Type.name_">
Humanly readible name of svc.
</member>
        <member name="T:ACE_5_6_0.ACE_Service_Type.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Type.dll(ACE_5_6_0.ACE_DLL!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the DLL
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Type.dll">
Get to the DLL's implentation
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Type.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Type.fini_called">
Check if the service has been fini'ed.
</member>
        <member name="F:DELETE_THIS">
Delete the enclosing object.
</member>
        <member name="F:DELETE_OBJ">
Delete the payload object.
</member>
        <member name="T:ACE_5_6_0.ACE_Service_Type">
 @class ACE_Service_Type

 @brief Keeps track of information related to the various
 ACE_Service_Type_Impl subclasses.

 This class acts as the interface of the "Bridge" pattern.

</member>
        <member name="M:ACE_5_6_0.ACE_Service_Object.resume">
Re-enable a previously suspended service.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Object.suspend">
Temporarily disable a service without removing it completely.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Object.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Object.#ctor(ACE_5_6_0.ACE_Reactor*)">
Constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**,System.Int32)">
Searches for a service object declaration in the local repo, only
</member>
        <member name="T:ACE_5_6_0.ACE_Service_Type_Dynamic_Guard">
 @class ACE_Service_Type_Dynamic_Guard

 @brief A forward service declaration guard.

 Helps to resolve an issue with hybrid services, i.e. dynamic
 services, accompanied by static services in the same DLL.  Only
 automatic instances of SDG are supposed to exist. Those are
 created during (dynamic) service initialization and serve to:

 (a) Ensure the service we are loading is ordered last in the
 repository, following any other services it may cause to register,
 as part of its own registration. This is a common case when
 loading dynamic services from DLLs - there are often static
 initializers, which register static services.

 (b) The SDG instance destructor detects if the dynamic service
 initialized successfully and "fixes-up" all the newly registered
 static services to hold a reference to the DLL, from which they
 have originated.

</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.processed_static_svcs_">
Repository of statically linked services for which process
directive was called, but the service is not already a member of
the static_svcs_ list.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.static_svcs_">
Repository of statically linked services.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.repo_">
The service repository to hold the services.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.svc_conf_file_queue_">
Queue of svc.conf files specified on the command-line.
   * @@ This should probably be made to handle unicode filenames...

</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.svc_queue_">
Queue of services specified on the command-line.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.no_static_svcs_">
Should we avoid loading the static services?
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.logger_key_">
Indicates where to write the logging output.  This is typically
either a STREAM pipe or a socket
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.svc_repo_size_">
Repository size is necessary, so that we can close (which may
destroy the repository instance), and then re-open again.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Gestalt.svc_repo_is_owned_">
Do we own the service repository instance, or have only been
given a ptr to the singleton?
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.init_i">
Performs the common initialization tasks for a new or previously
closed instance. Must not be virtual, as it is called from the
constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.process_directives_i(ACE_5_6_0.ACE_Svc_Conf_Param*)">
This is the implementation function that process_directives()
and process_directive() both call.  Returns the number of errors
that occurred.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.process_directive_i(ACE_5_6_0.ACE_Static_Svc_Descriptor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Process a static directive without also inserting its descriptor
the global table. This avoids multiple additions when processing
directives in non-global gestalts.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.process_commandline_directives">
Process service configuration requests that were provided on the
command-line.  Returns the number of errors that occurred.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.load_static_svcs">
Add the default statically-linked services to the
ACE_Service_Repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.open_i(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,System.Boolean)">
Performs an open without parsing command-line arguments.  The
@a logger_key indicates where to write the logging output, which
is typically either a STREAM pipe or a socket address.  If
@a ignore_default_svc_conf_file is non-0 then the "svc.conf" file
will be ignored.  If @a ignore_debug_flag is non-0 then the
application is responsible for setting the
@c ACE_Log_Msg::priority_mask() appropriately.  Returns number of
errors that occurred on failure and 0 otherwise.

</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.current_service_repository">
Get the current ACE_Service_Repository held by this object.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.find_static_svc_descriptor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Static_Svc_Descriptor**)">
Using the supplied name, finds and (if needed) returns a pointer to a
static service descriptor. Returns 0 for success and -1 for failure

</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.remove(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Totally remove @a svc_name from the daemon by removing it
from the ACE_Reactor, and unlinking it if necessary.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.resume(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Resume a @a svc_name that was previously suspended or has not yet
been resumed (e.g., a static service).
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.initialize(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Initialize and activate a statically @a svc_name service.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.initialize(ACE_5_6_0.ACE_Service_Type_Factory!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Dynamically link the shared object file and retrieve a pointer to
the designated shared object in this file. Also account for the
possiblity to have static services registered when loading the DLL, by
ensuring that the dynamic sevice is registered before any of its
subordibnate static services. Thus avoiding any finalization order
problems.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.process_directives">
Process (or re-process) service configuration requests that are
provided in the svc.conf file(s).  Returns the number of errors
that occurred.

</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.process_file(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Process a file containing a list of service configuration
directives.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.process_directive(ACE_5_6_0.ACE_Static_Svc_Descriptor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Process one static service definition.
 Load a new static service.

 @param ssd Service descriptor, see the document of
        ACE_Static_Svc_Descriptor for more details.

 @param force_replace If set the new service descriptor replaces
        any previous instance in the repository.

 @return Returns -1 if the service cannot be 'loaded'.

</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.process_directive(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Process one service configuration @a directive, which is passed as
a string.  Returns the number of errors that occurred.
</member>
        <member name="T:ACE_5_6_0.ACE_Service_Gestalt.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.is_opened">
Has it been opened?  Returns the difference between the times
open and close have been called on this instance
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.open(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,System.Boolean)">
 This is the primary entry point into the ACE_Service_Config (the
 constructor just handles simple initializations).  It parses
 arguments passed in from @a argc and @a argv parameters.  The
 arguments that are valid in a call to this method include:

 - '-b' Option to indicate that we should be a daemon. Note that when
        this option is used, the process will be daemonized before the
        service configuration file(s) are read. During daemonization,
        (on POSIX systems) the current directory will be changed to "/"
        so the caller should either fully specify the file names, or
        execute a @c chroot() to the appropriate directory.
        @sa ACE::daemonize().
 - '-d' Turn on debugging mode
 - '-f' Specifies a configuration file name other than the default
        svc.conf. Can be specified multiple times to use multiple files.
 - '-k' Specifies the rendezvous point to use for the ACE distributed
        logger.
 - '-y' Explicitly enables the use of static services. This flag
        overrides the @a ignore_static_svcs parameter value.
 - '-n' Explicitly disables the use of static services. This flag
        overrides the @a ignore_static_svcs parameter value.
 - '-p' Specifies a pathname which is used to store the process id.
 - '-s' Specifies a signal number other than SIGHUP to trigger reprocessing
        of the configuration file(s). Ignored for platforms that do not
        have POSIX signals, such as Windows.
 - '-S' Specifies a service directive string. Enclose the string in quotes
        and escape any embedded quotes with a backslash. This option
        specifies service directives without the need for a configuration
        file.

 @param argc The number of commandline arguments.
 @param argv The array with commandline arguments
 @param logger_key   Indicates where to write the logging output,
                     which is typically either a STREAM pipe or a
                     socket address.
 @param ignore_static_svcs   If true then static services are not loaded,
                             otherwise, they are loaded.
 @param ignore_default_svc_conf_file  If false then the @c svc.conf
                                      configuration file will be ignored.
 @param ignore_debug_flag If false then the application is responsible
                          for setting the @c ACE_Log_Msg::priority_mask
                          appropriately.

 @retval -1   The configuration file is not found or cannot
              be opened (errno is set accordingly).
 @retval  0   Success.
 @retval  &gt;0  The number of errors encountered while processing
              the service configuration file(s).

</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.Dispose">
Perform user-specified close activities and remove dynamic
memory.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Gestalt.#ctor(System.UInt32,System.Boolean,System.Boolean)">
Constructor either associates the instance with the process-wide
singleton instance of ACE_Service_Repository, or creates and
manages its own instance of the specified size.
</member>
        <member name="T:ACE_5_6_0.ACE_Service_Gestalt">
 * @class ACE_Service_Gestalt
 *
 * @brief Supplies common server operations for dynamic and static
 * configuration of services.
 *
 * The Gestalt embodies the concept of configuration context. On one
 * hand, it is a flat namespace, where names correspond to a Service
 * Object instance. A Gestalt owns the Service Repository instance,
 * which in turn owns the Service Object instances.
 *
 * Another aspect of a Gestalt is its responsibility for
 * record-keeping and accounting for the meta-data, necessary for
 * locating, removing or instantiating a service.
 *
 * A repository underlies an instance of a gestalt and its lifetime
 * may or may not be bounded by the lifetime of the gestalt, that owns
 * it. This feature is important for the derived classes and the
 * Service Config in particular.


</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Repository.lock_">
Synchronization variable for the MT_SAFE Repository
</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Repository.shutting_down_">
Flag set when repository is the process of shutting down.  This
is necessary to keep from self-deadlocking since some of
the components might make calls back to the repository to
unload their components, e.g., ACE_DLL_Manager.
</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Repository.repository_">
Pointer to a process-wide ACE_Framework_Repository.
</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Repository.total_size_">
Maximum number of components.
</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Repository.current_size_">
Current number of components.
</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Repository.component_vector_">
Contains all the framework components.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.#ctor(ACE_5_6_0.ACE_Framework_Repository!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Disallow copying and assignment.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.compact">
Compact component_vector_ after components have been removed__maintains
order.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.remove_dll_components_i(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Actually removes the dll components, must be called with locks held.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.#ctor(System.Int32)">
Initialize the repository.
</member>
        <member name="T:ACE_5_6_0.ACE_Framework_Repository.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.total_size">
Return the total size of the repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.current_size">
Return the current size of the repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.remove_dll_components(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Remove all components associated with a particular dll.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.remove_component(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Remove a component.  Returns -1 on error or if component not found
and 0 on success.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.register_component(ACE_5_6_0.ACE_Framework_Component*)">
Insert a new component.  Returns -1 when the repository is full
and 0 on success.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.close_singleton">
Delete the dynamically allocated Singleton.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.instance(System.Int32)">
Get pointer to a process-wide ACE_Framework_Repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.close">
Close down the repository and free up dynamically allocated
resources, also called by dtor.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.open(System.Int32)">
Initialize the repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Repository.Dispose">
Close down the repository and free up dynamically allocated
resources.
</member>
        <member name="T:ACE_5_6_0.ACE_Framework_Repository">
 @class ACE_Framework_Repository

 @brief Contains all framework components used by an application.

 This class contains a vector of ACE_Framework_Component *'s.  On
 destruction, framework components are destroyed in the reverse order
 that they were added originally.

</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Component.name_">
Component name
</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Component.dll_name_">
Library associated with this component
</member>
        <member name="F:ACE_5_6_0.ACE_Framework_Component.this_">
Pointer to the actual component.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Component.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Component.close_singleton">
Close the contained singleton.
</member>
        <member name="M:ACE_5_6_0.ACE_Framework_Component.#ctor(System.Void*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Framework_Component">
 @class ACE_Framework_Component

 @brief Base class that defines a uniform interface for all managed
 framework components.

</member>
        <member name="M:ACE_5_6_0.ACE_Static_Object_Lock.cleanup_lock">
For use only by ACE_Object_Manager to clean up lock if it
what dynamically allocated.
</member>
        <member name="M:ACE_5_6_0.ACE_Static_Object_Lock.instance">
Static lock access point.
</member>
        <member name="T:ACE_5_6_0.ACE_Static_Object_Lock">
 @class ACE_Static_Object_Lock

 @brief Provide an interface to access a global lock.

 This class is used to serialize the creation of static
 singleton objects.  It really isn't needed any more, because
 anyone can access ACE_STATIC_OBJECT_LOCK directly.  But, it
 is retained for backward compatibility.

</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.singleton_recursive_lock_">
Lock for guarding singleton creation, when Object_Manager
hasn't been started up, or has already been shut down.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.singleton_null_lock_">
Null lock for guarding singleton creation.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.internal_lock_">
Lock that is used to guard internal structures.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.instance_">
Singleton pointer.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.preallocated_array">
Table of preallocated arrays.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.preallocated_object">
Table of preallocated objects.
</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager.at_exit_i(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)">
Register an object or array for deletion at program termination.
See description of static version above for return values.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.ace_service_config_sig_handler_">
ACE_Service_Config signal handler.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.preallocations_">
Preallocated objects collection.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager.exit_info_">
For at_exit support.
</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager.default_mask">
@deprecated Accesses a default signal set used, for example,
in ACE_Sig_Guard methods.
Deprecated: use ACE_Object_Manager::default_mask () instead.

</member>
        <member name="F:ACE_PREALLOCATED_ARRAYS">
Hook for preallocated arrays provided by application.
</member>
        <member name="F:ACE_EMPTY_PREALLOCATED_ARRAY">
There currently are no preallocated arrays in the ACE
library.  If the application doesn't have any, make sure
the the preallocated_array size is at least one by declaring
this dummy . . .
</member>
        <member name="T:ACE_5_6_0.ACE_Object_Manager.Preallocated_Array">
Unique identifiers for preallocated arrays.  Please see
ace/Managed_Object.h for information on accessing preallocated
arrays.
</member>
        <member name="T:ACE_5_6_0.ACE_Object_Manager.Preallocated_Object">
Unique identifiers for preallocated objects.  Please see
ace/Managed_Object.h for information on accessing preallocated
objects.
</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager.shutting_down">
Returns 1 after the ACE_Object_Manager has been destroyed.  This
flag can be used to determine if the program is in the midst of
destroying static objects.  (Note that the program might destroy
some static objects before this flag can return 1, if
ACE_HAS_NONSTATIC_OBJECT_MANAGER is not defined.)

</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager.starting_up">
Returns 1 before the ACE_Object_Manager has been constructed.
This flag can be used to determine if the program is constructing
static objects.  If no static object spawns any threads, the
program will be single-threaded when this flag returns 1.  (Note
that the program still might construct some static objects when
this flag returns 0, if ACE_HAS_NONSTATIC_OBJECT_MANAGER is not
defined.)

</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager.fini">
Explicitly destroy the singleton instance of the
ACE_Object_Manager.  Returns 0 on success, -1 on failure, and 1
if it had already been called.

</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager.init">
Explicitly initialize (construct the singleton instance of) the
ACE_Object_Manager.  Returns 0 on success, -1 on failure, and 1
if it had already been called.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread.#ctor">
Ensure that we don't get instantiated.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.testcancel">
Test the cancel.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.cancel(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Cancel a thread.
@note This method is only portable on platforms, such as POSIX pthreads,
that support thread cancellation.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread.setcancelstate(ACE_5_6_0.cancel_state*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.cancel_state*)">
Set the cancellation state.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.enablecancel(ACE_5_6_0.cancel_state*,System.Int32)">
Enable thread cancellation.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.disablecancel(ACE_5_6_0.cancel_state*)">
Disable thread cancellation.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.getspecific(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void**)">
Stores the current value bound to @a key for the calling thread
into the location pointed to by @a valuep.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.setspecific(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*)">
Bind value to the thread-specific data key, @a key, for the calling
thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.keyfree(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Free up the key so that other threads can reuse it.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.keycreate(System.UInt32!System.Runtime.CompilerServices.IsLong*,=FUNC:System.Void(System.Void*),System.Void*)">
Allocates a @a keyp that is used to identify data that is specific
to each thread in the process.  The key is global to all threads
in the process.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread.sigsetmask(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsConst*,System.UInt32*)">
Change and/or examine calling thread's signal mask.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.setconcurrency(System.Int32)">
Set the LWP concurrency level of the process.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.getconcurrency">
Get the LWP concurrency level of the process.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.exit(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Exit the current thread and return "status".
Should _not_ be called by main thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.self">
Return the unique ID of the thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.self(System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the unique kernel handle of the thread.  Note that on
Win32 this is actually a pseudohandle, which cannot be shared
with other processes or waited on by threads.  To locate the real
handle, please use the ACE_Thread_Manager::thr_self() method.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread.yield">
Yield the thread to another.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.kill(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
Send a signal to the thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.setprio(System.Void*,System.Int32,System.Int32)">
Set the priority of a particular thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.getprio(System.Void*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the priority and policy of a particular thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.getprio(System.Void*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the priority of a particular thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.suspend(System.Void*)">
Suspend the execution of a particular thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.resume(System.Void*)">
Continue the execution of a previously suspended thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.join(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong*)">
Wait for one thread to exit and reap its exit status.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread.join(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32!System.Runtime.CompilerServices.IsLong*)">
 Wait for one or more threads to exit and reap their exit status.
 thr_join() returns successfully when the target thread terminates.

 @param thread_id is the ACE_thread_t ID of the thread to wait for.
                  If @a thread_id is 0, join() waits for any
                  undetached thread in the process to terminate
                  on platforms that support this capability
                  (for example, Solaris).
 @param departed  points to a location that is set to the ID of the
                  terminated thread if join() returns successfully.
                  If @a departed is 0, it is ignored.
 @param status    Points to the location that receives the joined
                  thread's exit value. If @a status is 0, it is ignored.

 @retval  0 for success
 @retval  -1 (with errno set) for failure.

</member>
        <member name="F:ACE_5_6_0.cancel_state.canceltype">
e.g., PTHREAD_CANCEL_DEFERRED and PTHREAD_CANCEL_ASYNCHRONOUS.
</member>
        <member name="F:ACE_5_6_0.cancel_state.cancelstate">
e.g., PTHREAD_CANCEL_ENABLE, PTHREAD_CANCEL_DISABLE,
PTHREAD_CANCELED.
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Adapter.thr_mgr_">
Optional thread manager.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Adapter.invoke_i">
Called by invoke, mainly here to separate the SEH stuff because
SEH on Win32 doesn't compile with local vars with destructors.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Adapter.Dispose">
Ensure that this object must be allocated on the heap.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Adapter.thr_mgr">
Accessor for the optional ACE_Thread_Manager.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Adapter.#ctor(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),ACE_5_6_0.ACE_Thread_Manager*,ACE_5_6_0.ACE_Thread_Descriptor*,=FUNC:System.Int32(System.Void*),=FUNC:System.Int32(System.Void*))">
Constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Thread_Adapter">
 @class ACE_Thread_Adapter

 @brief Converts a C++ function into a function that
 can be called from a thread creation routine
 (e.g., pthread_create() or _beginthreadex()) that expects an
 extern "C" entry point.  This class also makes it possible to
 transparently provide hooks to register a thread with an
 ACE_Thread_Manager.

 This class is used in ACE_OS::thr_create().  In general, the
 thread that creates an object of this class is different from
 the thread that calls @c invoke() on this object.  Therefore,
 the @c invoke() method is responsible for deleting itself.

</member>
        <member name="F:ACE_5_6_0.ACE_Service_Repository_Iterator.ignore_suspended_">
Are we ignoring suspended services?
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Repository_Iterator.next_">
Next index location that we haven't yet seen.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Repository_Iterator.svc_rep_">
Reference to the Service Repository we are iterating over.
</member>
        <member name="T:ACE_5_6_0.ACE_Service_Repository_Iterator.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository_Iterator.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository_Iterator.advance">
Move forward by one element in the repository.  Returns 0 when all the
items in the set have been seen, else 1.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository_Iterator.done">
Returns 1 when all items have been seen, else 0.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository_Iterator.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository_Iterator.#ctor(ACE_5_6_0.ACE_Service_Repository*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Constructor initializes the iterator.
</member>
        <member name="T:ACE_5_6_0.ACE_Service_Repository_Iterator">
 @class ACE_Service_Repository_Iterator

 @brief Iterate through the ACE_Service_Repository.

 Make sure not to delete entries as the iteration is going on
 since this class is not designed as a robust iterator.

</member>
        <member name="F:ACE_5_6_0.ACE_Service_Repository.lock_">
Synchronization variable for the MT_SAFE Repository
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Repository.svc_rep_">
Pointer to a process-wide ACE_Service_Repository.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Repository.total_size_">
Maximum number of services.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Repository.current_size_">
Current number of services.
</member>
        <member name="F:ACE_5_6_0.ACE_Service_Repository.service_vector_">
Contains all the configured services.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.relocate_i(System.UInt32,System.UInt32,ACE_5_6_0.ACE_DLL!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief Relocate (static) services to another DLL.

If any have been registered in the context of a "forward
declaration" guard, those really aren't static services. Their
code is in the DLL's code segment, or in one of the dependent
DLLs. Therefore, such services need to be associated with the
proper DLL in order to prevent failures upon finalization. The
method locks the repo.

Works by having the service type keep a reference to a specific
DLL. No locking, caller makes sure calling it is safe. You can
forcefully relocate any DLLs in the given range, not only the
static ones - but that will cause Very Bad Things (tm) to happen.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.find_i(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**,System.Boolean)">
 Locate a named entry in the service table, optionally ignoring
 suspended entries.

 @param service_name The name of the service to search for.
 @param slot         Receives the position index of the service if it
                     is found. Contents are meaningless if this method
                     returns -1.
 @param srp          Optional; if not 0, it is a pointer to a location
                     to receive the ACE_Service_Type pointer for the
                     located service. Meaningless if this method
                     returns -1.
 @param ignore_suspended If true, the search ignores suspended services.

 @retval  0 Named service was located; index in the table is set in
            @a slot.
 @retval -1 Named service was not found.
 @retval -2 Named service was found, but is suspended and
            @a ignore_suspended is true.

</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.remove_i(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type**)">
Remove an existing service record. It requires @a sr != 0, which
receives the service record pointer and the caller is
responsible for properly disposing of it.
</member>
        <member name="T:ACE_5_6_0.ACE_Service_Repository.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.total_size">
Return the total size of the repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.current_size">
Return the current size of the repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.suspend(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**)">
Suspend a service record.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.resume(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**)">
Resume a service record.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.remove(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type**)">
Remove an existing service record. If @a sr == 0, the service record
is deleted before control is returned to the caller. If @a sr != 0,
the service's record is removed from the repository, but not deleted;
*sr receives the service record pointer and the caller is responsible
for properly disposing of it.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**,System.Boolean)">
 Locate a named entry in the service table, optionally ignoring
 suspended entries.

 @param service_name The name of the service to search for.
 @param srp          Optional; if not 0, it is a pointer to a location
                     to receive the ACE_Service_Type pointer for the
                     located service. Meaningless if this method
                     returns -1.
 @param ignore_suspended If true, the search ignores suspended services.

 @retval  0 Named service was located.
 @retval -1 Named service was not found.
 @retval -2 Named service was found, but is suspended and
            @a ignore_suspended is true.

</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.insert(ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst*)">
Insert a new service record.  Returns -1 when the service repository
is full and 0 on success.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.close_singleton">
Delete the dynamically allocated Singleton.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.instance(ACE_5_6_0.ACE_Service_Repository*)">
Set pointer to a process-wide ACE_Service_Repository and return
existing pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.instance(System.UInt32)">
Get pointer to a process-wide ACE_Service_Repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.close">
Close down the repository and free up dynamically allocated
resources.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.Dispose">
Close down the repository and free up dynamically allocated
resources.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.open(System.UInt32)">
Initialize the repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.#ctor(System.UInt32)">
Initialize the repository.
</member>
        <member name="M:ACE_5_6_0.ACE_Service_Repository.#ctor">
Initialize the repository.
</member>
        <member name="F:ACE_5_6_0.ACE_Recursive_Thread_Mutex.lock_">
Recursive mutex.
</member>
        <member name="T:ACE_5_6_0.ACE_Recursive_Thread_Mutex.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.get_nesting_mutex">
Returns a reference to the recursive mutex's internal mutex;
</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.mutex">
Returns a reference to the recursive mutex;
</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.get_nesting_level">
Return the nesting level of the recursion.  When a thread has
acquired the mutex for the first time, the nesting level == 1.
The nesting level is incremented every time the thread acquires
the mutex recursively.  Note that if the ACE_HAS_RECURSIVE_MUTEXES
macro is enabled then this method may return -1 on platforms that
do not expose the internal count.

</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.get_thread_id">
Return the id of the thread that currently owns the mutex.
</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.release">
Releases a recursive mutex (will not release mutex until all the
nesting level drops to 0, which means the mutex is no longer
held).

</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.tryacquire_write_upgrade">
This is only here to make the ACE_Recursive_Thread_Mutex
interface consistent with the other synchronization APIs.
Assumes the caller has already acquired the mutex using one of
the above calls, and returns 0 (success) always.

</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.tryacquire">
Conditionally acquire a recursive mutex (i.e., won't block).
Returns -1 on failure.  If we "failed" because someone else
already had the lock, @c errno is set to @c EBUSY.

</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Block the thread until we acquire the mutex or until @a tv times
out, in which case -1 is returned with @c errno == @c ETIME.  Note
that @a tv is assumed to be in "absolute" rather than "relative"
time.  The value of @a tv is updated upon return to show the
actual (absolute) acquisition time.

</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.acquire">
Acquire a recursive mutex (will increment the nesting level and
not deadmutex if the owner of the mutex calls this method more
than once).

</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.remove">
Implicitly release a recursive mutex.  Note that only one thread
should call this method since it doesn't protect against race
conditions.

</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.Dispose">
Implicitly release a recursive mutex.
</member>
        <member name="M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_mutexattr_t*)">
Initialize a recursive mutex.
</member>
        <member name="T:ACE_5_6_0.ACE_Recursive_Thread_Mutex">
 @class ACE_Recursive_Thread_Mutex

 @brief Implement a C++ wrapper that allows nested acquisition and
 release of a mutex that occurs in the same thread.

</member>
        <member name="F:ACE_5_6_0.ACE_Tokenizer.delimiter_index_">
Pointer to the next free space in delimiters_.
</member>
        <member name="F:ACE_5_6_0.ACE_Tokenizer.delimiters_">
The tokenizer allows MAX_DELIMITERS number of delimiters.
</member>
        <member name="F:ACE_5_6_0.ACE_Tokenizer.Delimiter_Entry.delimiter_">
Most commonly a space ' '.
What occurrences of delimiter_ should be replaced with.
Whether replacement_ should be used.  This should be replaced
with a technique that sets replacement_ = delimiter by
default.  I'll do that next iteration.

</member>
        <member name="T:ACE_5_6_0.ACE_Tokenizer.Delimiter_Entry">
 @class Delimiter_Entry

 @brief Delimiter Entry

 Describes a delimiter for the tokenizer.

</member>
        <member name="F:ACE_5_6_0.ACE_Tokenizer.preserves_index_">
Pointer to the next free spot in preserves_.
</member>
        <member name="F:ACE_5_6_0.ACE_Tokenizer.preserves_">
The application can specify MAX_PRESERVES preserve designators.
</member>
        <member name="F:ACE_5_6_0.ACE_Tokenizer.Preserve_Entry.start_">
E.g., "(".
E.g., ")".
Whether the designators should be removed from the token.

</member>
        <member name="T:ACE_5_6_0.ACE_Tokenizer.Preserve_Entry">
 @class Preserve_Entry

 @brief Preserve Entry

 Defines a set of characters that designate an area that
 should not be parsed, but should be treated as a complete
 token.  For instance, in: (this is a preserve region), start
 would be a left paren -(- and stop would be a right paren
 -)-.  The strip determines whether the designators should be
 removed from the token.

</member>
        <member name="M:ACE_5_6_0.ACE_Tokenizer.next">
Returns the next token.
</member>
        <member name="M:ACE_5_6_0.ACE_Tokenizer.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
\a buffer will be parsed.  Notice that ACE_Tokenizer will modify
\a buffer if you use <code> delimiter_replace </code> or <code>
preserve_designators </code> to do character substitution.
@note You should NOT pass a constant string or string literal
to this constructor, since ACE_Tokenizer will try to modify
the string.
\sa preserve_designators
\sa preserve_designators

</member>
        <member name="T:ACE_5_6_0.ACE_Tokenizer">
 @class ACE_Tokenizer

 @brief Tokenizer

 Tokenizes a buffer.  Allows application to set delimiters and
 preserve designators.  Does not allow special characters, yet
 (e.g., printf ("\"like a quoted string\"")).

</member>
        <member name="F:ACE_5_6_0.ACE_SString.rep_">
Pointer to data.
</member>
        <member name="F:ACE_5_6_0.ACE_SString.len_">
Length of the ACE_SString (not counting the trailing '\0').
</member>
        <member name="F:ACE_5_6_0.ACE_SString.allocator_">
Pointer to a memory allocator.
</member>
        <member name="T:ACE_5_6_0.ACE_SString.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.op_Inequality(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inequality comparison operator.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.op_GreaterThan(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Greater than comparison operator.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.op_LessThan(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Less than comparison operator.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.op_Equality(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Equality comparison operator (must match entire string).
</member>
        <member name="M:ACE_5_6_0.ACE_SString.strstr(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Comparison operator that will match substrings.  Returns the
slot of the first location that matches, else @c npos.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.fast_rep">
Get the underlying pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.rep">
Get the underlying pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.rep(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
Set the underlying pointer.  Since this does not copy memory or
delete existing memory use with extreme caution!!!
</member>
        <member name="M:ACE_5_6_0.ACE_SString.length">
Return the length of the string.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.hash">
Returns a hash value for this string.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.substr(System.UInt32,System.UInt32)">
Same as substring
</member>
        <member name="M:ACE_5_6_0.ACE_SString.substring(System.UInt32,System.UInt32)">
Return a substring given an offset and length, if length == npos
use rest of str return empty substring if offset or offset/length
are invalid

</member>
        <member name="M:ACE_5_6_0.ACE_SString.op_Assign(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator (does copy memory).
</member>
        <member name="M:ACE_5_6_0.ACE_SString.Dispose">
Default destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,ACE_5_6_0.ACE_Allocator*)">
Constructor that copies @a c into dynamically allocated memory.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.#ctor(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,ACE_5_6_0.ACE_Allocator*)">
Constructor that copies @a len chars of  @s  into dynamically
allocated memory (will NUL terminate the result).
</member>
        <member name="M:ACE_5_6_0.ACE_SString.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*)">
Constructor that copies @a s into dynamically allocated memory.
</member>
        <member name="M:ACE_5_6_0.ACE_SString.#ctor(ACE_5_6_0.ACE_Allocator*)">
Default constructor.
</member>
        <member name="F:ACE_5_6_0.ACE_SString.npos">
No position constant
</member>
        <member name="T:ACE_5_6_0.ACE_SString">
 @class ACE_SString

 @brief A very Simple String ACE_SString class.  This is not a
 general-purpose string class, and you should probably consider
 using ACE_CString is you don't understand why this class
 exists...

 This class is optimized for efficiency, so it doesn't provide
 any internal locking.
 CAUTION: This class is only intended for use with applications
 that understand how it works.  In particular, its destructor
 does not deallocate its memory when it is destroyed...  We need
 this class since the ACE_Map_Manager requires an object that
 supports the operator == and operator !=.  This class uses an
 ACE_Allocator to allocate memory.  The user can make this a
 persistant class by providing an ACE_Allocator with a
 persistable memory pool.

</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.ushort_rep">
Transform into a copy of a USHORT16 representation (caller must
delete).  Note, behavior is undefined when sizeof (wchar_t) != 2.
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.char_rep">
Transform into a copy of the ASCII character representation.
(caller must delete)
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.#ctor(System.Char,ACE_5_6_0.ACE_Allocator*)">
Constructor that copies @a c into dynamically allocated memory.
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.#ctor(ACE_5_6_0.ACE_NS_WString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.#ctor(System.UInt32,ACE_5_6_0.ACE_Allocator*)">
Constructor that dynamically allocates memory for @a len + 1
ACE_WSTRING_TYPE characters. The newly created memory is set memset to 0.
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.#ctor(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32,ACE_5_6_0.ACE_Allocator*)">
Constructor that copies @a len ACE_WSTRING_TYPE's of @a s into dynamically
allocated memory (will NUL terminate the result).
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.#ctor(System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt32,ACE_5_6_0.ACE_Allocator*)">
Constructor that takes in a ushort16 string (mainly used by the
ACE Name_Space classes)
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.#ctor(System.Char!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*)">
Constructor that copies @a s into dynamically allocated memory.
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*)">
Constructor that copies @a s into dynamically allocated memory.
</member>
        <member name="M:ACE_5_6_0.ACE_NS_WString.#ctor(ACE_5_6_0.ACE_Allocator*)">
Default constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_NS_WString">
 @class ACE_NS_WString

 @brief This class retain the backward compatibility for
        ACE_Naming_Context and related classes.  The only addition to
        ACE_WString is a very naive "wchar" to "char" conversion
        function.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.socket(System.Int32,System.Int32,System.Int32)">
Create a BSD-style socket (no QoS).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.socket_fini">
Finalize WinSock after last use (e.g., when a DLL is unloaded).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.socket_init(System.Int32,System.Int32)">
Initialize WinSock before first use (e.g., when a DLL is first
loaded or the first use of a socket() call.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.setsockopt(System.Void*,System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Manipulate the options associated with a socket.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.join_leaf(System.Void*,sockaddr!System.Runtime.CompilerServices.IsConst*,System.Int32,ACE_5_6_0.ACE_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Joins a leaf node into a QoS-enabled multi-point session.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.enum_protocols(System.Int32*,_WSAPROTOCOL_INFOA*,System.UInt32!System.Runtime.CompilerServices.IsLong*)">
Retrieve information about available transport protocols
installed on the local machine. Windows specific...
</member>
        <member name="F:ACE_5_6_0.ACE_OS.socket_initialized_">
Keeps track of whether we've already initialized WinSock...
</member>
        <member name="F:ACE_5_6_0.ACE_Accept_QoS_Params.callback_data_">
This data is passed back to the application as a condition
function parameter, i.e., it is an Asynchronous Completion Token
(ACT).

</member>
        <member name="M:ACE_5_6_0.ACE_Accept_QoS_Params.callback_data(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set callback data.
</member>
        <member name="M:ACE_5_6_0.ACE_Accept_QoS_Params.callback_data">
Get callback data.
</member>
        <member name="M:ACE_5_6_0.ACE_Accept_QoS_Params.qos_condition_callback(=FUNC:System.Int32(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,iovec*,iovec*,System.UInt32*,System.UInt32!System.Runtime.CompilerServices.IsLong))">
Set QoS condition callback.
</member>
        <member name="M:ACE_5_6_0.ACE_Accept_QoS_Params.qos_condition_callback">
Get QoS condition callback.
</member>
        <member name="F:ACE_5_6_0.ACE_QoS_Params.flags_">
Flags that indicate if we're a sender, receiver, or both.
</member>
        <member name="F:ACE_5_6_0.ACE_QoS_Params.group_socket_qos_">
A pointer to the flow speicfications for the socket group, if
applicable.
</member>
        <member name="F:ACE_5_6_0.ACE_QoS_Params.socket_qos_">
A pointer to the flow speicfications for the socket, one for each
direction.
</member>
        <member name="F:ACE_5_6_0.ACE_QoS_Params.callee_data_">
A pointer to the user data that is to be transferred back from
the peer during connection establishment.
</member>
        <member name="F:ACE_5_6_0.ACE_QoS_Params.caller_data_">
A pointer to the user data that is to be transferred to the peer
during connection establishment.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.flags(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set flags.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.flags">
Get flags.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.group_socket_qos(ACE_5_6_0.ACE_QoS*)">
Set group socket qos.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.group_socket_qos">
Get group socket qos.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.socket_qos(ACE_5_6_0.ACE_QoS*)">
Set socket qos.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.socket_qos">
Get socket qos.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.callee_data(iovec*)">
Set callee data.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.callee_data">
Get callee data.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.caller_data(iovec*)">
Set caller data.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS_Params.caller_data">
Get caller data.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS.provider_specific(iovec!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the provider specific information.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS.provider_specific">
Get the provider specific information.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS.receiving_flowspec(ACE_5_6_0.ACE_Flow_Spec*)">
Set the flow spec for data receiving.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS.receiving_flowspec">
Get the flow spec for data receiving.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS.sending_flowspec(ACE_5_6_0.ACE_Flow_Spec*)">
Set the flow spec for data sending.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS.sending_flowspec">
Get the flow spec for data sending.
</member>
        <member name="M:ACE_5_6_0.ACE_QoS.#ctor">
Constructor
</member>
        <member name="T:ACE_5_6_0.ACE_QoS">
 @class ACE_QoS

 @brief Wrapper class that holds the sender and receiver flow spec
     information, which is used by IntServ (RSVP) and DiffServ.

</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.priority(System.Int32)">
Set the priority.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.priority">
Get the priority.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.ttl(System.Int32)">
Set the time-to-live.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.ttl">
Get the time-to-live.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.minimum_policed_size(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the minimum policed size in bytes.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.minimum_policed_size">
Get the minimum policed size in bytes.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.max_sdu_size(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the maximum SDU size in bytes.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.max_sdu_size">
Get the maximum SDU size in bytes.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.service_type(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the service type.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.service_type">
Get the service type.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.delay_variation(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the delay variation in microseconds.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.delay_variation">
Get the delay variation in microseconds.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.latency(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the latency in microseconds.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.latency">
Get the latency in microseconds.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.peak_bandwidth(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the PeakBandwidth in bytes/sec.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.peak_bandwidth">
Get the PeakBandwidth in bytes/sec.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.token_bucket_size(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the token bucket size in bytes.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.token_bucket_size">
Get the token bucket size in bytes.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.token_rate(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the token rate in bytes/sec.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.token_rate">
Get the token rate in bytes/sec.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Int32)">
Constructor that initializes all the fields.
</member>
        <member name="M:ACE_5_6_0.ACE_Flow_Spec.#ctor">
Default constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Flow_Spec">
 @class ACE_Flow_Spec

 @brief Wrapper class that defines the flow spec QoS information,
    which is used by IntServ (RSVP) and DiffServ.

</member>
        <member name="M:ACE_5_6_0.ACE_Str_Buf.#ctor(strbuf*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Str_Buf.#ctor(System.Void*,System.Int32,System.Int32)">
Constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Str_Buf">
 @class ACE_Str_Buf

 @brief Simple wrapper for STREAM pipes strbuf.

</member>
        <member name="F:strbuf.buf">
Pointer to data.
</member>
        <member name="F:strbuf.len">
No. of bytes returned.
</member>
        <member name="F:strbuf.maxlen">
No. of bytes in buffer.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_towupper(System.UInt16)">
Converts a character to upper case (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_toupper(System.Int32)">
Converts a character to upper case (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_towlower(System.UInt16)">
Converts a character to lower case (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_tolower(System.Int32)">
Converts a character to lower case (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_isxdigit(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is a hexadecimal-digit character.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_isupper(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is an uppercase character.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_isspace(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is a space character.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_ispunct(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is a punctuation character.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_isprint(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is a printable character.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_islower(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is a lowercase character.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_isgraph(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is a printable character other than a space.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_isdigit(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is a decimal-digit character.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_iscntrl(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is a control character.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_isalpha(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns true if the character is an alphabetic character.
</member>
        <member name="M:ACE_5_6_0.ACE.restore_non_blocking_mode(System.Void*,System.Int32)">
Cleanup after a timed operation, restore the appropriate
non-blocking status of @a handle.
</member>
        <member name="M:ACE_5_6_0.ACE.record_and_set_non_blocking_mode(System.Void*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This makes sure that @a handle is set into non-blocking mode.
@a val keeps track of whether were in non-blocking mode or not.
</member>
        <member name="M:ACE_5_6_0.ACE.enter_send_timedwait(System.Void*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Wait for @a timeout before proceeding to a @c send operation.
@a val keeps track of whether we're in non-blocking mode or
not.
</member>
        <member name="M:ACE_5_6_0.ACE.enter_recv_timedwait(System.Void*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Wait for @a timeout before proceeding to a @c recv operation.
@a val keeps track of whether we're in non-blocking mode or
not.
</member>
        <member name="M:ACE_5_6_0.ACE.handle_ready(System.Void*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32)">
Timed wait for handle to get read, write, or exception ready.
</member>
        <member name="M:ACE_5_6_0.ACE.handle_exception_ready(System.Void*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)">
Timed wait for handle to get exception ready.
</member>
        <member name="M:ACE_5_6_0.ACE.handle_write_ready(System.Void*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)">
Timed wait for handle to get write ready.
</member>
        <member name="M:ACE_5_6_0.ACE.handle_read_ready(System.Void*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)">
Timed wait for handle to get read ready.
</member>
        <member name="M:ACE_5_6_0.ACE.select(System.Int32,ACE_5_6_0.ACE_Handle_Set*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)">
Wrapper facade for the most common use of @c select that uses
@c ACE_Handle_Sets.
</member>
        <member name="M:ACE_5_6_0.ACE.select(System.Int32,ACE_5_6_0.ACE_Handle_Set*,ACE_5_6_0.ACE_Handle_Set*,ACE_5_6_0.ACE_Handle_Set*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)">
Wrapper facade for @c select that uses @c ACE_Handle_Sets.
</member>
        <member name="M:ACE_5_6_0.ACE.hex2byte(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Convert a hex character to its byte representation.
</member>
        <member name="M:ACE_5_6_0.ACE.nibble2hex(System.UInt32)">
Hex conversion utility.
</member>
        <member name="M:ACE_5_6_0.ACE.log2(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Computes the base 2 logarithm of {num}.
</member>
        <member name="M:ACE_5_6_0.ACE.unique_name(System.Void!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
This method uses process id and object pointer to come up with a
machine wide unique name.  The process ID will provide uniqueness
between processes on the same machine. The "this" pointer of the
{object} will provide uniqueness between other "live" objects in
the same process. The uniqueness of this name is therefore only
valid for the life of {object}.

</member>
        <member name="M:ACE_5_6_0.ACE.terminate_process(System.Int32!System.Runtime.CompilerServices.IsLong)">
Terminate the process abruptly with id @a pid.  On Win32 platforms
this uses {TerminateProcess} and on POSIX platforms is uses
{kill} with the -9 (SIGKILL) signal, which cannot be caught or
ignored.  Note that this call is potentially dangerous to use
since the process being terminated may not have a chance to
cleanup before it shuts down.

</member>
        <member name="M:ACE_5_6_0.ACE.process_active(System.Int32!System.Runtime.CompilerServices.IsLong)">
Checks if process with {pid} is still alive.  Returns 1 if it is
still alive, 0 if it isn't alive, and -1 if something weird
happened.

</member>
        <member name="M:ACE_5_6_0.ACE.is_sock_error(System.Int32)">
Determins whether the given error code corresponds to to a
WinSock error. If so returns true, false otherwise.
@internal
</member>
        <member name="M:ACE_5_6_0.ACE.sock_error(System.Int32)">
Returns a string containing the error message corresponding to a
WinSock error.  This works around an omission in the Win32 API.
@internal
</member>
        <member name="M:ACE_5_6_0.ACE.map_errno(System.Int32)">
Map troublesome win32 errno values to values that standard C
strerr function understands.  Thank you Microsoft.
</member>
        <member name="M:ACE_5_6_0.ACE.is_prime(System.UInt32!System.Runtime.CompilerServices.IsLong!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsLong!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsLong!System.Runtime.CompilerServices.IsConst)">
Function that can burn up noticeable CPU time:  brute-force
determination of whether number @a n is prime.  Returns 0 if
it is prime, or the smallest factor if it is not prime.
@a min_factor and @a max_factor can be used to partition the work
among threads. For just one thread, typical values are 2 and
n/2.

</member>
        <member name="M:ACE_5_6_0.ACE.minimum_frame_size(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Calculates the minimum enclosing frame size for the given values.
</member>
        <member name="M:ACE_5_6_0.ACE.gcd(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Euclid's greatest common divisor algorithm.
</member>
        <member name="M:ACE_5_6_0.ACE.crc32(iovec!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)">
Computes the ISO 8802-3 standard 32 bits CRC for the
@ len iovec buffers.
</member>
        <member name="M:ACE_5_6_0.ACE.crc32(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32)">
Computes the ISO 8802-3 standard 32 bits CRC for the buffer.
</member>
        <member name="M:ACE_5_6_0.ACE.crc32(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Computes the ISO 8802-3 standard 32 bits CRC for the string.
</member>
        <member name="M:ACE_5_6_0.ACE.crc_ccitt(iovec!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt16)">
Computes CRC-CCITT for the @ len iovec buffers.
</member>
        <member name="M:ACE_5_6_0.ACE.crc_ccitt(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt16)">
Computes CRC-CCITT for the buffer.
</member>
        <member name="M:ACE_5_6_0.ACE.crc_ccitt(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Computes CRC-CCITT for the string.
</member>
        <member name="M:ACE_5_6_0.ACE.hash_pjw(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Computes the hash value of {str} using the "Hash PJW" routine.
</member>
        <member name="M:ACE_5_6_0.ACE.hash_pjw(System.Char!System.Runtime.CompilerServices.IsConst*)">
Computes the hash value of {str} using the "Hash PJW" routine.
</member>
        <member name="M:ACE_5_6_0.ACE.hash_pjw(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Computes the hash value of {str} using the "Hash PJW" routine.
</member>
        <member name="M:ACE_5_6_0.ACE.hash_pjw(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Computes the hash value of {str} using the "Hash PJW" routine.
</member>
        <member name="M:ACE_5_6_0.ACE.format_hexdump(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
Format buffer into printable format.  This is useful for
debugging.
</member>
        <member name="M:ACE_5_6_0.ACE.round_to_allocation_granularity(System.UInt32)">
Rounds the request to a multiple of the allocation granularity.
</member>
        <member name="M:ACE_5_6_0.ACE.round_to_pagesize(System.UInt32)">
Rounds the request to a multiple of the page size.
</member>
        <member name="M:ACE_5_6_0.ACE.daemonize(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Become a daemon process using the algorithm in Richard Stevens
"Advanced Programming in the UNIX Environment."  If
@a close_all_handles is non-zero then all open file handles are
closed.

</member>
        <member name="M:ACE_5_6_0.ACE.fork(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
if @a avoid_zombies == 0 call @c ACE_OS::fork directly, else
create an orphan process that's inherited by the init process;
init cleans up when the orphan process terminates so we don't
create zombies.  Returns -1 on failure and either the child PID
on success if @a avoid_zombies == 0 or 1 on success if @a
avoid_zombies != 0 (this latter behavior is a known bug that
needs to be fixed).

</member>
        <member name="M:ACE_5_6_0.ACE.timestamp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.Int32)">
Returns the current timestamp in the form
"hour:minute:second:microsecond."  The month, day, and year are
also stored in the beginning of the @a date_and_time array, which
is a user-supplied array of size @a time_len&gt; @c ACE_TCHARs.
Returns 0 if unsuccessful, else returns pointer to beginning of the
"time" portion of @a date_and_time.  If @a
return_pointer_to_first_digit is 0 then return a pointer to the
space before the time, else return a pointer to the beginning of
the time portion.

</member>
        <member name="M:ACE_5_6_0.ACE.dirname(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns the "dirname" of a @a pathname.  For instance, the
dirname of "/tmp/foo.cpp" is "/tmp" when @a delim is @a '/'.  If
@a pathname has no @a delim ".\0" is returned.  This method does
not modify @a pathname and is not reentrant.

</member>
        <member name="M:ACE_5_6_0.ACE.basename(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Returns the "basename" of a @a pathname separated by @a delim.
For instance, the basename of "/tmp/foo.cpp" is "foo.cpp" when
@a delim is @a '/'.

</member>
        <member name="M:ACE_5_6_0.ACE.execname(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 On Windows, determines if a specified pathname ends with ".exe"
 (not case sensitive). If on Windows and there is no ".exe" suffix,
 a new ACE_TCHAR array is allocated and a copy of @c pathname with
 the ".exe" suffix is copied into it. In this case, the caller is
 responsible for calling delete [] on the returned pointer.

 @param pathname  The name to check for a proper suffix.

 @retval @c pathname if there is a proper suffix for Windows. This is
         always the return value for non-Windows platforms.
 @retval If a suffix needs to be added, returns a pointer to new[]
         allocated memory containing the original @c pathname plus
         a ".exe" suffix. The caller is responsible for freeing the
         memory using delete [].

</member>
        <member name="M:ACE_5_6_0.ACE.strnnew(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Create a fresh new copy of @a str, up to @a n chars long.  Uses
@c ACE_OS::malloc to allocate the new string.
</member>
        <member name="M:ACE_5_6_0.ACE.strndup(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Create a fresh new copy of @a str, up to @a n chars long.  Uses
@c ACE_OS::malloc to allocate the new string.
</member>
        <member name="M:ACE_5_6_0.ACE.strdelete(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
Delete the memory allocated by @c strnew.
</member>
        <member name="M:ACE_5_6_0.ACE.strnew(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
This method is just like @c strdup, except that it uses
@c operator @c new rather than @c malloc.  If @a s is NULL
returns NULL rather than segfaulting.
</member>
        <member name="M:ACE_5_6_0.ACE.strend(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns a pointer to the "end" of the string, i.e., the character
past the '\0'.
</member>
        <member name="M:ACE_5_6_0.ACE.strenvdup(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Return a dynamically allocated duplicate of @a str, substituting
the environment variable if @c str[0] @c == @c '$'.  Note that
the pointer is allocated with @c ACE_OS::malloc and must be freed
by @c ACE_OS::free.

</member>
        <member name="M:ACE_5_6_0.ACE.max_handles">
Returns the maximum number of open handles currently permitted in
this process.  This maximum may be extended using
@c ACE::set_handle_limit.

</member>
        <member name="M:ACE_5_6_0.ACE.set_handle_limit(System.Int32,System.Int32)">
Reset the limit on the number of open handles.  If @a new_limit
== -1 set the limit to the maximum allowable.  Otherwise, set
the limit value to @a new_limit.  If @a increase_limit_only is
non-0 then only allow increases to the limit.

</member>
        <member name="M:ACE_5_6_0.ACE.handle_timed_complete(System.Void*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Wait up to @a timeout amount of time to complete an actively
established non-blocking connection.  If @a is_tli is non-0 then
we are being called by a TLI wrapper (which behaves slightly
differently from a socket wrapper).

</member>
        <member name="M:ACE_5_6_0.ACE.handle_timed_accept(System.Void*,ACE_5_6_0.ACE_Time_Value*,System.Int32)">
Wait up to @a timeout amount of time to passively establish a
connection.  This method doesn't perform the @c accept, it just
does the timed wait.

</member>
        <member name="M:ACE_5_6_0.ACE.write_n(System.Void*,ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*,System.UInt32*)">
Write all the @a message_blocks chained through their @c next
and @c cont pointers.  This call uses the underlying OS
gather-write operation to reduce the domain-crossing penalty.
</member>
        <member name="M:ACE_5_6_0.ACE.send_n(System.Void*,ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*,System.UInt32*)">
Send all the @a message_blocks chained through their @c next and
@c cont pointers.  This call uses the underlying OS gather-write
operation to reduce the domain-crossing penalty.
</member>
        <member name="M:ACE_5_6_0.ACE.send(System.Void*,System.UInt32,BTEllipsis)">
Varargs variant.
</member>
        <member name="M:ACE_5_6_0.ACE.recv(System.Void*,System.UInt32,BTEllipsis)">
Receive into a variable number of pieces.
 Accepts a variable, caller-specified, number of pointer/length
 pairs. Arguments following @a n are char *, size_t pairs.

 @param handle The I/O handle to receive on
 @param n      The total number of char *, size_t pairs following @a n.

 @return -1 on error, else total number of bytes received.

</member>
        <member name="M:ACE_5_6_0.ACE.recv(System.Void*,System.Void*,System.UInt32,System.Int32,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)">
 @name I/O operations

 Notes on common parameters:

 @a handle is the connected endpoint that will be used for I/O.

 @a buf is the buffer to write from or receive into.

 @a len is the number of bytes to transfer.

 The @a timeout parameter in the following methods indicates how
 long to blocking trying to transfer data.  If @a timeout == 0,
 then the call behaves as a normal send/recv call, i.e., for
 blocking sockets, the call will block until action is possible;
 for non-blocking sockets, @c EWOULDBLOCK will be returned if no
 action is immediately possible.

 If @a timeout != 0, the call will wait until the relative time
 specified in  @a *timeout elapses.

 The "_n()" I/O methods keep looping until all the data has been
 transferred.  These methods also work for sockets in non-blocking
 mode i.e., they keep looping on @c EWOULDBLOCK.  @a timeout is
 used to make sure we keep making progress, i.e., the same timeout
 value is used for every I/O operation in the loop and the timeout
 is not counted down.

 The return values for the "*_n()" methods match the return values
 from the non "_n()" methods and are specified as follows:

 - On complete transfer, the number of bytes transferred is returned.
 - On timeout, -1 is returned, @c errno == @c ETIME.
 - On error, -1 is returned, @c errno is set to appropriate error.
 - On @c EOF, 0 is returned, @c errno is irrelevant.

 On partial transfers, i.e., if any data is transferred before
 timeout / error / @c EOF, @a bytes_transferred&gt; will contain the
 number of bytes transferred.

 Methods with @a iovec parameter are I/O vector variants of the
 I/O operations.

 Methods with the extra @a flags argument will always result in
 @c send getting called. Methods without the extra @a flags
 argument will result in @c send getting called on Win32
 platforms, and @c write getting called on non-Win32 platforms.

</member>
        <member name="M:ACE_5_6_0.ACE.wild_match(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Simple wildcard matching function supporting '*' and '?'
return true if string s matches pattern.
</member>
        <member name="M:ACE_5_6_0.ACE.out_of_handles(System.Int32)">
Check if error indicates the process being out of handles (file
descriptors).
</member>
        <member name="M:ACE_5_6_0.ACE.compiler_beta_version">
E.g., the "0" in SunPro C++ 4.32.0
</member>
        <member name="M:ACE_5_6_0.ACE.compiler_minor_version">
E.g., the "32" in SunPro C++ 4.32.0
</member>
        <member name="M:ACE_5_6_0.ACE.compiler_major_version">
E.g., the "4" in SunPro C++ 4.32.0
</member>
        <member name="M:ACE_5_6_0.ACE.compiler_name">
E.g., the "SunPro C++" in SunPro C++ 4.32.0
</member>
        <member name="M:ACE_5_6_0.ACE.beta_version">
e.g., the "12" in ACE 5.1.12.
Returns 0 for "stable" (non-beta) releases.
</member>
        <member name="M:ACE_5_6_0.ACE.minor_version">
e.g., the "1" in ACE 5.1.12.
</member>
        <member name="M:ACE_5_6_0.ACE.major_version">
e.g., the "5" in ACE 5.1.12.
</member>
        <member name="M:ACE_5_6_0.ACE.ipv6_enabled">
Returns 1 if IPv6 is enabled on the current host; 0 if not.
This is an execution-time check. If ACE has not been compiled
with ACE_HAS_IPV6, it always returns 0. If ACE_HAS_IPV6 is
enabled, this function tries to create a PF_INET6 socket,
returning 1 if it succeeds, and 0 if it fails. Caches the result
so it only gets checked once.

</member>
        <member name="M:ACE_5_6_0.ACE.ipv4_enabled">
Returns @c true if IPv4 is enabled on the current host; @c false
if not.
   * This is an execution-time check. If ACE has not been compiled
   * with @c ACE_HAS_IPV6, it always returns @c true. This function
   * tries to create a @c PF_INET socket, returning @c true if it
   * succeeds, and @c false if it fails. Caches the result so it only
     gets checked once.

</member>
        <member name="M:ACE_5_6_0.ACE.get_handle">
Routine to return a handle from which @c ioctl requests can be
made.  Caller must close the handle.
</member>
        <member name="M:ACE_5_6_0.ACE.count_interfaces(System.Void*,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Helper routine for get_ip_interfaces, differs by UNIX platform so
put into own subroutine.  perform some ioctls to retrieve ifconf
list of ifreq structs.

</member>
        <member name="M:ACE_5_6_0.ACE.get_ip_interfaces(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_INET_Addr**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return count and array of all configured IP interfaces on this
host, rc = 0 on success (count == number of interfaces else -1).
Caller is responsible for calling delete [] on @a addr_array.

</member>
        <member name="M:ACE_5_6_0.ACE.get_fqdn(ACE_5_6_0.ACE_INET_Addr!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
Get fully qualified host/domain name.
</member>
        <member name="M:ACE_5_6_0.ACE.get_bcast_addr(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.Void*)">
Get our broadcast address based on our @a host_addr.  If
@a hostname is non-0 we'll use it to determine our IP address.  If
@a handle is not ACE_INVALID_HANDLE then we'll use this to
determine our broadcast address, otherwise we'll have to create a
socket internally (and free it).  Returns -1 on failure and 0 on
success.

</member>
        <member name="M:ACE_5_6_0.ACE.bind_port(System.Void*,System.UInt32,System.Int32)">
Bind a new unused port to @a handle.
</member>
        <member name="F:msghdr.msg_accrights">
Access rights sent/received
</member>
        <member name="F:msghdr.msg_iovlen">
# elements in msg_iov
</member>
        <member name="F:msghdr.msg_iov">
Scatter/gather array
</member>
        <member name="F:msghdr.msg_namelen">
Size of address
</member>
        <member name="F:msghdr.msg_name">
Optional address
</member>
        <member name="F:iovec.iov_base">
data to be read/written
</member>
        <member name="F:iovec.iov_len">
byte count to read/write
</member>
        <member name="M:ACE_5_6_0.ACE.fini">
Shut down ACE library services.  Can be called only once per
program invocation.
@return Returns 0 on success, -1 on failure, and 1 if it had already been
called.

</member>
        <member name="M:ACE_5_6_0.ACE.init">
This class implements the functions for the initialization and
shutting down ACE.  These functions are called only once per ACE
invokation.
@return Returns 0 on success, -1 on failure, and 1 if it had already been
called.

</member>
        <member name="M:ACE_5_6_0.ACE.strsplit_r(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Char**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
As strsplit_r, but for wide characters.
</member>
        <member name="M:ACE_5_6_0.ACE.strrepl(System.Char*,System.Char,System.Char)">
As strrepl, but for wide characters.
</member>
        <member name="M:ACE_5_6_0.ACE.strrepl(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Replace all instances of @a search in @a s with @a replace.  Returns
the number of replacements made.
</member>
        <member name="M:ACE_5_6_0.ACE.open_temp_file(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Opening the temp file.  File is automagically unlinked when it is
closed.  This is useful for have temp files.
</member>
        <member name="M:ACE_5_6_0.ACE.get_temp_dir(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
Returns the temporary directory including the trailing slash in
@a buffer.  Returns -1 for an error or if the buffer_len is not
long enough.

</member>
        <member name="M:ACE_5_6_0.ACE.ldopen(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Uses @c ldfind to locate and open the appropriate @a filename and
returns a pointer to the file, else it returns a NULL
pointer. @a type specifies how the file should be open.

</member>
        <member name="M:ACE_5_6_0.ACE.ldfind(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
Finds the file @a filename either using an absolute path or using
a relative path in conjunction with ACE_LD_SEARCH_PATH (e.g.,
$LD_LIBRARY_PATH on UNIX or the directories scaned by Win32 API
SearchPath on Win32).  This function will add appropriate suffix
(e.g., .dll on Win32 or .so on UNIX) according to the OS
platform.  In addition, this function will apply the appropriate
prefix (e.g., "lib" on UNIX and "" on Win32) if the @a filename
doesn't match directly.

</member>
        <member name="M:ACE_5_6_0.ACE.handle_timed_open(ACE_5_6_0.ACE_Time_Value*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,_SECURITY_ATTRIBUTES*)">
Wait up to @a timeout&gt; amount of time to actively open a device.
This method doesn't perform the @c connect, it just does the
timed wait.

</member>
        <member name="M:ACE_5_6_0.ACE.get_flags(System.Void*)">
Return the current setting of flags associated with @a handle.
</member>
        <member name="M:ACE_5_6_0.ACE.clr_flags(System.Void*,System.Int32)">
Clear flags associated with @a handle.
</member>
        <member name="M:ACE_5_6_0.ACE.set_flags(System.Void*,System.Int32)">
Set flags associated with @a handle.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.log2(System.Double)">
This method computes the base-2 logarithm of x.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ceil(System.Double)">
This method computes the smallest integral value not less than x.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.floor(System.Double)">
This method computes the largest integral value not greater than x.
</member>
        <member name="F:ACE_5_6_0.ACE_String_Base_Const.npos">
Constant that denotes case where no such character position
exists.
</member>
        <member name="T:ACE_5_6_0.ACE_String_Base_Const">
 @class ACE_String_Base_Const

 @brief This class defines a constant for ACE_String_Base
        which originally was there to circumvent a bug in SunCC 6.0.
        This could be moved to ACE_String_Base but that
        adds a lot of footprint to the user applications which
        is not something we want.

</member>
        <member name="F:ACE_5_6_0.ACE_Allocator.allocator_">
Pointer to a process-wide ACE_Allocator instance.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.dump">
Dump the state of the object.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.protect(System.Void*,System.UInt32,System.Int32)">
Change the protection of the pages of the mapped region to @a prot
starting at @a addr up to @a len bytes.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.sync(System.Void*,System.UInt32,System.Int32)">
Sync @a len bytes of the memory region to the backing store
starting at @a addr.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.sync(System.Int32,System.Int32)">
Sync @a len bytes of the memory region to the backing store
starting at @c this-&gt;base_addr_.  If @a len == -1 then sync the
whole region.

</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.unbind(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Break any association of name.  Returns the value of pointer in
case the caller needs to deallocate memory.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.unbind(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Unbind (remove) the name from the map.  Don't return the pointer
to the caller
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns 0 if the name is in the mapping. -1, otherwise.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Locate @a name and pass out parameter via pointer.  If found,
return 0, returns -1 if failure occurs.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.trybind(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Associate @a name with @a pointer.  Does not allow duplicate
@a name/@a pointer associations.  Returns 0 if successfully binds
(1) a previously unbound @a name, 1 if trying to bind a previously
bound @a name, or returns -1 if a resource failure occurs.  When
this call returns @a pointer's value will always reference the
void * that @a name is associated with.  Thus, if the caller needs
to use @a pointer (e.g., to free it) a copy must be maintained by
the caller.

</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.bind(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Int32)">
Associate @a name with @a pointer.  If @a duplicates == 0 then do
not allow duplicate @a name/@a pointer associations, else if
@a duplicates != 0 then allow duplicate @a name/@a pointer
assocations.  Returns 0 if successfully binds (1) a previously
unbound @a name or (2) @a duplicates != 0, returns 1 if trying to
bind a previously bound @a name and @a duplicates == 0, else
returns -1 if a resource failure occurs.

</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.remove">
Remove any resources associated with this memory manager.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.calloc(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Allocate @a nbytes, giving them @a initial_value.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.malloc(System.UInt32)">
Allocate @a nbytes, but don't give them any initial value.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.Dispose">
Virtual destructor
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.#ctor">
"No-op" constructor (needed to make certain compilers happy).
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.close_singleton">
Delete the dynamically allocated Singleton
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.instance(ACE_5_6_0.ACE_Allocator*)">
Set pointer to a process-wide ACE_Allocator and return existing
pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_Allocator.instance">
Get pointer to a default ACE_Allocator.
</member>
        <member name="D:ACE_5_6_0.ACE_Allocator.size_type">
Unsigned integer type used for specifying memory block lengths.
</member>
        <member name="T:ACE_5_6_0.ACE_Allocator">
 @class ACE_Allocator

 @brief Interface for a dynamic memory allocator that uses inheritance
 and dynamic binding to provide extensible mechanisms for
 allocating and deallocating memory.

</member>
        <member name="F:ACE_5_6_0.ACE_DLL.error_">
Flag to record if the last operation had an error.
</member>
        <member name="F:ACE_5_6_0.ACE_DLL.close_handle_on_destruction_">
This flag keeps track of whether we should close the handle
automatically when the object is destroyed.
</member>
        <member name="F:ACE_5_6_0.ACE_DLL.dll_name_">
Keep track of the name of the loaded dll, so it can be used
to remove framework components, singletons that live in the dll,
prior to unloading the dll in the close() method.
</member>
        <member name="F:ACE_5_6_0.ACE_DLL.open_mode_">
Open mode.
</member>
        <member name="M:ACE_5_6_0.ACE_DLL.set_handle(HINSTANCE__*,System.Int32)">
Set the handle for the DLL object. By default, the close()
</member>
        <member name="M:ACE_5_6_0.ACE_DLL.error">
Returns a pointer to a string explaining that an error occured.  You
will need to consult the error log for the actual error string
returned by the OS.
</member>
        <member name="M:ACE_5_6_0.ACE_DLL.symbol(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Look up a named symbol in the DLL. DLL must be successfully opened
before calling symbol().
@param symbol_name The symbol name to look up.
@param ignore_errors If set to 1, allows you to probe a dll without
       generating error messages in the log.  Handy for determining
       the capabilities of a library.
@return Returns the value of @a symbol_name if it is a valid symbol
       in the DLL. Otherwise, returns 0.

</member>
        <member name="M:ACE_5_6_0.ACE_DLL.Dispose">
Called when the DLL object is destroyed -- invokes close() if the
@a close_handle_on_destruction flag was set to non-zero in the
constructor or open() method.

</member>
        <member name="M:ACE_5_6_0.ACE_DLL.close">
Call to close the DLL object.
</member>
        <member name="M:ACE_5_6_0.ACE_DLL.open(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
This method opens and dynamically links a specified DLL.
@param dll_name  The filename or path of the DLL to load.
       If a filename is given to @c open(), the @c ACE::ldfind() is used
       to locate DLLs via the following algorithms: (1) DLL filename
       expansion: @c ACE::ldfind() determines the name of the DLL by
       adding the appropriate prefix and suffix, e.g., it adds the @c lib
       prefix and @c .so suffix for Solaris and the @c .dll suffix for
       Windows and (2) DLL search path: @c ACE::ldfind() will also search
       for the designated DLL using the platform's DLL search path
       environment variable, e.g., it searches for DLLs using @c
       LD_LIBRARY_PATH on many UNIX systems and @c PATH on Windows.
@param open_mode  Flags to alter the actions taken when loading the DLL.
       The possible values are:
       @li @c RTLD_LAZY (this the default): loads identifier symbols but
           not the symbols for functions, which are loaded dynamically
           on-demand.
       @li @c RTLD_NOW: performs all necessary relocations when
           @a dll_name is first loaded
       @li RTLD_GLOBAL: makes symbols available for relocation
           processing of any other DLLs.
@param close_handle_on_destruction  Indicates whether or not the
       close() method will be called to close an open DLL when this
       object is destroyed. By default, close() will be called.
       Set this parameter to 0 for situations where the DLL's lifetime
       is controlled in a scope other than that of this ACE_DLL object.
       For example, termination by ACE_DLL_Manager via ACE::fini().
@retval -1 On failure
@retval 0 On success.

</member>
        <member name="M:ACE_5_6_0.ACE_DLL.#ctor(ACE_5_6_0.ACE_DLL!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_DLL.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
This constructor performs the actions of open() during construction.
@param dll_name  The name or path of the DLL to load.
@param open_mode  Flags to alter the actions taken when loading the DLL.
       The possible values are:
       @li @c RTLD_LAZY (this the default): loads identifier symbols but
           not the symbols for functions, which are loaded dynamically
           on-demand.
       @li @c RTLD_NOW: performs all necessary relocations when
           @a dll_name is first loaded
       @li RTLD_GLOBAL: makes symbols available for relocation
           processing of any other DLLs.
@param close_handle_on_destruction  Indicates whether or not the
       close() method will be called to close an open DLL when this
       object is destroyed. By default, close() will be called.
       Set this parameter to 0 for situations where the DLL's lifetime
       is controlled in a scope other than that of this ACE_DLL object.
       For example, termination by ACE_DLL_Manager via ACE::fini().

</member>
        <member name="M:ACE_5_6_0.ACE_DLL.op_Assign(ACE_5_6_0.ACE_DLL!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Allow assignment
</member>
        <member name="M:ACE_5_6_0.ACE_DLL.#ctor(System.Int32)">
Default constructor.  By default, the close() operation on the
object will be invoked before it is destroyed.
@param close_handle_on_destruction  Indicates whether or not the
       close() method will be called to close an open DLL when this
       object is destroyed. By default, close() will be called.
       Set this parameter to 0 for situations where the DLL's lifetime
       is controlled in a scope other than that of this ACE_DLL object.
       For example, termination by ACE_DLL_Manager via ACE::fini().

</member>
        <member name="T:ACE_5_6_0.ACE_DLL">
 @class ACE_DLL

 @brief Provides an abstract interface for handling various DLL
 operations.

 This class is a wrapper over the various methods for utilizing
 a dynamically linked library (DLL), which is called a shared
 library on some platforms.  Operations @c open(), @c close(), and
 @c symbol() have been implemented to help opening/closing and
 extracting symbol information from a DLL, respectively.

</member>
        <member name="M:ACE_5_6_0.ACE_Shared_Object.info(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.UInt32)">
Returns information on a service object.
</member>
        <member name="M:ACE_5_6_0.ACE_Shared_Object.fini">
Terminates object when dynamic unlinking occurs.
</member>
        <member name="M:ACE_5_6_0.ACE_Shared_Object.init(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)">
Initializes object when dynamic linking occurs.
</member>
        <member name="T:ACE_5_6_0.ACE_Shared_Object">
 @class ACE_Shared_Object

 @brief Provide the abstract base class used to access dynamic
 linking facilities.

</member>
        <member name="F:ACE_5_6_0.ACE_Notification_Buffer.mask_">
Mask that indicates which method to call.
</member>
        <member name="F:ACE_5_6_0.ACE_Notification_Buffer.eh_">
Pointer to the Event_Handler that will be dispatched
by the main event loop.
</member>
        <member name="M:ACE_5_6_0.ACE_Notification_Buffer.Dispose">
Default dtor.
</member>
        <member name="F:ACE_5_6_0.ACE_Event_Handler_var.ptr_">
Handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.reset(ACE_5_6_0.ACE_Event_Handler*)">
Reset the handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.release">
Release the handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.handler">
Access the handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.op_MemberSelection">
Overloaded "-&gt;".
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.op_Assign(ACE_5_6_0.ACE_Event_Handler_var!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment to a ACE_Event_Handler_var.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.op_Assign(ACE_5_6_0.ACE_Event_Handler*)">
Assignment to a handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.#ctor(ACE_5_6_0.ACE_Event_Handler_var!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.#ctor(ACE_5_6_0.ACE_Event_Handler*)">
Construct with a handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler_var.#ctor">
Default constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Event_Handler_var">
 @class ACE_Event_Handler_var

 @brief Auto pointer like class for Event Handlers.

 Used to manage lifecycle of handlers. This class calls
 ACE_Event_Handler::remove_reference() in its destructor.

</member>
        <member name="F:ACE_5_6_0.ACE_Event_Handler.reference_counting_policy_">
Reference counting requirements.
</member>
        <member name="F:ACE_5_6_0.ACE_Event_Handler.reactor_">
Pointer to the various event demultiplexors.
</member>
        <member name="F:ACE_5_6_0.ACE_Event_Handler.priority_">
Priority of this Event_Handler.
</member>
        <member name="F:ACE_5_6_0.ACE_Event_Handler.reference_count_">
Reference count.
</member>
        <member name="D:ACE_5_6_0.ACE_Event_Handler.Atomic_Reference_Count">
Typedef for implementation of reference counting.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.#ctor(ACE_5_6_0.ACE_Reactor*,System.Int32)">
Force ACE_Event_Handler to be an abstract base class.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.reference_counting_policy">
Current Reference_Counting_Policy.
</member>
        <member name="F:ACE_5_6_0.ACE_Event_Handler.Reference_Counting_Policy.value_">
The value of the policy.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.Reference_Counting_Policy.#ctor(ACE_5_6_0.ACE_Event_Handler.Reference_Counting_Policy.Value)">
Private constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.Reference_Counting_Policy.value(ACE_5_6_0.ACE_Event_Handler.Reference_Counting_Policy.Value)">
Update Reference_Counting_Policy.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.Reference_Counting_Policy.value">
Current Reference_Counting_Policy.
</member>
        <member name="F:DISABLED">
Don't perform reference counting.
</member>
        <member name="F:ENABLED">
Perform reference counting.
</member>
        <member name="T:ACE_5_6_0.ACE_Event_Handler.Reference_Counting_Policy">
 @class Reference_Counting_Policy

 @brief This policy dictates the reference counting requirements
 for the handler.

 This policy allows applications to configure whether it wants the
 Reactor to call add_reference() and remove_reference() during
 registrations, removals, and upcalls.

 <B>Default:</B> DISABLED.

</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.Policy.Dispose">
Virtual destructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Event_Handler.Policy">
 @class Policy

 @brief Base class for all handler policies.

</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.remove_reference">
Decrement reference count on the handler.
 This method is called when the handler is removed from the
 Reactor and when an upcall made on the handler by the Reactor
 completes.  Handler is deleted when the reference count reaches
 0.

 @return Current reference count.

</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.add_reference">
Increment reference count on the handler.
 This method is called when the handler is registered with the
 Reactor and when the Reactor makes an upcall on the handler.
 Reference count is 1 when the handler is created.

 @return Current reference count.

</member>
        <member name="D:ACE_5_6_0.ACE_Event_Handler.Reference_Count">
Reference count type.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.reactor_timer_interface">
Get only the reactor's timer related interface.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.reactor">
Get the event demultiplexors.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.reactor(ACE_5_6_0.ACE_Reactor*)">
Set the event demultiplexors.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.resume_handler">
 Called to figure out whether the handler needs to resumed by the
 reactor or the application can take care of it. The default
 value of 0 would be returned which would allow the reactor to
 take care of resumption of the handler. The application can
 return a value more than zero and decide to resume the handler
 themseleves.

 @note This method is only useful for the ACE_TP_Reactor. Sad
 that we have to have this method in a class that is supposed to
 be used across different components in ACE.

</member>
        <member name="F:ACE_APPLICATION_RESUMES_HANDLER">
The application takes responsibility of resuming the handler
</member>
        <member name="F:ACE_REACTOR_RESUMES_HANDLER">
The reactor takes responsibility of resuming the handler and
is the default
</member>
        <member name="F:ACE_EVENT_HANDLER_NOT_RESUMED">
The handler is not resumed at all. Could lead to deadlock..
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.handle_signal(System.Int32,siginfo_t*,System.Int32*)">
Called when object is signaled by OS (either via UNIX signals or
when a Win32 object becomes signaled).
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.handle_exit(ACE_5_6_0.ACE_Process*)">
Called when a process exits.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.handle_exception(System.Void*)">
Called when an exceptional events occur (e.g., SIGURG).
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.handle_output(System.Void*)">
Called when output events are possible (e.g., when flow control
abates or non-blocking connection completes).
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.handle_input(System.Void*)">
Called when input events occur (e.g., connection or data).
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.priority(System.Int32)">
Set the priority of the Event_Handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.priority">
Get the priority of the Event_Handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.set_handle(System.Void*)">
Set the I/O handle.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.get_handle">
Get the I/O handle.
</member>
        <member name="M:ACE_5_6_0.ACE_Event_Handler.Dispose">
Destructor is virtual to enable proper cleanup.
</member>
        <member name="T:ACE_5_6_0.ACE_Event_Handler">
 @class ACE_Event_Handler

 @brief Provides an abstract interface for handling various types of
 I/O, timer, and signal events.

 Subclasses read/write input/output on an I/O descriptor,
 handle an exception raised on an I/O descriptor, handle a
 timer's expiration, or handle a signal.


This policy can only be created by the handler.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.thr_desc_hook">
Return the TSS singleton thread descriptor
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.sync_hook(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Decouple the OS layer from the ACE_Log_Msg layer.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.close">
For cleanup, at program termination.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.default_priority_mask_">
Priority mask to use for each new instance

</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.instance_count_">
Number of existing ACE_Log_Msg instances; when 0, delete program/host
names

</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.msg_off_">
Offset of msg_[].
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.flags_">
Options flags used to hold the logger flag options, e.g.,
STDERR, LOGGER, OSTREAM, MSG_CALLBACK, etc.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.pid_">
Process id of the current process.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.local_host_">
Name of the local host (used when printing messages).
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.program_name_">
Records the program name.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.process_priority_mask_">
Keeps track of all the per-process ACE_Log_Priority values that
are currently enabled.  Default is for all logging priorities to
be enabled.

</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.timestamp_">
Always timestamp?
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.priority_mask_">
Keeps track of all the per-thread ACE_Log_Priority values that
are currently enabled.  Default is for all logging priorities to
be disabled.

</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.thr_desc_">
If we're running in the context of an ACE_Thread_Manager this
will point to the thread descriptor adapter which holds the
thread descriptor of the thread.  This can be used to repidly
access all thread data kept in ACE_Thread_Descriptor.

</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.delete_ostream_">
Are we deleting this ostream?
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.tracing_enabled_">
Are we allowing tracing in this thread?
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.trace_active_">
Are we already within an ACE_Trace constructor call?
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.trace_depth_">
Depth of the nesting for printing traces.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.msg_callback_">
The callback object.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.ostream_">
The ostream where logging messages can be written.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.restart_">
Indicates whether we should restart system calls that are
interrupted.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.msg_">
The log message, which resides in thread-specific storage.  Note
that only the current log message is stored here -- it will be
overwritten by the subsequent call to log().
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.file_">
File where the error occurred.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.linenum_">
Line number where the error occurred.
</member>
        <member name="F:ACE_5_6_0.ACE_Log_Msg.status_">
Status of operation (-1 means failure, &gt;= 0 means success).
</member>
        <member name="T:ACE_5_6_0.ACE_Log_Msg.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.inherit_hook(ACE_5_6_0.ACE_OS_Thread_Descriptor*,ACE_5_6_0.ACE_OS_Log_Msg_Attributes*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inherit hook, the @a attributes field is a ACE_OS_Log_Msg_Attributes
object, invoke the inherit_log_msg() method on it, then destroy
it and set the @a attribute argument to 0.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.init_hook(ACE_5_6_0.ACE_OS_Log_Msg_Attributes*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,=FUNC:System.Int32(System.Void*),=FUNC:System.Int32(System.Void*))">
Init hook, create a Log_Msg_Attribute object, initialize its
attributes from the TSS Log_Msg and save the object in the
@a attributes argument

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.log_hexdump(ACE_5_6_0.ACE_Log_Priority,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Method to log hex dump.  This is useful for debugging.  Calls
log() to do the actual print, but formats first to make the chars
printable.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.log(ACE_5_6_0.ACE_Log_Record*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Log a custom built log record to the currently enabled logging
sinks.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.log(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Log_Priority,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
An alternative logging mechanism that makes it possible to
integrate variable argument lists from other logging mechanisms
into the ACE mechanism.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.conditional_set(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32)">
These values are only actually set if the requested priority is
enabled.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.set(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32,System.Int32,_iobuf*,ACE_5_6_0.ACE_Log_Msg_Callback*)">
Set the line number, file name, operational status, error number,
restart flag, ostream, and the callback object.  This combines
all the other set methods into a single method.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.local_host(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Set the name of the local host.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.local_host">
Get the name of the local host.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.getpid">
Optimize reading of the pid (avoids a system call if the value is
cached...).
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.log_priority_enabled(ACE_5_6_0.ACE_Log_Priority,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
Return true if the requested priority is enabled.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.log_priority_enabled(ACE_5_6_0.ACE_Log_Priority)">
Return true if the requested priority is enabled.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.priority_mask(System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Log_Msg.MASK_TYPE)">
Set the ACE_Log_Priority mask, returns original mask.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.priority_mask(ACE_5_6_0.ACE_Log_Msg.MASK_TYPE)">
Get the current ACE_Log_Priority mask.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.tracing_enabled">
Query tracing status on a per-thread basis...
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.start_tracing">
Start tracing status on a per-thread basis...
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.stop_tracing">
Stop tracing status on a per-thread basis...
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.thr_desc(ACE_5_6_0.ACE_Thread_Descriptor*)">
Set the TSS thread descriptor.  This method will call
td-&gt;acquire_release to block execution until this call
return.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.thr_desc">
Get the TSS thread descriptor.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.trace_active(System.Int32)">
Get trace active status.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.trace_active">
Set trace active status.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.trace_depth(System.Int32)">
Set trace depth.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.trace_depth">
Get trace depth.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.dec">
Nesting depth decrement.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.inc">
Nesting depth increment.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.msg_backend(ACE_5_6_0.ACE_Log_Msg_Backend*)">
 Set a new backend object and return the existing backend to
 allow "chaining". Note that as opposed to ACE_Log_Msg_Callback,
 ACE_Log_Msg_Backend is a per-process entity.

 @note Be aware that because of the current architecture there is
 no guarantee that open (), reset () and close () will be called
 on a backend object.


</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.msg_callback(ACE_5_6_0.ACE_Log_Msg_Callback*)">
Set a new callback object and return the existing callback to
allow "chaining".  Note that ACE_Log_Msg_Callback objects are not
inherited when spawning a new thread, so you'll need to reset
them in each thread.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.msg_ostream">
Get the ostream that is used to print error messages.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.msg_ostream(_iobuf*,System.Int32)">
delete_stream == 1, forces Log_Msg.h to delete the stream in
its own ~dtor (assumes control of the stream)
use only with proper ostream (eg: fstream), not (cout, cerr)

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.msg_ostream(_iobuf*)">
Update the ostream without overwriting the delete_ostream_ flag.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.restart">
Get the field that indicates whether interrupted calls should be
restarted.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.restart(System.Int32)">
Set the field that indicates whether interrupted calls should be
restarted.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.msg">
Get the message that describes what type of error occurred.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.msg(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Set the message that describes what type of error occurred.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.file">
Get the file name where an error occurred.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.file(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Set the file name where an error occurred.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.linenum">
Get the line number where an error occurred.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.linenum(System.Int32)">
Set the line number where an error occurred.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.errnum">
Get the value of the errnum (by convention this corresponds to
errno).
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.errnum(System.Int32)">
Set the value of the errnum (by convention this corresponds to
errno).
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.op_status">
Get the result of the operation status (by convention, -1 means
error).
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.op_status(System.Int32)">
Set the result of the operation status (by convention, -1 means
error).
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.sync(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Call after doing a @c fork() to resynchronize the process id and
@c program_name_ variables.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.release">
Release the internal lock.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.acquire">
@name Allow apps to acquire and release internal synchronization
   *        lock
   *
   * This lock is used internally by the ACE_Log_Msg
   * implementation. By exporting the lock, applications can hold the
   * lock atomically over a number of calls to ACE_Log_Msg.

Acquire the internal lock.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.flags">
Return the bits in the logger's options flags.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.clr_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Disable the bits in the logger's options flags.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.set_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Enable the bits in the logger's options flags.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.open(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Initialize the ACE logging facility.
 Initialize the ACE logging facility. Supplies the program name
 that is available to each logging message call. Default arguments
 set up logging to STDERR only.

 @param prog_name      The name of the calling program.
 @param options_flags  A bitwise-or of options flags used to set the
                       initial behavior and logging sink(s). (see the
                       enum above for the valid values).
 @param logger_key     The name of ACE_FIFO rendezvous point where the
                       local client logger daemon is listening for logging
                       messages if the LOGGER bit is set in the @a flags
                       argument. If the SYSLOG bit is set in @a flags,
                       @a logger_key is the source/program name specified
                       in the syslog facility (UNIX/Linux) or the Windows
                       event log (Windows). In the SYSLOG case, if
                       @a logger_key is 0, @a prog_name is used.

</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.Dispose">
cleanup logger.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.#ctor">
Initialize logger.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.enable_debug_messages(ACE_5_6_0.ACE_Log_Priority)">
Sets the flag in the default priority mask used to initialize
ACE_Log_Msg instances.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.disable_debug_messages(ACE_5_6_0.ACE_Log_Priority)">
Clears the flag from the default priority mask used to
initialize ACE_Log_Msg instances.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.program_name">
Returns the current program name used for logging.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.exists">
Returns non-null if an ACE_Log_Msg exists for the calling thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.last_error_adapter">
Returns last error.
</member>
        <member name="M:ACE_5_6_0.ACE_Log_Msg.instance">
Returns a pointer to the Singleton.
</member>
        <member name="F:CUSTOM">
Write messages to the user provided backend
</member>
        <member name="F:SYSLOG">
Write messages to the system's event log.
</member>
        <member name="F:SILENT">
Do not print messages at all (just leave in thread-specific
storage for later inspection).
</member>
        <member name="F:VERBOSE_LITE">
Display messages in a less verbose manner (i.e., only print
information that can change between calls).
</member>
        <member name="F:VERBOSE">
Display messages in a verbose manner.
</member>
        <member name="F:MSG_CALLBACK">
Write messages to the callback object.
</member>
        <member name="F:OSTREAM">
Write messages to the ostream * stored in thread-specific
storage.
</member>
        <member name="F:LOGGER">
Write messages to the local client logger deamon.
</member>
        <member name="F:STDERR">
Write messages to stderr.
</member>
        <member name="T:ACE_5_6_0.ACE_Log_Priority">
 @enum ACE_Log_Priority

 @brief This data type indicates the relative priorities of the
    logging messages, from lowest to highest priority.

 These values are defined using powers of two so that it's
 possible to form a mask to turn them on or off dynamically.
 We only use 12 bits, however, so users are free to use the
 remaining 19 bits to define their own priority masks.

</member>
        <member name="F:LM_ENSURE_32_BITS">
Do not use!!  This enum value ensures that the underlying
integral type for this enum is at least 32 bits.
</member>
        <member name="F:LM_MAX">
The maximum logging priority.
</member>
        <member name="F:LM_EMERGENCY">
A panic condition.  This is normally broadcast to all users
(decimal 1024).
</member>
        <member name="F:LM_ALERT">
A condition that should be corrected immediately, such as a
corrupted system database (decimal 512).
</member>
        <member name="F:LM_CRITICAL">
Critical conditions, such as hard device errors (decimal 256).
</member>
        <member name="F:LM_ERROR">
Error messages (decimal 128).
</member>
        <member name="F:LM_STARTUP">
Initialize the logger (decimal 64).
</member>
        <member name="F:LM_WARNING">
Warning messages (decimal 32).
</member>
        <member name="F:LM_NOTICE">
Conditions that are not error conditions, but that may require
special handling (decimal 16).
</member>
        <member name="F:LM_INFO">
Informational messages (decimal 8).
</member>
        <member name="F:LM_DEBUG">
Messages that contain information normally of use only when
debugging a program (decimal 4).
</member>
        <member name="F:LM_TRACE">
Messages indicating function-calling sequence (decimal 2).
</member>
        <member name="F:LM_SHUTDOWN">
Shutdown the logger (decimal 1).
</member>
        <member name="T:ACE_5_6_0.ACE_RW_Thread_Mutex.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Thread_Mutex.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Thread_Mutex.tryacquire_write_upgrade">
Conditionally upgrade a read lock to a write lock.  This only
works if there are no other readers present, in which case the
method returns 0.  Otherwise, the method returns -1 and sets
@c errno to @c EBUSY.  Note that the caller of this method *must*
already possess this lock as a read lock (but this condition is
not checked by the current implementation).

</member>
        <member name="M:ACE_5_6_0.ACE_RW_Thread_Mutex.Dispose">
Default dtor.
</member>
        <member name="T:ACE_5_6_0.ACE_RW_Thread_Mutex">
 @class ACE_RW_Thread_Mutex

 @brief Wrapper for readers/writer locks that exist within a process.

</member>
        <member name="F:ACE_5_6_0.ACE_RW_Mutex.lock_">
Readers/writer lock.
</member>
        <member name="T:ACE_5_6_0.ACE_RW_Mutex.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.lock">
Return the underlying lock.
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.release">
Unlock a readers/writer lock.
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.tryacquire_write_upgrade">
Conditionally upgrade a read lock to a write lock.  This only
works if there are no other readers present, in which case the
method returns 0.  Otherwise, the method returns -1 and sets
@c errno to @c EBUSY.  Note that the caller of this method *must*
already possess this lock as a read lock (but this condition is
not checked by the current implementation).

</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.tryacquire_write">
Conditionally acquire a write lock (i.e., won't block).
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.tryacquire_read">
Conditionally acquire a read lock (i.e., won't block).  Returns
-1 on failure.  If we "failed" because someone else already had
the lock, @c errno is set to @c EBUSY.

</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.acquire_write">
Acquire a write lock, but block if any readers or a
writer hold the lock.
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.acquire_read">
Acquire a read lock, but block if a writer hold the lock.
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.remove">
Explicitly destroy a readers/writer lock.  Note that only one
thread should call this method since it doesn't protect against
race conditions.

</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.Dispose">
Implicitly destroy a readers/writer lock
</member>
        <member name="M:ACE_5_6_0.ACE_RW_Mutex.#ctor(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*)">
Initialize a readers/writer lock.
</member>
        <member name="T:ACE_5_6_0.ACE_RW_Mutex">
 @class ACE_RW_Mutex

 @brief Wrapper for readers/writer locks.

 These are most useful for applications that have many more
 parallel readers than writers...

</member>
        <member name="F:ACE_5_6_0.ACE_Thread_Mutex.lock_">
Mutex type that supports single-process locking efficiently.
</member>
        <member name="T:ACE_5_6_0.ACE_Thread_Mutex.__Ace">
Declare the dynamic allocation hooks.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.dump">
Dump the state of an object.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.lock">
Return the underlying mutex.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.tryacquire_write_upgrade">
This is only here to make the ACE_Thread_Mutex
interface consistent with the other synchronization APIs.
Assumes the caller has already acquired the mutex using one of
the above calls, and returns 0 (success) always.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.release">
Release lock and unblock a thread at head of queue.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.tryacquire">
Conditionally acquire lock (i.e., don't wait on queue).  Returns
-1 on failure.  If we "failed" because someone else already had
the lock, @c errno is set to @c EBUSY.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Block the thread until we acquire the mutex or until @a tv times
out, in which case -1 is returned with @c errno == @c ETIME.  Note
that @a tv is assumed to be in "absolute" rather than "relative"
time.  The value of @a tv is updated upon return to show the
actual (absolute) acquisition time.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.acquire">
Acquire lock ownership (wait on queue if necessary).
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.remove">
Explicitly destroy the mutex.  Note that only one thread should
call this method since it doesn't protect against race
conditions.

</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.Dispose">
Implicitly destroy the mutex.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_Mutex.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_mutexattr_t*)">
Constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.set_win32_resource_module(HINSTANCE__*)">
Allow an application to modify which module contains ACE's
resources. This is mainly useful for a static build of ACE where
the required resources reside somewhere other than the executable.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.get_win32_resource_module">
Return the handle of the module containing ACE's resources. By
default, for a DLL build of ACE this is a handle to the ACE DLL
itself, and for a static build it is a handle to the executable.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.get_win32_versioninfo">
Return the win32 OSVERSIONINFO structure.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.default_win32_security_attributes(_SECURITY_ATTRIBUTES*)">
Default Win32 Security Attributes definition.
</member>
        <member name="F:ACE_5_6_0.ACE_OS.ace_flock_t.handle_">
Handle to the underlying file.
</member>
        <member name="F:ACE_5_6_0.ACE_OS.ace_flock_t.lockname_">
Name of this filelock.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.ace_flock_t.dump">
Dump state of the object.
</member>
        <member name="T:ACE_5_6_0.ACE_OS.ace_flock_t">
 @class ace_flock_t

 @brief OS file locking structure.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.num_processors_online">
Get the number of CPUs currently online.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.num_processors">
Get the number of CPUs configured in the machine.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.fork">
Forks and exec's a process in a manner that works on Solaris and
NT.  argv[0] must be the full path name to the executable.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.open(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,_SECURITY_ATTRIBUTES*)">
The O_APPEND flag is only partly supported on Win32. If you specify
O_APPEND, then the file pointer will be positioned at the end of
the file initially during open, but it is not re-positioned at
the end prior to each write, as specified by POSIX.  This
is generally good enough for typical situations, but it is ``not
quite right'' in its semantics.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Recursive_Thread_Mutex_Guard.owner_">
Keeps track of whether we acquired the lock or failed.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Recursive_Thread_Mutex_Guard.lock_">
Reference to the mutex.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Recursive_Thread_Mutex_Guard.release">
Explicitly release the lock.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Recursive_Thread_Mutex_Guard.acquire">
Explicitly acquire the lock.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Recursive_Thread_Mutex_Guard.Dispose">
Implicitly release the lock.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Recursive_Thread_Mutex_Guard.#ctor(_RTL_CRITICAL_SECTION*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implicitly and automatically acquire the lock.
</member>
        <member name="T:ACE_5_6_0.ACE_OS_Recursive_Thread_Mutex_Guard">
 @class ACE_OS_Recursive_Thread_Mutex_Guard

 @brief For internal use only by ACE_OS.

 This data structure is meant to be used within an ACE_OS
 function.  It performs automatic aquisition and release of
 an ACE_recursive_thread_mutex_t.

 If an object of this class is instantiated before ACE_Object_Manager is
 initialized, it will not do anything. This is because this class is
 used only with the ACE_TSS_GUARD macro which is passing a reference to
 one of the preallocated Object Manager locks. If the object manager
 hasn't been initialized yet, the lock reference is bogus. This is an
 acceptable tradeoff since in cases where the lock reference is bogus,
 there isn't multithreaded access. Please see detailed comments in
 Object_Manager.h for further information.

</member>
        <member name="F:ACE_5_6_0.ACE_OS_Thread_Mutex_Guard.owner_">
Keeps track of whether we acquired the lock or failed.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Thread_Mutex_Guard.lock_">
Reference to the mutex.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Thread_Mutex_Guard.release">
Explicitly release the lock.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Thread_Mutex_Guard.acquire">
Explicitly acquire the lock.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Thread_Mutex_Guard.Dispose">
Implicitly release the lock.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Thread_Mutex_Guard.#ctor(_RTL_CRITICAL_SECTION*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Implicitly and automatically acquire the lock.
</member>
        <member name="T:ACE_5_6_0.ACE_OS_Thread_Mutex_Guard">
 @class ACE_OS_Thread_Mutex_Guard

 This data structure is meant to be used within an ACE_OS
 function.  It performs automatic aquisition and release of
 an ACE_thread_mutex_t.

 If an object of this class is instantiated before ACE_Object_Manager is
 initialized, it will not do anything. This is because this class is
 used only with the ACE_OS_GUARD macro which is passing a reference to
 one of the preallocated Object Manager locks. If the object manager
 hasn't been initialized yet, the lock reference is bogus. This is an
 acceptable tradeoff since in cases where the lock reference is bogus,
 there isn't multithreaded access. Please see detailed comments in
 Object_Manager.h for further information.

 For internal use only by ACE_OS.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.thr_setspecific_native(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*)">
@internal Applications should call thr_setspecific
</member>
        <member name="M:ACE_5_6_0.ACE_OS.thr_keyfree_native(System.UInt32!System.Runtime.CompilerServices.IsLong)">
@internal  applications should call thr_keyfree instead
</member>
        <member name="M:ACE_5_6_0.ACE_OS.thr_keycreate(System.UInt32!System.Runtime.CompilerServices.IsLong*,=FUNC:System.Void(System.Void*),System.Void*)">
@note the "inst" arge is deprecated.  It will be ignored.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.thr_keycreate_native(System.UInt32!System.Runtime.CompilerServices.IsLong*,=FUNC:System.Void(System.Void*))">
@internal Applications should call thr_keycreate instead
</member>
        <member name="M:ACE_5_6_0.ACE_OS.thr_key_detach(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*)">
@note the "inst" arg is deprecated.  It will be ignored.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.thr_set_affinity(System.Void*,System.UInt32,cpu_set_t!System.Runtime.CompilerServices.IsConst*)">
 Set the thread affinity

 @param thr_id For NPTL-threads, when ACE_HAS_PTHREAD_SETAFFINITY_NP
 defined, this is the thread-id. For linux-threads, when
 ACE_HAS_SCHED_SETAFFINITY defined, it expects a process-id. Since for
 linux-threads a thread is seen as a process, it does the job.
 @param cpu_set_size The size of the cpu_mask
 @param cpu_mask Is a bitmask of CPUs to bind to, e.g value 1 binds the
 thread to the "CPU 0", etc

</member>
        <member name="M:ACE_5_6_0.ACE_OS.thr_get_affinity(System.Void*,System.UInt32,cpu_set_t*)">
 Get the thread affinity

 @param thr_id For NPTL-threads, when ACE_HAS_PTHREAD_SETAFFINITY_NP
 defined, this is the thread-id. For linux-threads, when
 ACE_HAS_SCHED_SETAFFINITY defined, it expects a process-id. Since for
 linux-threads a thread is seen as a process, it does the job.
 @param cpu_set_size The size of the cpu_mask
 @param cpu_mask Is a bitmask of CPUs to bind to, e.g value 1 binds the
 thread to the "CPU 0", etc

</member>
        <member name="M:ACE_5_6_0.ACE_OS.thr_getspecific_native(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void**)">
for internal use only.  Applications should call thr_getspecific
</member>
        <member name="M:ACE_5_6_0.ACE_OS.scheduling_class(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsLong*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Find the schedling class ID that corresponds to the class name.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.sched_params(ACE_5_6_0.ACE_Sched_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set scheduling parameters.  An id of ACE_SELF indicates, e.g.,
set the parameters on the calling thread.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.mutex_trylock(ACE_5_6_0.ACE_mutex_t*)">
Win32 note: Abandoned mutexes are not treated differently. 0 is
returned since the calling thread does get the ownership.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.mutex_lock_cleanup(System.Void*)">
Handle asynchronous thread cancellation cleanup.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.mutex_lock(ACE_5_6_0.ACE_mutex_t*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method attempts to acquire a lock, but gives up if the lock
has not been acquired by the given time.  If the lock is not
acquired within the given amount of time, then this method
returns -1 with an @c ETIME errno on platforms that actually
support timed mutexes.  The timeout should be an absolute time.
Note that the mutex should not be a recursive one, i.e., it
should only be a standard mutex or an error checking mutex since
some implementations of this method don't support recursive
mutexes.  If you want to use a recursive mutex see the methods
below.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.mutex_lock(ACE_5_6_0.ACE_mutex_t*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method is only implemented for Win32.  For abandoned
mutexes, @a abandoned is set to 1 and 0 is returned.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.mutex_lock(ACE_5_6_0.ACE_mutex_t*)">
Win32 note: Abandoned mutexes are not treated differently. 0 is
returned since the calling thread does get the ownership.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.cleanup_tss(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Call TSS destructors for the current thread.  If the current
thread is the main thread, then the argument must be 1.
For private use of ACE_Object_Manager and ACE_Thread_Adapter only.

</member>
        <member name="F:ACE_5_6_0.ACE_OS.NULL_key">
This is necessary to deal with POSIX pthreads and their use of
structures for TSS keys.
</member>
        <member name="F:ACE_5_6_0.ACE_OS.NULL_hthread">
This is necessary to deal with POSIX pthreads and their use of
structures for thread handles.
</member>
        <member name="F:ACE_5_6_0.ACE_OS.NULL_thread">
This is necessary to deal with POSIX pthreads and their use of
structures for thread ids.
</member>
        <member name="F:ACE_5_6_0.ACE_TSS_Keys.key_bit_words_">
Bit flag collection.  A bit value of 1 indicates that the key is in
use by this thread.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Keys.find(System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
For a given key, find the word and bit number that represent it.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Keys.is_set(System.UInt32!System.Runtime.CompilerServices.IsLong!System.Runtime.CompilerServices.IsConst)">
Return whether the specific key is marked as in use.
Returns 1 if the key is been marked, 0 if not.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Keys.test_and_clear(System.UInt32!System.Runtime.CompilerServices.IsLong!System.Runtime.CompilerServices.IsConst)">
Mark the specified key as not being in use, if it was not already so
cleared.  Returns 1 if the key had already been cleared, 0 if not.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Keys.test_and_set(System.UInt32!System.Runtime.CompilerServices.IsLong!System.Runtime.CompilerServices.IsConst)">
Mark the specified key as being in use, if it was not already so marked.
Returns 1 if the had already been marked, 0 if not.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Keys.#ctor">
Default constructor, to initialize all bits to zero (unused).
</member>
        <member name="T:ACE_5_6_0.ACE_TSS_Keys">
 @class ACE_TSS_Keys

 @brief Collection of in-use flags for a thread's TSS keys.
 For internal use only by ACE_TSS_Cleanup; it is public because
 some compilers can't use nested classes for template instantiation
 parameters.

 Wrapper around array of whether each key is in use.  A simple
 typedef doesn't work with Sun C++ 4.2.

</member>
        <member name="F:ACE_5_6_0.ACE_TSS_Info.thread_count_">
Count of threads that are using this key.  Contains -1 when the
key is not in use.
</member>
        <member name="F:ACE_5_6_0.ACE_TSS_Info.destructor_">
"Destructor" that gets called when the item is finally released.
</member>
        <member name="F:ACE_5_6_0.ACE_TSS_Info.key_">
Key to the thread-specific storage item.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Info.dump">
Dump the state.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Info.op_Inequality(ACE_5_6_0.ACE_TSS_Info!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check for inequality.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Info.op_Equality(ACE_5_6_0.ACE_TSS_Info!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check for equality.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Info.key_in_use(System.Int32)">
Mark the key as being in use if the flag is non-zero, or
not in use if the flag is 0.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Info.key_in_use">
Returns 1 if the key is in use, 0 if not.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Info.#ctor">
Default constructor
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Info.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong,=FUNC:System.Void(System.Void*))">
Constructor
</member>
        <member name="D:ACE_5_6_0.ACE_TSS_Info.Destructor">
Declare pointer to function to destroy tss object.
</member>
        <member name="T:ACE_5_6_0.ACE_TSS_Info">
 @class ACE_TSS_Info

 @brief Thread Specific Key management.

 This class maps a key to a "destructor."

</member>
        <member name="F:ACE_5_6_0.ACE_TSS_Ref.tid_">
ID of thread using a specific key.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Ref.op_Inequality(ACE_5_6_0.ACE_TSS_Ref!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check for inequality.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Ref.op_Equality(ACE_5_6_0.ACE_TSS_Ref!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check for equality.
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Ref.#ctor">
Default constructor
</member>
        <member name="M:ACE_5_6_0.ACE_TSS_Ref.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Constructor
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_ID.thread_handle_">
Handle to the thread (typically used to "wait" on Win32).
</member>
        <member name="F:ACE_5_6_0.ACE_Thread_ID.thread_id_">
Identify the thread.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.op_Inequality(ACE_5_6_0.ACE_Thread_ID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inequality operator.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.op_Equality(ACE_5_6_0.ACE_Thread_ID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Equality operator.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.handle(System.Void*)">
Set the thread handle.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.handle">
Get the thread handle.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.id(System.UInt32!System.Runtime.CompilerServices.IsLong)">
Set the thread id.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.id">
Get the thread id.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.#ctor(ACE_5_6_0.ACE_Thread_ID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.#ctor">
Initialize the object using calls to ACE_OS::thr_self().
</member>
        <member name="M:ACE_5_6_0.ACE_Thread_ID.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*)">
Initialize the object using the thread id and thread handle
passed as parameters.
</member>
        <member name="T:ACE_5_6_0.ACE_Thread_ID">
 @class ACE_Thread_ID

 @brief Defines a platform-independent thread ID class.  Note that
  this class should be defined within the scope of a thread, rather
  than at global scope!

</member>
        <member name="F:ACE_5_6_0.ACE_rwlock_t.waiting_important_writer_">
Condition for the upgrading reader
</member>
        <member name="F:ACE_5_6_0.ACE_rwlock_t.important_writer_">
Indicate that a reader is trying to upgrade
</member>
        <member name="F:ACE_5_6_0.ACE_rwlock_t.ref_count_">
Value is -1 if writer has the lock, else this keeps track of the
number of readers holding the lock.
</member>
        <member name="F:ACE_5_6_0.ACE_rwlock_t.num_waiting_writers_">
Number of waiting writers.
</member>
        <member name="F:ACE_5_6_0.ACE_rwlock_t.waiting_writers_">
Writer threads waiting to acquire the lock.
</member>
        <member name="F:ACE_5_6_0.ACE_rwlock_t.num_waiting_readers_">
Number of waiting readers.
</member>
        <member name="F:ACE_5_6_0.ACE_rwlock_t.waiting_readers_">
Reader threads waiting to acquire the lock.
</member>
        <member name="F:ACE_5_6_0.ACE_rwlock_t.lock_">
Serialize access to internal state.
</member>
        <member name="T:ACE_5_6_0.ACE_rwlock_t">
 @class ACE_rwlock_t

 @brief This is used to implement readers/writer locks on NT,
     VxWorks, and POSIX pthreads.

     At the current time, this stuff only works for threads
     within the same process.

</member>
        <member name="F:ACE_5_6_0.ACE_cond_t.was_broadcast_">
Keeps track of whether we were broadcasting or just signaling.
</member>
        <member name="F:ACE_5_6_0.ACE_cond_t.waiters_done_">
An auto reset event used by the broadcast/signal thread to wait
for the waiting thread(s) to wake up and get a chance at the
semaphore.

</member>
        <member name="F:ACE_5_6_0.ACE_cond_t.sema_">
Queue up threads waiting for the condition to become signaled.
</member>
        <member name="F:ACE_5_6_0.ACE_cond_t.waiters_lock_">
Serialize access to the waiters count.
</member>
        <member name="F:ACE_5_6_0.ACE_cond_t.waiters_">
Number of waiting threads.
</member>
        <member name="M:ACE_5_6_0.ACE_cond_t.waiters">
Returns the number of waiters.
</member>
        <member name="T:ACE_5_6_0.ACE_cond_t">
 @class ACE_cond_t

 @brief This structure is used to implement condition variables on
 platforms that lack it natively, such as VxWorks, and Win32.

 At the current time, this stuff only works for threads
 within the same process.

</member>
        <member name="F:siginfo_t.si_handles_">
Array of Win32 HANDLEs all of which have become signaled.
</member>
        <member name="F:siginfo_t.si_handle_">
Win32 HANDLE that has become signaled.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtok_r_emulation(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)">
Emulated strtok_r.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtok_r(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*,System.Char**)">
Finds the next token in a string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtok_r(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)">
Finds the next token in a string (safe char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtok(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Finds the next token in a string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtok(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Finds the next token in a string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strstr(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Finds the first occurance of a substring in a string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strstr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Finds the first occurance of a substring in a string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strstr(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Finds the first occurance of a substring in a string (const wchar_t
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strstr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Finds the first occurance of a substring in a string (const char
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strspn(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Searches for the first substring containing only the specified
characters and returns the size of the substring (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strspn(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Searches for the first substring containing only the specified
characters and returns the size of the substring (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strsncpy(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
This is a "safe" c string copy function (wchar_t version).
Unlike strncpy() this function will always add a terminating '\0'
char if maxlen &gt; 0.  So the user doesn't has to provide an extra
'\0' if the user wants a '\0' terminated dst.  The function
doesn't check for a 0 @a dst, because this will give problems
anyway.  When @a src is 0 an empty string is made.  We do not
"touch" * @a dst if maxlen is 0.  Returns @a dst.  Care should be
taken when replacing strncpy() calls, because in some cases a
strncpy() user is using the "not '\0' terminating" feature from
strncpy().  This happens most when the call to strncpy() was
optimized by using a maxlen which is 1 smaller than the size
because there's always written a '\0' inside this last position.
Very seldom it's possible that the '\0' padding feature from
strncpy() is needed.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.strsncpy(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
This is a "safe" c string copy function (char version).
Unlike strncpy() this function will always add a terminating '\0'
char if maxlen &gt; 0.  So the user doesn't has to provide an extra
'\0' if the user wants a '\0' terminated dst.  The function
doesn't check for a 0 @a dst, because this will give problems
anyway.  When @a src is 0 an empty string is made.  We do not
"touch" * @a dst if maxlen is 0.  Returns @a dst.  Care should be
taken when replacing strncpy() calls, because in some cases a
strncpy() user is using the "not '\0' terminating" feature from
strncpy().  This happens most when the call to strncpy() was
optimized by using a maxlen which is 1 smaller than the size
because there's always written a '\0' inside this last position.
Very seldom it's possible that the '\0' padding feature from
strncpy() is needed.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.strrchr(System.Char*,System.Char)">
Finds the last occurance of a character in a string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strrchr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
Finds the last occurance of a character in a string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strrchr(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char)">
Finds the last occurance of a character in a string (const wchar_t
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strrchr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Finds the last occurance of a character in a string (const char
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strpbrk(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Searches for characters in a string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strpbrk(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Searches for characters in a string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strpbrk(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Searches for characters in a string (const wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strpbrk(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Searches for characters in a string (const char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnstr(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Finds the first occurance of a substring in an array (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnstr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Finds the first occurance of a substring in an array (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnstr(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Finds the first occurance of a substring in an array (const wchar_t
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnstr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Finds the first occurance of a substring in an array (const char
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnlen(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Finds the length of a limited-length string (ACE_WCHAR_T version).
 @param s       The character string to find the length of.
 @param maxlen  The maximum number of characters that will be
                scanned for the terminating nul character.

 @return The length of @arg s, if the terminating nul character
         is located, else @arg maxlen.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnlen(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Finds the length of a limited-length string (char version).
 @param s       The character string to find the length of.
 @param maxlen  The maximum number of characters that will be
                scanned for the terminating nul character.

 @return The length of @arg s, if the terminating nul character
         is located, else @arg maxlen.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.strncpy(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Copies an array (ACE_WCHAR_T version)
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strncpy(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Copies an array (char version)
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strncmp(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Compares two arrays (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strncmp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Compares two arrays (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnchr(System.Char*,System.Char,System.UInt32)">
Finds the first occurance of a character in an array (ACE_WCHAR_T version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnchr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.UInt32)">
Finds the first occurance of a character in an array (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnchr(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char,System.UInt32)">
Finds the first occurance of a character in an array (const ACE_WCHAR_T
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strnchr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)">
Finds the first occurance of a character in an array (const char
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strncat(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Appends part of a string to another string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strncat(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Appends part of a string to another string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strlen(System.Char!System.Runtime.CompilerServices.IsConst*)">
Finds the length of a string (ACE_WCHAR_T version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strlen(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Finds the length of a string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strecpy(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Copies a string, but returns a pointer to the end of the
copied region (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strecpy(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Copies a string, but returns a pointer to the end of the
copied region (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strdup(System.Char!System.Runtime.CompilerServices.IsConst*)">
Returns a malloced duplicated string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strdup(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns a malloced duplicated string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcspn(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Searches for the first substring without any of the specified
characters and returns the size of the substring (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcspn(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Searches for the first substring without any of the specified
characters and returns the size of the substring (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcpy(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Copies a string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcpy(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Copies a string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcmp(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Compares two strings (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcmp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Compares two strings (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strchr(System.Char*,System.Char)">
Finds the first occurance of a character in a string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strchr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
Finds the first occurance of a character in a string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strchr(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char)">
Finds the first occurance of a character in a string (const wchar_t
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strchr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Finds the first occurance of a character in a string (const char
version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcat(System.Char*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Appends a string to another string (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strcat(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Appends a string to another string (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.memset(System.Void*,System.Int32,System.UInt32)">
Fills a buffer with a character value.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.memmove(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Moves one buffer to another.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.memcpy(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Copies one buffer to another.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.memcmp(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Compares two buffers.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.memchr(System.Void*,System.Int32,System.UInt32)">
Finds characters in a buffer (void version).
</member>
        <member name="T:ACE_5_6_0.ACE_Object_Manager">
This class is for internal use by ACE_OS, etc., only.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Object_Manager.print_error_message(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
For use by init () and fini (), to consolidate error reporting.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Object_Manager.seh_except_selector_">
These handlers determine how a thread handles win32 structured
exception.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Object_Manager.exit_info_">
For at_exit support.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Object_Manager.thread_hook_">
Thread hook that's used by this process.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Object_Manager.default_mask_">
Default signal set used, for example, in ACE_Sig_Guard.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Object_Manager.preallocated_object">
Table of preallocated objects.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Object_Manager.instance_">
Singleton instance pointer.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Object_Manager.instance">
Accessor to singleton instance.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Object_Manager.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Object_Manager.#ctor">
Constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Object_Manager.seh_except_selector">
Get/Set TSS exception action.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Object_Manager.thread_hook">
Returns the current thread hook for the process.
</member>
        <member name="F:ACE_OS_PREALLOCATED_OBJECTS">
This enum value must be last!
</member>
        <member name="T:ACE_5_6_0.ACE_OS_Object_Manager.Preallocated_Object">
Unique identifiers for preallocated objects.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Object_Manager.fini">
Explicitly destroy.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Object_Manager.init">
Explicitly initialize.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager_Base.next_">
Link to next Object_Manager, for chaining.
</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager_Base.dynamically_allocated_">
Flag indicating whether the ACE_Object_Manager was dynamically
allocated by ACE.  (If is was dynamically allocated by the
application, then the application is responsible for destroying
it.)

</member>
        <member name="F:ACE_5_6_0.ACE_Object_Manager_Base.object_manager_state_">
State of the Object_Manager;
</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager_Base.shutting_down_i">
Returns 1 after ACE_Object_Manager_Base has been destroyed.  This
flag can be used to determine if the program is in the midst of
destroying static objects.  (Note that the program might destroy
some static objects before this flag can return 1, if
ACE_HAS_NONSTATIC_OBJECT_MANAGER is not defined.)

</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager_Base.starting_up_i">
Returns 1 before ACE_Object_Manager_Base has been constructed.
This flag can be used to determine if the program is constructing
static objects.  If no static object spawns any threads, the
program will be single-threaded when this flag returns 1.  (Note
that the program still might construct some static objects when
this flag returns 0, if ACE_HAS_NONSTATIC_OBJECT_MANAGER is not
defined.)

</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager_Base.fini">
Explicitly destroy.  Returns 0 on success, -1 on failure because
the number of fini () calls hasn't reached the number of init ()
calls, or 1 if it had already been called.

</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager_Base.init">
Explicitly initialize.  Returns 0 on success, -1 on failure due
to dynamic allocation failure (in which case errno is set to
ENOMEM), or 1 if it had already been called.

</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager_Base.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Object_Manager_Base.#ctor">
Default constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Object_Manager_Base">
 @class ACE_Object_Manager_Base

 @brief Base class for ACE_Object_Manager(s).

 Encapsulates the most useful ACE_Object_Manager data structures.

</member>
        <member name="F:ACE_5_6_0.ACE_OS_Exit_Info.registered_objects_">
Keeps track of all registered objects.  The last node is only
used to terminate the list (it doesn't contain a valid
ACE_Cleanup_Info).

</member>
        <member name="M:ACE_5_6_0.ACE_OS_Exit_Info.call_hooks">
Call all registered cleanup hooks, in reverse order of
registration.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Exit_Info.find(System.Void*)">
Look for a registered cleanup hook object.  Returns 1 if already
registered, 0 if not.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Exit_Info.at_exit_i(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)">
Use to register a cleanup hook.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Exit_Info.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Exit_Info.#ctor">
Default constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_OS_Exit_Info">
 @class ACE_OS_Exit_Info

 @brief Hold Object Manager cleanup (exit) information.

 For internal use by the ACE library, only.

</member>
        <member name="F:ACE_5_6_0.ACE_Cleanup_Info.cleanup_hook_">
Cleanup hook that gets called back.
</member>
        <member name="M:ACE_5_6_0.ACE_Cleanup_Info.op_Inequality(ACE_5_6_0.ACE_Cleanup_Info!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inequality operator.
</member>
        <member name="M:ACE_5_6_0.ACE_Cleanup_Info.op_Equality(ACE_5_6_0.ACE_Cleanup_Info!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Equality operator.
</member>
        <member name="M:ACE_5_6_0.ACE_Cleanup_Info.#ctor">
Default constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Cleanup_Info">
 @class ACE_Cleanup_Info

 @brief Hold cleanup information for thread/process

</member>
        <member name="M:ACE_5_6_0.ACE_Cleanup.cleanup(System.Void*)">
Cleanup method that, by default, simply deletes itself.
</member>
        <member name="M:ACE_5_6_0.ACE_Cleanup.Dispose">
Destructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Cleanup.#ctor">
No-op constructor.
</member>
        <member name="T:ACE_5_6_0.ACE_Cleanup">
 @class ACE_Cleanup

 @brief Base class for objects that are cleaned by ACE_Object_Manager.

</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtoul(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char**,System.Int32)">
Converts a string to an unsigned long value (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtoul(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.Int32)">
Converts a string to an unsigned long value (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtol(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char**,System.Int32)">
Converts a string to a long value (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtol(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.Int32)">
Converts a string to a long value (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtod(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char**)">
Converts a string to a double value (wchar_t version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.strtod(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)">
Converts a string to a double value (char version).
</member>
        <member name="M:ACE_5_6_0.ACE_OS.set_exit_hook(=FUNC:System.Void(System.Void))">
For use by ACE_Object_Manager only, to register its exit hook..
</member>
        <member name="M:ACE_5_6_0.ACE_OS.itoa(System.Int32,System.Char*,System.Int32)">
Converts an integer to a string.
</member>
        <member name="M:ACE_5_6_0.ACE_OS.itoa(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
Converts an integer to a string.
</member>
        <member name="M:ACE_5_6_0.ACE_OS._exit(System.Int32)">
@name Non-standard functions
   *
   *  These functions aren't in the standard.
   *

</member>
        <member name="M:ACE_5_6_0.ACE_ptr_align_binary(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Return the next address aligned to a required boundary
</member>
        <member name="M:ACE_5_6_0.ACE_ptr_align_binary(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Return the next address aligned to a required boundary
</member>
        <member name="F:semun.val">
value for SETVAL
</member>
        <member name="F:sembuf.sem_flg">
operation flags
</member>
        <member name="F:sembuf.sem_op">
semaphore operation
</member>
        <member name="F:sembuf.sem_num">
semaphore #
</member>
        <member name="F:ACE_5_6_0.ACE_Base_Thread_Adapter.log_msg_attributes_">
The ACE_Log_Msg attributes.
</member>
        <member name="F:ACE_5_6_0.ACE_Base_Thread_Adapter.entry_point_">
Entry point to the underlying OS thread creation call (C
linkage).
</member>
        <member name="F:ACE_5_6_0.ACE_Base_Thread_Adapter.arg_">
Argument to thread startup function.
</member>
        <member name="F:ACE_5_6_0.ACE_Base_Thread_Adapter.user_func_">
Thread startup function passed in by the user (C++ linkage).
</member>
        <member name="T:ACE_5_6_0.ACE_Log_Msg">
Allow the ACE_Log_Msg class to set its hooks.

 @class ACE_Log_Msg

 @brief Provides a variable length argument message logging
 abstraction.

 This class is very flexible since it allows formatted error
 messages to be printed in a thread-safe manner to various
 locations, such as stderr, cerr, a distributed logger, etc.  The
 current message is also kept in a thread-specific storage location
 (threads spawned using ACE_Thread_Manager automatically get an
 ACE_Log_Msg object that inherits the spawning thread's settings),
 which can be used to communicate errors between framework methods
 and callers.  A message is logged by the log() method, only if the
 message priority is currently enabled.  Moreover, only the current
 log message is stored here -- it will be overwritten by the
 subsequent call to log().

 The ACE_Log_Msg class uses two priority masks to control its
 logging behavior.  The @c priority_mask_ object attribute is
 thread- specific and specifies the priority levels logged by the
 thread.  The @c process_priority_mask_ class attribute is not
 thread-specific and specifies the priority levels that will be
 logged by all threads in the process.  By default, all levels are
 disabled for @c priority_mask_ and all levels are enabled for @c
 process_priority_mask_ (i.e. the process-wide mask controls the
 settings, and each instance can expand on it if desired).  Both
 priority masks can be modified using the priority_mask() method of
 this class.

</member>
        <member name="M:ACE_5_6_0.ACE_Base_Thread_Adapter.set_log_msg_hooks(=FUNC:System.Void(ACE_5_6_0.ACE_OS_Log_Msg_Attributes*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,=FUNC:System.Int32(System.Void*),=FUNC:System.Int32(System.Void*)),=FUNC:System.Void(ACE_5_6_0.ACE_OS_Thread_Descriptor*,ACE_5_6_0.ACE_OS_Log_Msg_Attributes*!System.Runtime.CompilerServices.IsImplicitlyDereferenced),=FUNC:System.Void(System.Void),=FUNC:System.Void(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*),=FUNC:ACE_5_6_0.ACE_OS_Thread_Descriptor*(System.Void))">
Set the Log_Msg hooks
</member>
        <member name="F:ACE_5_6_0.ACE_Base_Thread_Adapter.init_log_msg_hook_">
The hooks to inherit and cleanup the Log_Msg attributes
</member>
        <member name="M:ACE_5_6_0.ACE_Base_Thread_Adapter.inherit_log_msg">
Inherit the logging features if the parent thread has an
ACE_Log_Msg.
</member>
        <member name="M:ACE_5_6_0.ACE_Base_Thread_Adapter.#ctor(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),ACE_5_6_0.ACE_OS_Thread_Descriptor*,=FUNC:System.Int32(System.Void*),=FUNC:System.Int32(System.Void*))">
Constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Base_Thread_Adapter.thr_desc_log_msg">
Invoke the thr_desc_log_msg_hook, if it is present
</member>
        <member name="M:ACE_5_6_0.ACE_Base_Thread_Adapter.sync_log_msg(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Invoke the sync_log_msg_hook, if it is present
</member>
        <member name="M:ACE_5_6_0.ACE_Base_Thread_Adapter.close_log_msg">
Invoke the close_log_msg_hook, if it is present
</member>
        <member name="M:ACE_5_6_0.ACE_Base_Thread_Adapter.entry_point">
Accessor for the C entry point function to the OS thread creation
routine.
</member>
        <member name="M:ACE_5_6_0.ACE_Base_Thread_Adapter.invoke">
Virtual method invoked by the thread entry point.
</member>
        <member name="T:ACE_5_6_0.ACE_Base_Thread_Adapter">
 @class ACE_Base_Thread_Adapter

 @brief Base class for all the Thread_Adapters.

 Converts a C++ function into a function that can be
 called from a thread creation routine
 (e.g., pthread_create() or _beginthreadex()) that expects an
 extern "C" entry point.  This class also makes it possible to
 transparently provide hooks to register a thread with an
 ACE_Thread_Manager.
 This class is used in ACE_OS::thr_create().  In general, the
 thread that creates an object of this class is different from
 the thread that calls @c invoke() on this object.  Therefore,
 the @c invoke() method is responsible for deleting itself.

</member>
        <member name="M:ACE_5_6_0.ACE_OS_Thread_Descriptor.#ctor(System.Int32!System.Runtime.CompilerServices.IsLong)">
For use by ACE_Thread_Descriptor.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Thread_Descriptor.flags">
Get the thread creation flags.
</member>
        <member name="T:ACE_5_6_0.ACE_OS_Thread_Descriptor">
 @class ACE_OS_Thread_Descriptor

 @brief Parent class of all ACE_Thread_Descriptor classes.
 =
 Container for ACE_Thread_Descriptor members that are
 used in ACE_OS.

</member>
        <member name="F:ACE_5_6_0.ACE_OS_Log_Msg_Attributes.seh_except_selector_">
Structured exception handling Callbacks, only used under Win32
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Log_Msg_Attributes.trace_depth_">
Depth of the nesting for printing traces.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Log_Msg_Attributes.restart_">
Indicates whether we should restart system calls that are
interrupted.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Log_Msg_Attributes.tracing_enabled_">
Are we allowing tracing in this thread?
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Log_Msg_Attributes.priority_mask_">
Priority_mask to be used in new TSS Log_Msg.
</member>
        <member name="F:ACE_5_6_0.ACE_OS_Log_Msg_Attributes.ostream_">
Ostream where the new TSS Log_Msg will use.
</member>
        <member name="M:ACE_5_6_0.ACE_OS_Log_Msg_Attributes.#ctor">
Constructor
</member>
        <member name="T:ACE_5_6_0.ACE_OS_Log_Msg_Attributes">
 @class ACE_OS_Log_Msg_Attributes

 @brief The attributes required by ACE_Log_Msg.

 When a new thread is created the TSS resources for the Log_Msg
 class in the new thread may be inherited by the creator thread.
 The base_attributes are encapsulated in this class to simplify their
 manipulation and destruction.
 @par
 The contents of the class must be made available to the OS layer,
 because they are part of the thread descriptor.

</member>
        <member name="T:ACE_5_6_0.ACE_Reactor_Timer_Interface">
 @class ACE_Reactor_Timer_Interface

 @brief Interface for timer related methods on the Reactor.

</member>
        <member name="T:ACE_5_6_0.ACE_Errno_Guard">
 @class ACE_Errno_Guard

 @brief Provides a wrapper to improve performance when thread-specific
 errno must be saved and restored in a block of code.

 The typical use-case for this is the following:
 int error = errno;
 call_some_function_that_might_change_errno ();
 errno = error;
 This can be replaced with
 {
 ACE_Errno_Guard guard (errno);
 call_some_function_that_might_change_errno ();
 }
 This implementation is more elegant and more efficient since it
 avoids an unnecessary second access to thread-specific storage
 by caching a pointer to the value of errno in TSS.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.normalize">
Put the timevalue into a canonical form.
</member>
        <member name="F:ACE_5_6_0.ACE_Time_Value.FILETIME_to_timval_skew">
Const time difference between FILETIME and POSIX time.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.dump">
Dump is a no-op.
The dump() method is a no-op.  It's here for backwards compatibility
only, but does not dump anything. Invoking logging methods here
violates layering restrictions in ACE because this class is part
of the OS layer and @c ACE_Log_Msg is at a higher level.

</member>
        <member name="M:ACE_5_6_0.op_Multiply(System.Double,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Multiplies the time value by @a d
</member>
        <member name="M:ACE_5_6_0.op_Inequality(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
True if @a tv1 != @a tv2.
</member>
        <member name="M:ACE_5_6_0.op_Equality(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
True if @a tv1 == @a tv2.
</member>
        <member name="M:ACE_5_6_0.op_GreaterThanOrEqual(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
True if @a tv1 &gt;= @a tv2.
</member>
        <member name="M:ACE_5_6_0.op_GreaterThan(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
True if @a tv1 &gt; @a tv2.
</member>
        <member name="M:ACE_5_6_0.op_Subtraction(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Subtracts two ACE_Time_Value objects, returns the difference.
</member>
        <member name="M:ACE_5_6_0.op_Addition(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds two ACE_Time_Value objects together, returns the sum.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Decrement">
Decrement microseconds as prefix.
@note The only reason this is here is to allow the use of ACE_Atomic_Op
with ACE_Time_Value.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Decrement(System.Int32)">
Decrement microseconds as postfix.
@note The only reason this is here is to allow the use of ACE_Atomic_Op
with ACE_Time_Value.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Increment">
Increment microseconds as prefix.
@note The only reason this is here is to allow the use of ACE_Atomic_Op
with ACE_Time_Value.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Increment(System.Int32)">
Increment microseconds as postfix.
@note The only reason this is here is to allow the use of ACE_Atomic_Op
with ACE_Time_Value.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_SubtractionAssignment(System.Int64)">
Substract @a tv to this.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_SubtractionAssignment(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Subtract @a tv to this.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Assign(System.Int64)">
Assign @ tv to this
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Assign(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assign @ tv to this
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_AdditionAssignment(System.Int64)">
Add @a tv to this.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_AdditionAssignment(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add @a tv to this.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.to_usec(System.UInt64*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@return Sum of second field (in microseconds) and microsecond field
        and return them via the @param usec parameter.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.usec(System.Int32!System.Runtime.CompilerServices.IsLong)">
Set microseconds.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.usec">
Get microseconds.
 @return The microsecond field/component of this ACE_Time_Value.

 @note The semantics of this method differs from the msec()
       method.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.sec(System.Int64)">
Set seconds.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.sec">
Get seconds.
 @return The second field/component of this ACE_Time_Value.

 @note The semantics of this method differs from the msec()
       method.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Implicit~_FILETIME">
Returns the value of the object as a Win32 FILETIME.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Implicit~timeval!System.Runtime.CompilerServices.IsConst*">
Returns a pointer to the object as a timeval.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Implicit~timeval">
Returns the value of the object as a timeval.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.op_Implicit~timespec">
Returns the value of the object as a timespec_t.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.msec(System.Int32!System.Runtime.CompilerServices.IsLong)">
Converts from milli-seconds format into ACE_Time_Value format.
@note The semantics of this method differs from the sec() and
      usec() methods.  There is no analogous "millisecond"
      component in an ACE_Time_Value.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.msec(System.UInt64*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 @return Sum of second field (in milliseconds) and microsecond field
         (in milliseconds) and return them via the @param ms parameter.

 @note The semantics of this method differs from the sec() and
       usec() methods.  There is no analogous "millisecond"
       component in an ACE_Time_Value.

</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.set(_FILETIME!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Initializes the ACE_Time_Value object from a Win32 FILETIME.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.set(timespec!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Initializes the ACE_Time_Value object from a timespec_t.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.set(timeval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Initializes the ACE_Time_Value from a timeval.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.set(System.Double)">
Initializes the ACE_Time_Value from a double, which is assumed to be
in second format, with any remainder treated as microseconds.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.set(System.Int64,System.Int32!System.Runtime.CompilerServices.IsLong)">
Initializes the ACE_Time_Value from seconds and useconds.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.#ctor(_FILETIME!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Construct the ACE_Time_Value object from a Win32 FILETIME
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.#ctor(timespec!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Construct the ACE_Time_Value object from a timespec_t.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.#ctor(timeval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Construct the ACE_Time_Value from a timeval.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.#ctor(System.Int64,System.Int32!System.Runtime.CompilerServices.IsLong)">
Constructor.
</member>
        <member name="M:ACE_5_6_0.ACE_Time_Value.#ctor">
Default Constructor.
</member>
        <member name="F:ACE_5_6_0.ACE_Time_Value.zero">
Constant "0".
</member>
        <member name="F:timespec.tv_nsec">
Nanoseconds
</member>
        <member name="F:timespec.tv_sec">
Seconds
</member>
        <member name="T:ACE_5_6_0.ACE_MT_SYNCH">
 @class ACE_MT_SYNCH

 @brief Implement a default thread safe synchronization wrapper that
        typedefs the @c ACE_Condition and @c ACE_Mutex to the
 @c ACE_Condition and @c ACE_Mutex versions.

 @todo This should be a template, but SunC++ 4.0.1 complains about
       this.

</member>
        <member name="T:ACE_5_6_0.ACE_NULL_SYNCH">
 @class ACE_NULL_SYNCH

 @brief Implement a do nothing Synchronization wrapper that
        typedefs the @c ACE_Condition and @c ACE_Mutex to the
        @c Null* versions.

</member>
        <member name="M:ACE_5_6_0.ACE_Lock.release">
Release the lock.  Returns -1 on failure.
</member>
        <member name="M:ACE_5_6_0.ACE_Lock.tryacquire">
Conditionally acquire the lock (i.e., won't block).  Returns -1
on failure.  If we "failed" because someone else already had the
lock, @c errno is set to @c EBUSY.

</member>
        <member name="M:ACE_5_6_0.ACE_Lock.acquire">
Block the thread until the lock is acquired.  Returns -1 on
failure.
</member>
        <member name="M:ACE_5_6_0.ACE_Lock.remove">
Explicitly destroy the lock.  Note that only one thread should
call this method since it doesn't protect against race
conditions.

</member>
        <member name="M:ACE_5_6_0.ACE_Lock.Dispose">
Noop virtual destructor
</member>
        <member name="M:ACE_5_6_0.ACE_Lock.#ctor">
CE needs a default ctor here.
</member>
        <member name="T:ACE_5_6_0.ACE_Lock">
 @class ACE_Lock

 @brief This is the abstract base class that contains the uniform
 locking API that is supported by all the ACE synchronization
 mechanisms.

 This class is typically used in conjunction with the
 ACE_Lock_Adapter in order to provide a polymorphic
 interface to the ACE synchronization mechanisms (e.g.,
 ACE_Mutex, ACE_Semaphore, ACE_RW_Mutex, etc).  Note that
 the reason that all of ACE doesn't use polymorphic locks is
 that (1) they add ~20% extra overhead for virtual function
 calls and (2) objects with virtual functions can't be placed
 into shared memory.

</member>
        <member name="M:ACE_5_6_0.ACE_Ascii_To_Wide.#ctor">
Disallow these operation.
</member>
        <member name="F:ACE_5_6_0.ACE_Ascii_To_Wide.s_">
Internal pointer to the converted string.
</member>
        <member name="M:ACE_5_6_0.ACE_Ascii_To_Wide.convert(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Converts an char string to unicode/wide and returns a new string.
</member>
        <member name="M:ACE_5_6_0.ACE_Ascii_To_Wide.wchar_rep">
Return the internal wchar* representation.
</member>
        <member name="M:ACE_5_6_0.ACE_Ascii_To_Wide.Dispose">
Dtor will free up the memory.
</member>
        <member name="M:ACE_5_6_0.ACE_Ascii_To_Wide.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Ctor must take a wchar string.
</member>
        <member name="T:ACE_5_6_0.ACE_Ascii_To_Wide">
 @class ACE_Ascii_To_Wide

 @brief A lightweight char* to wchar* string conversion class.

 The purpose of this class is to perform conversion from
 char* to wchar* strings.  It is not intended for general
 purpose use.

</member>
        <member name="M:ACE_5_6_0.ACE_Wide_To_Ascii.#ctor">
Disallow these operation.
</member>
        <member name="F:ACE_5_6_0.ACE_Wide_To_Ascii.s_">
Internal pointer to the converted string.
</member>
        <member name="M:ACE_5_6_0.ACE_Wide_To_Ascii.convert(System.Char!System.Runtime.CompilerServices.IsConst*)">
Converts an wchar_t string to ascii and returns a new string.
</member>
        <member name="M:ACE_5_6_0.ACE_Wide_To_Ascii.char_rep">
Return the internal char* representation.
</member>
        <member name="M:ACE_5_6_0.ACE_Wide_To_Ascii.Dispose">
Dtor will free up the memory.
</member>
        <member name="M:ACE_5_6_0.ACE_Wide_To_Ascii.#ctor(System.Char!System.Runtime.CompilerServices.IsConst*)">
Ctor must take a wchar string.
</member>
        <member name="T:ACE_5_6_0.ACE_Wide_To_Ascii">
 @class ACE_Wide_To_Ascii

 @brief A lightweight wchar* to char* string conversion class.

 The purpose of this class is to perform conversion from
 wchar* to char* strings.  It is not intended for general
 purpose use.

</member>
        <member name="M:GemStone.GemFire.Cache.Struct.#ctor(gemfire.Serializable*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Struct.Create(gemfire.Serializable*)">
            <summary>
Factory function to register wrapper
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Struct.Next">
            <summary>
Get the next field value item available in this <c>Struct</c>.
</summary>
            <returns>
A reference to the next item in the <c>Struct</c>
or null if no more available.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Struct.Length">
            <summary>
Get the number of field values available.
</summary>
            <returns>the number of field values available.</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Struct.HasNext">
            <summary>
Check whether another field value is available to iterate over
in this <c>Struct</c>.
</summary>
            <returns>true if available otherwise false.</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Struct.Set">
            <summary>
Get the parent <c>StructSet</c> of this <c>Struct</c>.
</summary>
            <returns>
A reference to the parent <c>StructSet</c> of this <c>Struct</c>.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Struct.default(System.String)">
            <summary>
Get the field value for the given field name.
</summary>
            <returns>The value of the field.</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the field name is not found.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Struct.Item(System.UInt32)">
            <summary>
Get the field value for the given index number.
</summary>
            <returns>
The value of the field or null if index is out of bounds.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Struct">
            <summary>
Encapsulates a row of query struct set.
</summary>
            <remarks>
A Struct has a StructSet as its parent. It contains the field values
returned after executing a Query obtained from a QueryService which in turn
is obtained from a Cache.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectXml.#ctor(System.Object)">
            <summary>
Allocates a new instance from the given object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectXml.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableObjectXml.Value">
            <summary>
Gets the object value.
</summary>
            <remarks>
The user can modify the object and the changes shall be reflected
immediately in the local cache. For this change to be propagate to
other members of the distributed system, the object needs to be
put into the cache.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableObjectXml.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableObjectXml.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectXml.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserializes the <see cref="T:System.Object" /> using
<see cref="T:System.Xml.Serialization.XmlSerializer" /> class.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectXml.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this <see cref="T:System.Object" /> using
<see cref="T:System.Xml.Serialization.XmlSerializer" /> class.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectXml.Create(System.Object)">
            <summary>
Static function to create a new instance from the given object.
</summary>
            <remarks>
If the given object is null then this method returns null.
</remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableObjectXml">
            <summary>
A mutable generic <see cref="T:System.Object" /> wrapper that can
serve as a distributable value for caching.
</summary>
            <remarks>
                <para>
This class can contain any object and uses the
<see cref="T:System.Xml.Serialization.XmlSerializer" /> to
serialize and deserialize the object. So the user must use the
<c>XmlSerializer</c> attributes to control the serialization/deserialization
of the object (or implement the <see cref="T:System.Xml.Serialization.IXmlSerializable" />)
to change the serialization/deserialization. However, the latter should
be avoided for efficiency reasons and the user should implement
<see cref="T:GemStone.GemFire.Cache.IGFSerializable" /> instead.
</para>
                <para>
The user must keep in mind that the rules that apply to <c>XmlSerializer</c>
would be the rules that apply to this class. For instance the user
cannot pass objects of class implementing or containing
<see cref="T:System.Collections.IDictionary" /> class, must use
<see cref="T:System.Xml.Serialization.XmlIncludeAttribute" /> to
mark user-defined types etc.
</para>
            </remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObject.#ctor(System.Object)">
            <summary>
Allocates a new instance from the given object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObject.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableObject.Value">
            <summary>
Gets the object value.
</summary>
            <remarks>
The user can modify the object and the changes shall be reflected
immediately in the local cache. For this change to be propagate to
other members of the distributed system, the object needs to be
put into the cache.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableObject.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableObject.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObject.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserializes the <see cref="T:System.Object" /> using
<see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" /> class.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObject.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this <see cref="T:System.Object" /> using
<see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" /> class.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObject.Create(System.Object)">
            <summary>
Static function to create a new instance from the given object.
</summary>
            <remarks>
If the given object is null then this method returns null.
</remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableObject">
            <summary>
An mutable generic <see cref="T:System.Object" /> wrapper that can
serve as a distributable value for caching.
</summary>
            <remarks>
                <para>
This class can serialize any class which has either the
[Serializable] attribute set or implements
<see cref="T:System.Runtime.Serialization.ISerializable" /> interface.
However, for better efficiency the latter should be avoided and the
user should implement <see cref="T:GemStone.GemFire.Cache.IGFSerializable" /> instead.
</para>
                <para>
The user must keep in mind that the rules that apply to runtime
serialization would be the rules that apply to this class. For
the serialization will be carried out by serializing all the
members (public/private/protected) of the class. Each of the
contained classes should also have either the [Serializable]
attribute set or implement <c>ISerializable</c> interface.
</para>
            </remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.#ctor(gemfire.Serializable*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.#ctor(GemStone.GemFire.Cache.CacheableString[])">
            <summary>
Allocates a new instance assigning the given
<c>CacheableString</c> array.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array contains a string greater than or equal 64K in length.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.#ctor(System.String[])">
            <summary>
Allocates a new instance copying from the given string array.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array contains a string greater than or equal 64K in length.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.Create(gemfire.Serializable*)">
            <summary>
Factory function to register wrapper
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableStringArray.Length">
            <summary>
Gets the length of the array.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableStringArray.Item(System.Int32)">
            <summary>
Returns a copy of the underlying string at the given index.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.GetValues">
            <summary>
Returns a copy of the underlying array of strings.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableStringArray.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableStringArray.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserializes the managed object -- returns an instance of the
<c>IGFSerializable</c> class.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this managed object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.Create(GemStone.GemFire.Cache.CacheableString[])">
            <summary>
Static function to create a new instance assigning the given
<c>CacheableString</c> array.
</summary>
            <remarks>
If the given array of strings is null or of zero-length then
this method returns null.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array contains a string greater than or equal 64K in length.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStringArray.Create(System.String[])">
            <summary>
Static function to create a new instance copying from the given
string array.
</summary>
            <remarks>
If the given array of strings is null or of zero-length then
this method returns null.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array contains a string greater than or equal 64K in length.
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableStringArray">
            <summary>
An immutable wrapper for array of strings that can serve as
a distributable object for caching.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableObjectArray.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableObjectArray.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.Create(System.Int32)">
            <summary>
Static function to create a new instance with given initial size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.Create(System.Collections.Generic.IEnumerable`1{GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Static function to create a new instance copying from the
given collection.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the vector.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.#ctor(System.Collections.Generic.IEnumerable`1{GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Allocates a new instance copying from the given collection.
</summary>
            <param name="collection">
The collection whose elements are copied to this list.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableObjectArray.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableObjectArray">
            <summary>
A mutable <c>IGFSerializable</c> object array wrapper that can serve
as a distributable object for caching. Though this class provides
compatibility with java Object[] serialization, it provides the
semantics of .NET generic <c>List</c> class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableIdentityHashMap.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableIdentityHashMap.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableIdentityHashMap.Create(System.Int32)">
            <summary>
Static function to create a new instance with given initial size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableIdentityHashMap.Create(System.Collections.Generic.IDictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Static function to create a new instance copying from the
given dictionary.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableIdentityHashMap.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableIdentityHashMap.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the HashMap.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableIdentityHashMap.#ctor(System.Collections.Generic.IDictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Allocates a new instance copying from the given dictionary.
</summary>
            <param name="dictionary">
The dictionary whose elements are copied to this HashMap.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableIdentityHashMap.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableIdentityHashMap">
            <summary>
A mutable <c>ICacheableKey</c> to <c>IGFSerializable</c> hash map
that can serve as a distributable object for caching. This class
extends .NET generic <c>Dictionary</c> class. This class is meant
as a means to interoperate with java server side
<c>IdentityHashMap</c> class objects but is intentionally not
intended to provide <c>java.util.IdentityHashMap</c> semantics.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashTable.Create">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashTable.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableHashTable.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashTable.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the HashTable.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashTable.#ctor(System.Collections.Generic.IDictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Allocates a new instance copying from the given dictionary.
</summary>
            <param name="dictionary">
The dictionary whose elements are copied to this HashTable.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashTable.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableHashTable">
            <summary>
A mutable <c>ICacheableKey</c> to <c>IGFSerializable</c> hash table
that can serve as a distributable object for caching. This class
extends .NET generic <c>Dictionary</c> class.
</summary>
        </member>
        <member name="F:gemfire.ManagedPartitionResolverGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IPartitionResolver
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedPartitionResolverGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedPartitionResolverGeneric.getName">
            <summary>
Returns the name of the PartitionResolver.
</summary>
            <remarks>
                <para>
This function does not throw any exception.
</para>
                <returns>
the name of the PartitionResolver
</returns>
            </remarks>
        </member>
        <member name="M:gemfire.ManagedPartitionResolverGeneric.getRoutingObject(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return object associated with entry event which allows the Partitioned Region to store associated data together.
</summary>
            <remarks>
throws RuntimeException - any exception thrown will terminate the operation and the exception will be passed to the
calling thread.
</remarks>
            <param name="key">
key the detail of the entry event.
</param>
        </member>
        <member name="M:gemfire.ManagedPartitionResolverGeneric.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedPartitionResolverGeneric.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedPartitionResolver</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>IPartitionResolver</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>IPartitionResolver</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedPartitionResolverGeneric.#ctor(System.Object)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="userptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedPartitionResolverGeneric">
            <summary>
Wraps the managed <see cref="!:GemStone.GemFire.Cache.IPartitionResolver" />
object and implements the native <c>gemfire::PartitionResolver</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheWriterGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheWriter
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.close(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external
resources, such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.beforeRegionDestroy(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
called before this region is destroyed
</summary>
            <param name="ev">
RegionEvent denotes the event object associated with destroying the region
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.beforeRegionClear(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
called before this region is cleared
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.beforeDestroy(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called before an entry is destroyed.
</summary>
            <remarks>
The entry being destroyed may or may
not exist in the local cache where the CacheWriter is installed. This method
is <em>not</em> called as a result of expiration or
<see cref="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with destroying the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.beforeCreate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called before an entry is created. Entry creation is initiated by a
<c>create</c>, a <c>put</c>, or a <c>get</c>.
</summary>
            <remarks>
The <c>CacheWriter</c> can determine whether this value comes from a
<c>get</c> or not from <c>load</c>. The entry being created may already
exist in the local cache where this <c>CacheWriter</c> is installed,
but it does not yet exist in the cache where the operation was initiated.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with creating the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.beforeUpdate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called before an entry is updated. The entry update is initiated by a
<c>put</c> or a <c>get</c> that causes the loader to update an existing entry.
</summary>
            <remarks>
The entry previously existed in the cache where the operation was
initiated, although the old value may have been null. The entry being
updated may or may not exist in the local cache where the CacheWriter is
installed.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedCacheWriter</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheWriter</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>ICacheWriter</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedCacheWriterGeneric.#ctor(System.Object)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="userptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheWriterGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.ICacheWriter" />
object and implements the native <c>gemfire::CacheWriter</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.CreateRegionAttributes">
            <summary>
Creates a <c>RegionAttributes</c> with the current settings.
</summary>
            <returns>the newly created <c>RegionAttributes</c></returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the current settings violate the <a href="compability.html">
compatibility</a> rules.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCloningEnabled(System.Boolean)">
            <summary>
Set cloning enabled flag for this region.
</summary>
            <remarks>
                <para>
If set to false, then there is no cloning will take place in case of delta.
Delta will be applied on the old value which will change old value in-place.
</para>
                <para>
The default if not set is 'false'
of <c>ScopeType.Local</c> scope. 
</para>
            </remarks>
            <param name="cloningEnabled">
if true, clone old value before applying delta so that in-place change would not occour..
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCachingEnabled(System.Boolean)">
            <summary>
Set caching enabled flag for this region.
</summary>
            <remarks>
                <para>
If set to false, then no data is stored in the local process,
but events and distributions will still occur, and the region
can still be used to put and remove, etc...
</para>
                <para>
The default if not set is 'true', 'false' is illegal for regions
of <c>ScopeType.Local</c> scope. 
</para>
            </remarks>
            <param name="cachingEnabled">
if true, cache data for this region in this process.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetDiskPolicy(GemStone.GemFire.Cache.Generic.DiskPolicyType)">
            <summary>
Sets the disk policy type for the next <c>RegionAttributes</c> created.
</summary>
            <param name="diskPolicy">
the disk policy to use for the region
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetLruEntriesLimit(System.UInt32)">
            <summary>
Sets a limit on the number of entries that will be held in the cache.
If a new entry is added while at the limit, the cache will evict the
least recently used entry.
</summary>
            <param name="entriesLimit">
The limit of the number of entries before eviction starts.
Defaults to 0, meaning no LRU actions will used.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetConcurrencyLevel(System.Int32)">
            <summary>
Sets the concurrency level of the next <c>RegionAttributes</c>
created. This value is used in initializing the map that holds the entries.
</summary>
            <param name="concurrencyLevel">
the concurrency level of the entry map
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if concurrencyLevel is nonpositive
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetLoadFactor(System.Single)">
            <summary>
Sets the entry load factor for the next <c>RegionAttributes</c>
created. This value is
used in initializing the map that holds the entries.
</summary>
            <param name="loadFactor">the load factor of the entry map</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if loadFactor is nonpositive
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetInitialCapacity(System.Int32)">
            <summary>
Sets the entry initial capacity for the <c>RegionAttributes</c>
being created. This value is used in initializing the map that
holds the entries.
</summary>
            <param name="initialCapacity">the initial capacity of the entry map</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if initialCapacity is nonpositive
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetPoolName(System.String)">
            <summary>
Set the pool name for a Thin Client region.
</summary>
            <remarks>
The pool with the name specified must be already created.
</remarks>
            <param name="poolName">
The name of the pool to attach to this region.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetEndpoints(System.String)">
            <summary>
Set the endpoints for a Thin Client region.
</summary>
            <remarks>
If the endpoints are set then the region is taken to be a Thin-client
region that interacts with the GemFire Java cacheserver.
</remarks>
            <param name="endpoints">
The list of host:port pairs separated by commas.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetClientNotificationEnabled(System.Boolean)">
            <summary>
Enables/disables client noficiations for a Thin client region.
</summary>
            <param name="clientNotificationEnabled">
true if client notifications have to be enabled; false otherwise
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetScope(GemStone.GemFire.Cache.Generic.ScopeType)">
            <summary>
Sets the scope for the next <c>RegionAttributes</c> created.
</summary>
            <param name="scopeType">
the type of scope to use for the region
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetPersistenceManager(System.String,System.String,GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.String^})">
            <summary>
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
This must be used to set the PersistenceManager.
</summary>
            <param name="libPath">The path of the PersistenceManager shared library.</param>
            <param name="factoryFunctionName">
The name of the factory function to create an instance of PersistenceManager object.
</param>
            <param name="config">
The configuration properties to use for the PersistenceManager.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetPersistenceManager(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
This must be used to set the PersistenceManager.
</summary>
            <param name="libPath">The path of the PersistenceManager shared library.</param>
            <param name="factoryFunctionName">
The name of the factory function to create an instance of PersistenceManager object.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetRegionTimeToLive(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)">
            <summary>
Sets the timeToLive expiration attributes for the region itself for the
next <c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="timeToLive">
the timeToLive in seconds for the region as a whole.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetRegionIdleTimeout(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)">
            <summary>
Sets the idleTimeout expiration attributes for the region itself for the
next <c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="idleTimeout">
the idleTimeout in seconds for the region as a whole.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetEntryTimeToLive(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)">
            <summary>
Sets the timeToLive expiration attributes for region entries for the next
<c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="timeToLive">
the timeToLive in seconds for entries in this region.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetEntryIdleTimeout(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)">
            <summary>
Sets the idleTimeout expiration attributes for region entries for the next
<c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="idleTimeout">
the idleTimeout in seconds for entries in this region.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetPartitionResolver(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the partition resolver of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>PartitionResolver</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>IPartitionResolver</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheListener(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the listener of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheListener</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheListener</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheWriter(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the writer of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheWriter</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheWriter</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheLoader(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the loader of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheLoader</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheLoader</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetPartitionResolver(GemStone.GemFire.Cache.Generic.IPartitionResolver`2{`0,`1})">
            <summary>
Sets the PartitionResolver for the <c>RegionAttributes</c> being created.
</summary>
            <param name="partitionresolver">
user-defined partition resolver, or null for no partition resolver
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheListener(GemStone.GemFire.Cache.Generic.ICacheListener`2{`0,`1})">
            <summary>
Sets the CacheListener for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheListener">
user-defined cache listener, or null for no cache listener
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheWriter(GemStone.GemFire.Cache.Generic.ICacheWriter`2{`0,`1})">
            <summary>
Sets the cache writer for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheWriter">
user-defined cache writer, or null for no cache writer
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheLoader(GemStone.GemFire.Cache.Generic.ICacheLoader`2{`0,`1})">
            <summary>
Sets the cache loader for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheLoader">
a user-defined cache loader, or null for no cache loader
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.#ctor(GemStone.GemFire.Cache.Generic.RegionAttributes`2{`0,`1})">
            <summary>
Creates a new instance of <c>AttributesFactory</c> ready to create
a <c>RegionAttributes</c> with the same settings as those in the
specified <c>RegionAttributes</c>.
</summary>
            <param name="regionAttributes">
attributes used to initialize this AttributesFactory
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.#ctor">
            <summary>
Creates a new <c>AttributesFactory</c> ready to create
a <c>RegionAttributes</c> with default settings.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.AttributesFactory`2">
            <summary>
Factory class to create instances of <see cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" />.
</summary>
            <remarks>
An <see cref="T:GemStone.GemFire.Cache.Generic.AttributesFactory`2" />
instance maintains state for creating <see cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" /> instances.
The setter methods are used to change the settings that will be used for
creating the next attributes instance with the <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.CreateRegionAttributes" />
method. If you create a factory with the default constructor, then the
factory is set up to create attributes with all default settings. You can
also create a factory by providing a preset <see cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" />.
<para>
Once a <see cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" /> is created, it can only be modified
after it has been used to create a <see cref="T:GemStone.GemFire.Cache.Generic.Region`2" />, and then only by
using an <see cref="T:GemStone.GemFire.Cache.Generic.AttributesMutator`2" /> obtained from the region.
</para><para><h3>Attributes</h3><h4>Callbacks</h4><dl><dt><see cref="T:GemStone.GemFire.Cache.Generic.ICacheLoader`2" /> [<em>default:</em> null]</dt><dd>User-implemented plug-in for loading data on cache misses.<br />
       see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheLoader(System.String,System.String)" />,
           <see cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheLoader" /></dd><dt><see cref="T:GemStone.GemFire.Cache.Generic.ICacheWriter`2" /> [<em>default:</em> null]</dt><dd>User-implemented plug-in for intercepting cache modifications, e.g.
        for writing to an external data source.<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheWriter(System.String,System.String)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheWriter" /></dd><dt><see cref="T:GemStone.GemFire.Cache.Generic.ICacheListener`2" /> [<em>default:</em> null]</dt><dd>User-implemented plug-in for receiving and handling cache-related events.<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetCacheListener(System.String,System.String)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener" /></dd><dt><see cref="T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2" /> [<em>default:</em> null]</dt><dd>User-implemented plug-in for custom partitioning.<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetPartitionResolver(System.String,System.String)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.PartitionResolver" /></dd></dl><h4>Expiration</h4><dl><dt>RegionTimeToLive [<em>default:</em> no expiration]</dt><dd>Expiration configuration for the entire region based on the
    lastModifiedTime ( <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> ).<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetRegionTimeToLive(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.RegionTimeToLive" />,
            <see cref="M:GemStone.GemFire.Cache.AttributesMutator.SetRegionTimeToLive(System.Int32)" /></dd><dt>RegionIdleTimeout [<em>default:</em> no expiration]</dt><dd>Expiration configuration for the entire region based on the
        lastAccessedTime ( <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> ).<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetRegionIdleTimeout(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.RegionIdleTimeout" />,
            <see cref="M:GemStone.GemFire.Cache.AttributesMutator.SetRegionIdleTimeout(System.Int32)" /></dd><dt>EntryTimeToLive [<em>default:</em> no expiration]</dt><dd>Expiration configuration for individual entries based on the
    lastModifiedTime ( <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> ).<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetEntryTimeToLive(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.EntryTimeToLive" />,
            <see cref="M:GemStone.GemFire.Cache.AttributesMutator.SetEntryTimeToLive(System.Int32)" /></dd><dt>EntryIdleTimeout [<em>default:</em> no expiration]</dt><dd>Expiration configuration for individual entries based on the
        lastAccessedTime ( <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> ).<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetEntryIdleTimeout(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.EntryIdleTimeout" />,
            <see cref="M:GemStone.GemFire.Cache.AttributesMutator.SetEntryIdleTimeout(System.Int32)" /></dd></dl><h4>Distribution</h4><dl><dt><see cref="T:GemStone.GemFire.Cache.Generic.ScopeType" /> [<em>default:</em><tt>ScopeType.DistributedNoAck</tt>]</dt><dd>The C++ cache can contain either local regions or distributed regions. 
        Distributed regions are configured with servers that they distribute 
        their operations to upto. Locally scoped regions do not have any 
        distribution behavior. GFE native client regions scoped as 
        ScopeType.DistributedNoAck and ScopeType.DistributedAck have identical
        distribution behavior.<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetScope(GemStone.GemFire.Cache.Generic.ScopeType)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.Scope" /></dd></dl><h4>Storage</h4><dl><dt>InitialCapacity [<em>default:</em><tt>16</tt>]</dt><dd>The initial capacity of the map used for storing the entries.<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetInitialCapacity(System.Int32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.InitialCapacity" /></dd><dt>LoadFactor [<em>default:</em><tt>0.75</tt>]</dt><dd>The load factor of the map used for storing the entries.<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetLoadFactor(System.Single)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.LoadFactor" /></dd><dt>ConcurrencyLevel [<em>default:</em><tt>16</tt>]</dt><dd>The allowed concurrency among updates to values in the region
        is guided by the <tt>concurrencyLevel</tt>, which is used as a hint
        for internal sizing. The actual concurrency will vary.
        Ideally, you should choose a value to accommodate as many
        threads as will ever concurrently modify values in the region. Using a
        significantly higher value than you need can waste space and time,
        and a significantly lower value can lead to thread contention. But
        overestimates and underestimates within an order of magnitude do
        not usually have much noticeable impact. A value of one is
        appropriate when it is known that only one thread will modify
        and all others will only read.<br />
        see <see cref="M:GemStone.GemFire.Cache.Generic.AttributesFactory`2.SetConcurrencyLevel(System.Int32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.ConcurrencyLevel" /></dd></dl></para></remarks>
            <seealso cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" />
            <seealso cref="T:GemStone.GemFire.Cache.Generic.AttributesMutator`2" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.CreateSubRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SelectResultsIterator`1.#ctor(gemfire.SelectResultsIterator*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SelectResultsIterator`1.Create(gemfire.SelectResultsIterator*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SelectResultsIterator`1.HasNext">
            <summary>
Check if there is a next element.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SelectResultsIterator`1.Next">
            <summary>
Get the current element and move to the next one.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SelectResultsIterator`1.Reset">
            <summary>
Sets the enumerator to its initial position, which is before
the first element in the collection.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SelectResultsIterator`1.MoveNext">
            <summary>
Advances the enumerator to the next element of the collection.
</summary>
            <returns>
true if the enumerator was successfully advanced to the next
element; false if the enumerator has passed the end of
the collection.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SelectResultsIterator`1.Current">
            <summary>
Gets the element in the collection at the current
position of the enumerator.
</summary>
            <returns>
The element in the collection at the current position
of the enumerator.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.SelectResultsIterator`1">
            <summary>
Iterator for a query result.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultCollector`1.SetSPGeneric(gemfire.ResultCollector*)">
            <summary>
Used to assign the native CqListener pointer to a new object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultCollector`1.AssignSPGeneric(gemfire.ResultCollector*)">
            <summary>
Used to assign the native Serializable pointer to a new object.
</summary>
            <remarks>
Note the order of preserveSB() and releaseSB(). This handles the
corner case when <c>m_nativeptr</c> is same as <c>nativeptr</c>.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultCollector`1.#ctor(gemfire.ResultCollector*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultCollector`1.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultCollector`1.EndResults">
            <summary>
Call back provided to caller, which is called after function execution is
complete and caller can retrieve results using getResult()
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultCollector`1.GetResult(System.UInt32)">
            <summary>
get result 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultCollector`1.GetResult">
            <summary>
get result 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultCollector`1.AddResult(`0)">
            <summary>
add result from a single function execution
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ResultCollector`1">
            <summary>
collect function execution results, default collector
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectXml.#ctor(System.Object)">
            <summary>
Allocates a new instance from the given object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectXml.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableObjectXml.Value">
            <summary>
Gets the object value.
</summary>
            <remarks>
The user can modify the object and the changes shall be reflected
immediately in the local cache. For this change to be propagate to
other members of the distributed system, the object needs to be
put into the cache.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableObjectXml.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableObjectXml.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectXml.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserializes the <see cref="T:System.Object" /> using
<see cref="T:System.Xml.Serialization.XmlSerializer" /> class.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectXml.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this <see cref="T:System.Object" /> using
<see cref="T:System.Xml.Serialization.XmlSerializer" /> class.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectXml.Create(System.Object)">
            <summary>
Static function to create a new instance from the given object.
</summary>
            <remarks>
If the given object is null then this method returns null.
</remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableObjectXml">
            <summary>
A mutable generic <see cref="T:System.Object" /> wrapper that can
serve as a distributable value for caching.
</summary>
            <remarks>
                <para>
This class can contain any object and uses the
<see cref="T:System.Xml.Serialization.XmlSerializer" /> to
serialize and deserialize the object. So the user must use the
<c>XmlSerializer</c> attributes to control the serialization/deserialization
of the object (or implement the <see cref="T:System.Xml.Serialization.IXmlSerializable" />)
to change the serialization/deserialization. However, the latter should
be avoided for efficiency reasons and the user should implement
<see cref="!:../../IGFSerializable" /> instead.
</para>
                <para>
The user must keep in mind that the rules that apply to <c>XmlSerializer</c>
would be the rules that apply to this class. For instance the user
cannot pass objects of class implementing or containing
<see cref="T:System.Collections.IDictionary" /> class, must use
<see cref="T:System.Xml.Serialization.XmlIncludeAttribute" /> to
mark user-defined types etc.
</para>
            </remarks>
        </member>
        <member name="F:gemfire.ManagedResultCollector.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheListener
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedResultCollector.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedResultCollector.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedResultCollector.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedResultCollector</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheListener</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>IResultCollector</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedResultCollector.#ctor(GemStone.GemFire.Cache.IResultCollector)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedResultCollector">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IResultCollector" />
object and implements the native <c>gemfire::ResultCollector</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultCollector.SetSP(gemfire.ResultCollector*)">
            <summary>
Used to assign the native CqListener pointer to a new object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultCollector.AssignSP(gemfire.ResultCollector*)">
            <summary>
Used to assign the native Serializable pointer to a new object.
</summary>
            <remarks>
Note the order of preserveSB() and releaseSB(). This handles the
corner case when <c>m_nativeptr</c> is same as <c>nativeptr</c>.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultCollector.#ctor(gemfire.ResultCollector*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultCollector.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultCollector.EndResults">
            <summary>
Call back provided to caller, which is called after function execution is
complete and caller can retrieve results using getResult()
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultCollector.GetResult(System.UInt32)">
            <summary>
get result 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultCollector.GetResult">
            <summary>
get result 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultCollector.AddResult(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
add result from a single function execution
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.ResultCollector">
            <summary>
collect function execution results, default collector
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IResultCollector.ClearResults">
            <summary>
GemFire will invoke this method before re-executing function (in case of
Function Execution HA) This is to clear the previous execution results from
the result collector
@since 6.5
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IResultCollector.EndResults">
            <summary>
Call back provided to caller, which is called after function execution is
complete and caller can retrieve results using getResult()
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IResultCollector.GetResult(System.UInt32)">
            <summary>
get result 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IResultCollector.GetResult">
            <summary>
get result 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IResultCollector.AddResult(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
add result from a single function execution
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.IResultCollector">
            <summary>
collect function execution results, can be overriden 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.#ctor(gemfire_statistics.Statistics*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.Create(gemfire_statistics.Statistics*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncDouble(System.String,System.Double)">
            <summary>
Increments the value of the statistic of type <c>double</c> with
the given name by a given amount.
</summary>
            <param name="name">statistic name</param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncDouble(GemStone.GemFire.Cache.StatisticDescriptor,System.Double)">
            <summary>
Increments the value of the described statistic of type <c>double</c>
by the given amount.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncDouble(System.Int32,System.Double)">
            <summary>
Increments the value of the identified statistic of type <c>double</c>
by the given amount.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="delta">the value of the statistic after it has been incremented</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncLong(System.String,System.Int64)">
            <summary>
Increments the value of the statistic of type <c>long</c> with
the given name by a given amount.
</summary>
            <param name="name">statistic name</param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncLong(GemStone.GemFire.Cache.StatisticDescriptor,System.Int64)">
            <summary>
Increments the value of the described statistic of type <c>long</c>
by the given amount.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncLong(System.Int32,System.Int64)">
            <summary>
Increments the value of the identified statistic of type <c>long</c>
by the given amount.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="delta">the value of the statistic after it has been incremented</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncInt(System.String,System.Int32)">
            <summary>
Increments the value of the statistic of type <c>int</c> with
the given name by a given amount.
</summary>
            <param name="name">statistic name</param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncInt(GemStone.GemFire.Cache.StatisticDescriptor,System.Int32)">
            <summary>
Increments the value of the described statistic of type <c>int</c>
by the given amount.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="delta">change value to be added</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.IncInt(System.Int32,System.Int32)">
            <summary>
Increments the value of the identified statistic of type <c>int</c>
by the given amount.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="delta">the value of the statistic after it has been incremented</param>
            <returns>the value of the statistic after it has been incremented</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetRawBits(GemStone.GemFire.Cache.StatisticDescriptor)">
            <summary>
Returns the bits that represent the raw value of the described statistic.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the described statistic does not exist
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetDouble(System.String)">
            <summary>
Returns the value of the statistic of type <c>double</c> at
the given name.
</summary>
            <param name="name">statistic name</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetDouble(GemStone.GemFire.Cache.StatisticDescriptor)">
            <summary>
Returns the value of the described statistic of type <c>double</c>.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists with the specified <c>descriptor</c> or
if the described statistic is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetDouble(System.Int32)">
            <summary>
Returns the value of the identified statistic of type <c>double</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetLong(System.String)">
            <summary>
Returns the value of the statistic of type <c>long</c> at
the given name.
</summary>
            <param name="name">statistic name</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetLong(GemStone.GemFire.Cache.StatisticDescriptor)">
            <summary>
Returns the value of the described statistic of type <c>long</c>.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists with the specified <c>descriptor</c> or
if the described statistic is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetLong(System.Int32)">
            <summary>
Returns the value of the identified statistic of type <c>long</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetInt(System.String)">
            <summary>
Returns the value of the statistic of type <code>int</code> at
the given name.
</summary>
            <param name="name">statistic name</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetInt(GemStone.GemFire.Cache.StatisticDescriptor)">
            <summary>
Returns the value of the described statistic of type <code>int</code>.
</summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists with the specified <c>descriptor</c> or
if the described statistic is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.GetInt(System.Int32)">
            <summary>
Returns the value of the identified statistic of type <c>int</c>.
whose type is <c>double</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetDouble(GemStone.GemFire.Cache.StatisticDescriptor,System.Double)">
            <summary>
Sets the value of a described statistic of type <c>double</c></summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetDouble(System.String,System.Double)">
            <summary>
Sets the value of a named statistic of type <c>double</c></summary>
            <param name="name">statistic name</param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>double</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetDouble(System.Int32,System.Double)">
            <summary>
Sets the value of a statistic with the given <c>id</c>
whose type is <c>double</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetLong(System.String,System.Int64)">
            <summary>
Sets the value of a named statistic of type <c>long</c>.
</summary>
            <param name="name">statistic name</param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetLong(GemStone.GemFire.Cache.StatisticDescriptor,System.Int64)">
            <summary>
Sets the value of a described statistic of type <c>long</c></summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:StatisticsType#nameToDescriptor" /></param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>long</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetLong(System.Int32,System.Int64)">
            <summary>
Sets the value of a statistic with the given <c>id</c>
whose type is <c>long</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" /> 
or <see cref="!:#StatisticsType#nameToId" />. </param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetInt(GemStone.GemFire.Cache.StatisticDescriptor,System.Int32)">
            <summary>
Sets the value of a described statistic of type <c>int</c></summary>
            <param name="descriptor">a statistic descriptor obtained with <see cref="!:#nameToDescriptor" />
or <see cref="!:#StatisticsType#nameToDescriptor" /></param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists for the given <c>descriptor</c> or
if the described statistic is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetInt(System.String,System.Int32)">
            <summary>
Sets the value of a named statistic of type <c>int</c></summary>
            <param name="name">statistic name</param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If no statistic exists named <c>name</c> or
if the statistic with name <c>name</c> is not of
type <c>int</c>.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.SetInt(System.Int32,System.Int32)">
            <summary>
Sets the value of a statistic with the given <c>id</c>
whose type is <c>int</c>.
</summary>
            <param name="id">a statistic id obtained with <see cref="!:#nameToId" />
or <see cref="!:#StatisticsType#nameToId" /></param>
            <param name="value">value to set</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the id is invalid.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Statistics.IsClosed">
            <summary>
Returns true if the instance has been <see cref="!:#close" /> closed.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Statistics.IsShared">
            <summary>
Returns true if the data for this instance is stored in shared memory.
Returns false if the data is store in local memory.
</summary>
            <para>
Note that all instances that are <see cref="!:#isShared" /> shared are also atomic.
</para>
        </member>
        <member name="P:GemStone.GemFire.Cache.Statistics.IsAtomic">
            <summary>
Returns true if modifications are atomic. This means that multiple threads
can safely modify this instance without additional synchronization.
</summary>
            <para>
Returns false if modifications are not atomic. This means that modifications
to this instance are cheaper but not thread safe.
</para>
            <para>
Note that all instances that are <see cref="!:#isShared" /> shared are also atomic.
</para>
        </member>
        <member name="P:GemStone.GemFire.Cache.Statistics.NumericId">
            <summary>
Gets the number associated with this instance that helps identify it.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Statistics.TextId">
            <summary>
Gets the text associated with this instance that helps identify it.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Statistics.Type">
            <summary>
Gets the <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> of this instance.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Statistics.UniqueId">
            <summary>
Gets a value that uniquely identifies this statistics.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.NameToDescriptor(System.String)">
            <summary>
Returns the descriptor of the statistic with the given name in this
statistics instance.
</summary>
            <param name="name">the statistic name</param>
            <returns>the descriptor of the statistic with the given name</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if no statistic named <c>name</c> exists in this
statistics instance.
</exception>
            <see cref="!:StatisticsType#nameToId" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.NameToId(System.String)">
            <summary>
Returns the id of the statistic with the given name in this
statistics instance.
</summary>
            <param name="name">the statistic name</param>
            <returns>the id of the statistic with the given name</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if no statistic named <c>name</c> exists in this
statistics instance.
</exception>
            <see cref="!:StatisticsType#nameToDescriptor" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Statistics.Close">
            <summary>
Closes these statistics.  After statistics have been closed, they
are no longer archived.
A value access on a closed statistics always results in zero.
A value modification on a closed statistics is ignored.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Statistics">
            <summary>
An instantiation of an existing <c>StatisticsType</c> object with methods for
setting, incrementing and getting individual <c>StatisticDescriptor</c> values.
</summary>
            <para>
The class is purposefully inherited from UMWrapN and not UMWrap as the destructor
of the class is protected, and so it is now not called from inside the InternalCleanup
method.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.#ctor(gemfire_statistics.StatisticsFactory*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.Create(gemfire_statistics.StatisticsFactory*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticsFactory.ID">
            <summary>
Returns a numeric id that can be used to identify the manager
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticsFactory.Name">
            <summary>
Returns a name that can be used to identify the manager
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.FindFirstStatisticsByType(GemStone.GemFire.Cache.StatisticsType)">
            <summary>
Return the first instance that matches the type, or NULL
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateAtomicStatistics(GemStone.GemFire.Cache.StatisticsType,System.String,System.Int64)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> type, <c>textId</c>, and <c>numericId</c>.
</summary>
            <para>
The created instance will be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateAtomicStatistics(GemStone.GemFire.Cache.StatisticsType,System.String)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> type, <c>textId</c>, and with a default numeric id.
</summary>
            <para>
The created instance will be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateAtomicStatistics(GemStone.GemFire.Cache.StatisticsType)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> type, <c>textId</c>, and with default ids.
</summary>
            <para>
The created instance will be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateStatistics(GemStone.GemFire.Cache.StatisticsType,System.String,System.Int64)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> type, <c>textId</c>, and <c>numericId</c>.
</summary>
            <para>
The created instance may not be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateStatistics(GemStone.GemFire.Cache.StatisticsType,System.String)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> type, <c>textId</c>, and with a default numeric id.
</summary>
            <para>
The created instance may not be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateStatistics(GemStone.GemFire.Cache.StatisticsType)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.Statistics" /> instance of the given <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> type, <c>textId</c>, and with default ids.
</summary>
            <para>
The created instance may not be <see cref="!:Statistics#isAtomic" /> atomic.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.FindType(System.String)">
            <summary>
Finds and returns an already created <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> 
with the given <c>name</c>. Returns <c>null</c> if the type does not exist.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateType(System.String,System.String,GemStone.GemFire.Cache.StatisticDescriptor[],System.Int32)">
            <summary>
Creates and returns a <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> 
with the given <c>name</c>, <c>description</c>,and <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" /></summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if a type with the given <c>name</c> already exists.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateDoubleGauge(System.String,System.String,System.String)">
            <summary>
Creates and returns an double gauge <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateDoubleGauge(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an double gauge <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with smaller values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateLongGauge(System.String,System.String,System.String)">
            <summary>
Creates and returns an long gauge <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateLongGauge(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an long gauge <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with smaller values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateIntGauge(System.String,System.String,System.String)">
            <summary>
Creates and returns an int gauge  <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateIntGauge(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an int gauge  <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with smaller values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateDoubleCounter(System.String,System.String,System.String)">
            <summary>
Creates and returns an double counter  <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateDoubleCounter(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an double counter  <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with larger values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateLongCounter(System.String,System.String,System.String)">
            <summary>
Creates and returns an long counter  <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateLongCounter(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an long counter  <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with larger values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateIntCounter(System.String,System.String,System.String)">
            <summary>
Creates and returns an int counter  <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.CreateIntCounter(System.String,System.String,System.String,System.SByte)">
            <summary>
Creates and returns an int counter  <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
with the given <c>name</c>, <c>description</c>,
<c>units</c>, and with larger values indicating better performance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsFactory.GetExistingInstance">
            <summary>
Return a pre-existing statistics factory. Typically configured through
creation of a distributed system.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.StatisticsFactory">
            <summary>
Instances of this interface provide methods that create instances
of <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" /> and <see cref="T:GemStone.GemFire.Cache.StatisticsType" />.
Every <see cref="T:GemStone.GemFire.Cache.StatisticsFactory" /> is also a type factory.
</summary>
            <para>
A <c>StatisticsFactory</c> can create a <see cref="T:GemStone.GemFire.Cache.StatisticDescriptor" />
statistic of three numeric types:
<c>int</c>, <c>long</c>, and <c>double</c>.  A
statistic (<c>StatisticDescriptor</c>) can either be a
<I>gauge</I> meaning that its value can increase and decrease or a
<I>counter</I> meaning that its value is strictly increasing.
Marking a statistic as a counter allows the GemFire Manager Console
to properly display a statistics whose value "wraps around" (that
is, exceeds its maximum value).
</para>
        </member>
        <member name="M:gemfire_statistics.StatisticsFactory.getId">
Returns a numeric id that can be used to identify the manager

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.getName">
Returns a name that can be used to identify the manager

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.findFirstStatisticsByType(gemfire_statistics.StatisticsType*)">
Return the first instance that matches the type, or NULL 
</member>
        <member name="M:gemfire_statistics.StatisticsFactory.findType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Finds and returns an already created {@link StatisticsType}
with the given <code>name</code>.
Returns <code>null</code> if the type does not exist.

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.createType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire_statistics.StatisticDescriptor**,System.Int32)">
Creates  and returns a {@link StatisticsType}
with the given <code>name</code>, <code>description</code>,
and {@link StatisticDescriptor}.
@throws IllegalArgumentException
if a type with the given <code>name</code> already exists.

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.createDoubleGauge(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte)">
Creates and returns an double gauge {@link StatisticDescriptor}
with the given <code>name</code>, <code>description</code>,
<code>units</code>,  and with smaller values indicating better performance.

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.createLongGauge(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte)">
Creates and returns an long gauge {@link StatisticDescriptor}
with the given <code>name</code>, <code>description</code>,
<code>units</code>,  and with smaller values indicating better performance.

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.createIntGauge(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte)">
Creates and returns an int gauge {@link StatisticDescriptor}
with the given <code>name</code>, <code>description</code>,
<code>units</code>,  and with smaller values indicating better performance.

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.createDoubleCounter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte)">
Creates and returns an int gauge {@link StatisticDescriptor}
with the given <code>name</code>, <code>description</code>,
<code>units</code>,  and with smaller values indicating better performance.

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.createLongCounter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte)">
 Creates and returns a double counter {@link StatisticDescriptor}
 with the given <code>name</code>, <code>description</code>,
<code>units</code>, and with larger values indicating better performance.

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.createIntCounter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte)">
Creates and returns a long counter {@link StatisticDescriptor}
with the given <code>name</code>, <code>description</code>,
<code>units</code>,and with larger values indicating better performance.

</member>
        <member name="M:gemfire_statistics.StatisticsFactory.getExistingInstance">
Return a pre-existing statistics factory. Typically configured through
creation of a distributed system.

</member>
        <member name="M:gemfire_statistics.Statistics.Dispose">
Destructor is protected to prevent direct deletion. Use close().

</member>
        <member name="M:gemfire_statistics.Statistics.incDouble(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Double)">
 Increments the value of the statistic of type <code>double</code> with
 the given name by a given amount.
 @param name statistic name
 @param delta change value to be added

 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If no statistic exists with name <code>name</code> or
         if the statistic named <code>name</code> is not of
         type <code>double</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.incDouble(gemfire_statistics.StatisticDescriptor*,System.Double)">
 Increments the value of the described statistic of type <code>double</code>
 by the given amount.
 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @param delta change value to be added

 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If no statistic exists with the given <code>descriptor</code> or
         if the described statistic is not of
         type <code>double</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.incDouble(System.Int32,System.Double)">
 Increments the value of the identified statistic of type <code>double</code>
 by the given amount.

 @param id a statistic id obtained with {@link #nameToId}
 or {@link StatisticsType#nameToId}.
 @param delta change value to be added

 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.incLong(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int64)">
 Increments the value of the statistic of type <code>long</code> with
 the given name by a given amount.

 @param name statistic name
 @param delta change value to be added
 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If no statistic exists with name <code>name</code> or
         if the statistic named <code>name</code> is not of
         type <code>long</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.incLong(gemfire_statistics.StatisticDescriptor*,System.Int64)">
 Increments the value of the described statistic of type <code>long</code>
 by the given amount.

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @param delta change value to be added
 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If no statistic exists with the given <code>descriptor</code> or
         if the described statistic is not of
         type <code>long</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.incLong(System.Int32,System.Int64)">
 Increments the value of the identified statistic of type <code>long</code>
 by the given amount.

 @param id a statistic id obtained with {@link #nameToId}
 or {@link StatisticsType#nameToId}.
 @param delta change value to be added

 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.incInt(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
 Increments the value of the statistic of type <code>int</code> with
 the given name by a given amount.
 @param name statistic name
 @param delta change value to be added
 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If no statistic exists with name <code>name</code> or
         if the statistic named <code>name</code> is not of
         type <code>int</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.incInt(gemfire_statistics.StatisticDescriptor*,System.Int32)">
 Increments the value of the described statistic of type <code>int</code>
 by the given amount.
 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @param delta change value to be added
 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If no statistic exists with the given <code>descriptor</code> or
         if the described statistic is not of
         type <code>int</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.incInt(System.Int32,System.Int32)">
 Returns the bits that represent the raw value of the named statistic.

 @throws IllegalArgumentException
         If the named statistic does not exist

 Increments the value of the identified statistic of type <code>int</code>
 by the given amount.

 @param id a statistic id obtained with {@link #nameToId}
 or {@link StatisticsType#nameToId}.
 @param delta change value to be added

 @return The value of the statistic after it has been incremented

 @throws IllegalArgumentException
         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.getRawBits(gemfire_statistics.StatisticDescriptor*)">
 Returns the value of the identified statistic.

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @throws IllegalArgumentException
         If the described statistic does not exist

 Returns the value of the named statistic.

 @throws IllegalArgumentException
         If the named statistic does not exist

 Returns the bits that represent the raw value of the described statistic.

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @throws IllegalArgumentException
         If the described statistic does not exist

</member>
        <member name="M:gemfire_statistics.Statistics.getDouble(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
 Returns the value of the statistic of type <code>double</code> at
 the given name.
 @param name statistic name

 @throws IllegalArgumentException
         If no statistic exists with name <code>name</code> or
         if the statistic named <code>name</code> is not of
         type <code>double</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.getDouble(gemfire_statistics.StatisticDescriptor*)">
 Returns the value of the described statistic of type <code>double</code>.

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @throws IllegalArgumentException
         If no statistic exists with the specified <code>descriptor</code> or
         if the described statistic is not of
         type <code>double</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.getDouble(System.Int32)">
 Returns the value of the identified statistic of type <code>double</code>.

 @param id a statistic id obtained with {@link #nameToId}
 or {@link StatisticsType#nameToId}.
 @throws IllegalArgumentException
         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.getLong(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
 Returns the value of the statistic of type <code>long</code> at
 the given name.

 @param name statistic name
 @throws IllegalArgumentException
         If no statistic exists with name <code>name</code> or
         if the statistic named <code>name</code> is not of
         type <code>long</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.getLong(gemfire_statistics.StatisticDescriptor*)">
 Returns the value of the described statistic of type <code>long</code>.

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @throws IllegalArgumentException
         If no statistic exists with the specified <code>descriptor</code> or
         if the described statistic is not of
         type <code>long</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.getLong(System.Int32)">
 Returns the value of the identified statistic of type <code>long</code>.

 @param id a statistic id obtained with {@link #nameToId}
 or {@link StatisticsType#nameToId}.
 @throws IllegalArgumentException
         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.getInt(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
 Returns the value of the statistic of type <code>int</code> at
 the given name.
 @param name statistic name

 @throws IllegalArgumentException
         If no statistic exists with name <code>name</code> or
         if the statistic named <code>name</code> is not of
         type <code>int</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.getInt(gemfire_statistics.StatisticDescriptor*)">
 Returns the value of the described statistic of type <code>int</code>.

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @throws IllegalArgumentException
         If no statistic exists with the specified <code>descriptor</code> or
         if the described statistic is not of
         type <code>int</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.getInt(System.Int32)">
 Returns the value of the identified statistic of type <code>int</code>.

 @param id a statistic id obtained with {@link #nameToId}
 or {@link StatisticsType#nameToId}.
 @throws IllegalArgumentException
         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.setDouble(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Double)">
 Sets the value of a named statistic of type <code>double</code>.

 @param name statistic name
 @param value value to set
 @throws IllegalArgumentException
         If no statistic exists named <code>name</code> or
         if the statistic with name <code>name</code> is not of
         type <code>double</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.setDouble(gemfire_statistics.StatisticDescriptor*,System.Double)">
 Sets the value of a described statistic of type <code>double</code>

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @param value value to set
 @throws IllegalArgumentException
         If no statistic exists for the given <code>descriptor</code> or
         if the described statistic is not of
         type <code>double</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.setDouble(System.Int32,System.Double)">
 Sets the value of a statistic with the given <code>id</code>
 whose type is <code>double</code>.
 @param id a statistic id obtained with {@link #nameToId}
 or {@link StatisticsType#nameToId}.
 @param value value to set

 @throws IllegalArgumentException
         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.setLong(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int64)">
 Sets the value of a named statistic of type <code>long</code>.

 @param name statistic name
 @param value value to set
 @throws IllegalArgumentException
         If no statistic exists named <code>name</code> or
         if the statistic with name <code>name</code> is not of
         type <code>long</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.setLong(gemfire_statistics.StatisticDescriptor*,System.Int64)">
 Sets the value of a described statistic of type <code>long</code>

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @param value value to set
 @throws IllegalArgumentException
         If no statistic exists for the given <code>descriptor</code> or
         if the described statistic is not of
         type <code>long</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.setLong(System.Int32,System.Int64)">
 Sets the value of a statistic with the given <code>id</code>
 whose type is <code>long</code>.
 @param id a statistic id obtained with {@link #nameToId}
 or {@link StatisticsType#nameToId}.
 @param value value to set

 @throws IllegalArgumentException
         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.setInt(gemfire_statistics.StatisticDescriptor*,System.Int32)">
 Sets the value of a described statistic of type <code>int</code>

 @param descriptor a statistic descriptor obtained with {@link #nameToDescriptor}
 or {@link StatisticsType#nameToDescriptor}.
 @param value value to set
 @throws IllegalArgumentException
         If no statistic exists for the given <code>descriptor</code> or
         if the described statistic is not of
         type <code>int</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.setInt(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
 Sets the value of a named statistic of type <code>int</code>

 @param name statistic name
 @param value value to set
 @throws IllegalArgumentException
         If no statistic exists named <code>name</code> or
         if the statistic with name <code>name</code> is not of
         type <code>int</code>.

</member>
        <member name="M:gemfire_statistics.Statistics.setInt(System.Int32,System.Int32)">
    * Sets the value of a statistic with the given <code>id</code>
   * whose type is <code>int</code>.
   * @param id a statistic id obtained with {@link #nameToId}
   * or {@link StatisticsType#nameToId}.
   * @param value value to set
   *
   * @throws IllegalArgumentException
   *         If the id is invalid.

</member>
        <member name="M:gemfire_statistics.Statistics.isClosed">
Returns true if the instance has been {@link #close closed}.

</member>
        <member name="M:gemfire_statistics.Statistics.getNumericId">
Gets the number associated with this instance that helps identify it.

</member>
        <member name="M:gemfire_statistics.Statistics.getTextId">
Gets the text associated with this instance that helps identify it.

</member>
        <member name="M:gemfire_statistics.Statistics.getType">
Gets the {@link StatisticsType} of this instance.

</member>
        <member name="M:gemfire_statistics.Statistics.getUniqueId">
Gets a value that uniquely identifies this statistics.

</member>
        <member name="M:gemfire_statistics.Statistics.nameToDescriptor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Returns the descriptor of the statistic with the given name in this
 statistics instance.

 @param name statistic name
 @throws IllegalArgumentException
         No statistic named <code>name</code> exists in this
         statistics instance.

 @see StatisticsType#nameToId

</member>
        <member name="M:gemfire_statistics.Statistics.nameToId(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Returns the id of the statistic with the given name in this
 statistics instance.

 @param name statistic name
 @throws IllegalArgumentException
         No statistic named <code>name</code> exists in this
         statistics instance.

 @see StatisticsType#nameToDescriptor

</member>
        <member name="M:gemfire_statistics.Statistics.close">
Closes these statistics.  After statistics have been closed, they
are no longer archived.
A value access on a closed statistics always results in zero.
A value modification on a closed statistics is ignored.

</member>
        <member name="T:gemfire_statistics.Statistics">
An instantiation of an existing <code>StatisticsType</code> object with methods for
setting, incrementing and getting individual <code>StatisticDescriptor</code> values.

</member>
        <member name="M:GemStone.GemFire.Cache.CqStatistics.#ctor(gemfire.CqStatistics*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqStatistics.Create(gemfire.CqStatistics*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqStatistics.numEvents">
            <summary>
get number of events qualified by this Cq
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqStatistics.numUpdates">
            <summary>
get number of updates qualified by this Cq
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqStatistics.numDeletes">
            <summary>
get number of deletes qualified by this Cq
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqStatistics.numInserts">
            <summary>
get number of inserts qualified by this Cq
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqStatistics">
            <summary>
Defines common statistical information for a cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesMutator.#ctor(gemfire.CqAttributesMutator*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesMutator.Create(gemfire.CqAttributesMutator*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesMutator.SetCqListeners(GemStone.GemFire.Cache.ICqListener[])">
            <summary>
Initialize with an array of listeners
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesMutator.RemoveCqListener(GemStone.GemFire.Cache.ICqListener)">
            <summary>
Remove a CqListener for the cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesMutator.AddCqListener(GemStone.GemFire.Cache.ICqListener)">
            <summary>
Adds the CqListener for the cq.
</summary>
            <param name="cqListener">
user-defined cq listener, or null for no cache listener
</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqAttributesMutator">
            <summary>
Supports modification of certain cq attributes after the cq
has been created.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.SelectResultsIterator.#ctor(gemfire.SelectResultsIterator*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.SelectResultsIterator.Create(gemfire.SelectResultsIterator*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SelectResultsIterator.HasNext">
            <summary>
Check if there is a next element.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.SelectResultsIterator.Next">
            <summary>
Get the current element and move to the next one.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.SelectResultsIterator.Reset">
            <summary>
Sets the enumerator to its initial position, which is before
the first element in the collection.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.SelectResultsIterator.MoveNext">
            <summary>
Advances the enumerator to the next element of the collection.
</summary>
            <returns>
true if the enumerator was successfully advanced to the next
element; false if the enumerator has passed the end of
the collection.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SelectResultsIterator.Current">
            <summary>
Gets the element in the collection at the current
position of the enumerator.
</summary>
            <returns>
The element in the collection at the current position
of the enumerator.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.SelectResultsIterator">
            <summary>
Iterator for a query result.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqServiceStatistics.#ctor(gemfire.CqServiceStatistics*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqServiceStatistics.Create(gemfire.CqServiceStatistics*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqServiceStatistics.numCqsOnClient">
            <summary>
Get number of CQs that are currently active or stopped. 
The CQs included in this number are either running or stopped (suspended).
Closed CQs are not included.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqServiceStatistics.numCqsStopped">
            <summary>
Get the number of stopped CQs currently.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqServiceStatistics.numCqsClosed">
            <summary>
Get the total number of closed CQs. This is a cumulative number.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqServiceStatistics.numCqsCreated">
            <summary>
Get the total number of CQs created. This is a cumulative number.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqServiceStatistics.numCqsActive">
            <summary>
Get the number of CQs currently active. 
Active CQs are those which are executing (in running state).
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqServiceStatistics">
            <summary>
Defines common statistical information for cqservice 
</summary>
        </member>
        <member name="F:gemfire.ManagedCqListenerGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheListener
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCqListenerGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCqListenerGeneric.onError(gemfire.CqEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCqListenerGeneric.onEvent(gemfire.CqEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <param name="ev">
Denotes the event object associated with the entry creation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCqListenerGeneric.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedCqListenerGeneric.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedCacheListener</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheListener</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>ICacheListener</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedCqListenerGeneric.#ctor(System.Object)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="userptr">
The user object.
</param>
        </member>
        <member name="T:gemfire.ManagedCqListenerGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.ICacheListener" />
object and implements the native <c>gemfire::CacheListener</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICqListener`2.Close">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources,
such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICqListener`2.OnError(GemStone.GemFire.Cache.Generic.CqEvent`2{`0,`1})">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICqListener`2.OnEvent(GemStone.GemFire.Cache.Generic.CqEvent`2{`0,`1})">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <param name="ev">
Denotes the event object associated with the entry creation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ICqListener`2">
            <summary>
An application plug-in that can be installed on a region.
Listener change notifications are invoked <c>after</c>
the change has occured.
</summary>
            <remarks>
Listeners receive notifications when entries in a region change or changes occur to the
region attributes themselves.
<para>
A cache listener is defined in the <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />.
</para>
The methods on a <c>ICacheListener</c>
are invoked asynchronously. Multiple events can cause concurrent invocation
of <c>ICacheListener</c> methods.  If event A occurs before event B,
there is no guarantee that their corresponding <c>ICacheListener</c>
method invocations will occur in the same order.  Any exceptions thrown by
the listener are caught by GemFire and logged. 

Listeners are user callbacks that
are invoked by GemFire. It is important to ensure that minimal work is done in the
listener before returning control back to GemFire. For example, a listener
implementation may choose to hand off the event to a thread pool that then processes
the event on its thread rather than the listener thread
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheLoader" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheWriter" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StructSet`1.#ctor(gemfire.StructSet*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StructSet`1.Create(gemfire.StructSet*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StructSet`1.GetEnumerator">
            <summary>
Returns an enumerator that iterates through the <c>StructSet</c>.
</summary>
            <returns>
A <c>System.Collections.Generic.IEnumerator</c> that
can be used to iterate through the <c>StructSet</c>.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StructSet`1.GetFieldName(System.UInt32)">
            <summary>
Get the field name of the <c>StructSet</c> from the
specified index number.
</summary>
            <param name="index">
the index number of the field name to get.
</param>
            <returns>
the field name from the specified index number or null if not found.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StructSet`1.GetFieldIndex(System.String)">
            <summary>
Get the index number of the specified field name
in the <c>StructSet</c>.
</summary>
            <param name="fieldName">
the field name for which the index is required.
</param>
            <returns>the index number of the specified field name.</returns>
            <exception cref="!:IllegalArgumentException">
if the field name is not found.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.StructSet`1.GetIterator">
            <summary>
Get a <c>SelectResultsIterator</c> with which to iterate
over the items in the <c>StructSet</c>.
</summary>
            <returns>
The <c>SelectResultsIterator</c> with which to iterate.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StructSet`1.Item(System.UInt32)">
            <summary>
Index operator to directly access an item in the <c>StructSet</c>.
</summary>
            <exception cref="!:IllegalArgumentException">
if the index is out of bounds.
</exception>
            <returns>Item at the given index.</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StructSet`1.Size">
            <summary>
The size of the <c>StructSet</c>.
</summary>
            <returns>
the number of items in the <c>StructSet</c>.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.StructSet`1.IsModifiable">
            <summary>
True if this <c>StructSet</c> is modifiable.
</summary>
            <returns>returns false always at this time.</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.StructSet`1">
            <summary>
Encapsulates a query struct set.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ICqResults`1">
            <summary>
Interface to encapsulate a select query result set.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultSet`1.#ctor(gemfire.ResultSet*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultSet`1.Create(gemfire.ResultSet*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultSet`1.GetEnumerator">
            <summary>
Returns an enumerator that iterates through the collection.
</summary>
            <returns>
A <c>System.Collections.Generic.IEnumerator</c> that
can be used to iterate through the <c>ResultSet</c>.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ResultSet`1.GetIterator">
            <summary>
Get an iterator for the result set.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.ResultSet`1.Item(System.UInt32)">
            <summary>
Get an object at the given index.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.ResultSet`1.Size">
            <summary>
The size of the <c>ResultSet</c>.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.ResultSet`1.IsModifiable">
            <summary>
True if this <c>ResultSet</c> is modifiable.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ResultSet`1">
            <summary>
Encapsulates a query result set.
It specifies the interface for the resultset obtained from the
Gemfire cache server
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISelectResults`1.GetIterator">
            <summary>
Get an iterator for the result set.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.ISelectResults`1.Item(System.UInt32)">
            <summary>
Get an object at the given index.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.ISelectResults`1.Size">
            <summary>
The size of the <c>ISelectResults</c>.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.ISelectResults`1.IsModifiable">
            <summary>
True if this <c>ISelectResults</c> is modifiable.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ISelectResults`1">
            <summary>
Interface to encapsulate a select query result set.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqStatistics.#ctor(gemfire.CqStatistics*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqStatistics.Create(gemfire.CqStatistics*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqStatistics.numEvents">
            <summary>
get number of events qualified by this Cq
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqStatistics.numUpdates">
            <summary>
get number of updates qualified by this Cq
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqStatistics.numDeletes">
            <summary>
get number of deletes qualified by this Cq
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqStatistics.numInserts">
            <summary>
get number of inserts qualified by this Cq
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqStatistics">
            <summary>
Defines common statistical information for a cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesMutator`2.#ctor(gemfire.CqAttributesMutator*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesMutator`2.Create(gemfire.CqAttributesMutator*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesMutator`2.SetCqListeners(GemStone.GemFire.Cache.Generic.ICqListener`2{`0,`1}[])">
            <summary>
Initialize with an array of listeners
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesMutator`2.RemoveCqListener(GemStone.GemFire.Cache.Generic.ICqListener`2{`0,`1})">
            <summary>
Remove a CqListener for the cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributesMutator`2.AddCqListener(GemStone.GemFire.Cache.Generic.ICqListener`2{`0,`1})">
            <summary>
Adds the CqListener for the cq.
</summary>
            <param name="cqListener">
user-defined cq listener, or null for no cache listener
</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqAttributesMutator`2">
            <summary>
Supports modification of certain cq attributes after the cq
has been created.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributes`2.#ctor(gemfire.CqAttributes*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributes`2.Create(gemfire.CqAttributes*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqAttributes`2.getCqListeners">
            <summary>
get all listeners in this attributes
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqAttributes`2">
            <summary>
Defines attributes for configuring a cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Query`1.#ctor(gemfire.Query*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Query`1.Create(gemfire.Query*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Query`1.IsCompiled">
            <summary>
Check if the query is compiled -- NOT IMPLEMENTED.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Query`1.Compile">
            <summary>
Compile the given query -- NOT IMPLEMENTED.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Query`1.QueryString">
            <summary>
Get the string for this query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Query`1.Execute(System.Object[])">
            <summary>
Executes the OQL Parameterized Query on the cache server with the specified
paramList and returns the results. The default timeout for the query is 15 secs.
</summary>
            <param name="paramList">The Parameter List for the specified Query.
</param>
            <exception cref="!:IllegalArgumentException">
if timeout parameter is greater than 2^31/1000.
</exception>
            <exception cref="!:QueryException">
if some query error occurred at the server.
</exception>
            <exception cref="!:IllegalStateException">
if some other error occurred.
</exception>
            <exception cref="!:NotConnectedException">
if no java cache server is available
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <returns>
An <see cref="T:GemStone.GemFire.Cache.Generic.ISelectResults`1" /> object which can either be a
<see cref="T:GemStone.GemFire.Cache.StructSet" /> or a <see cref="T:GemStone.GemFire.Cache.StructSet" />.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Query`1.Execute(System.UInt32)">
            <summary>
Executes the OQL Query on the cache server with the specified
timeout and returns the results.
</summary>
            <param name="timeout">The time (in seconds) to wait for query response.
This should be less than or equal to 2^31/1000 i.e. 2147483.
</param>
            <exception cref="!:IllegalArgumentException">
if timeout parameter is greater than 2^31/1000.
</exception>
            <exception cref="!:QueryException">
if some query error occurred at the server.
</exception>
            <exception cref="!:IllegalStateException">
if some other error occurred.
</exception>
            <exception cref="!:NotConnectedException">
if no java cache server is available
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <returns>
An <see cref="T:GemStone.GemFire.Cache.Generic.ISelectResults`1" /> object which can either be a
<see cref="T:GemStone.GemFire.Cache.StructSet" /> or a <see cref="T:GemStone.GemFire.Cache.StructSet" />.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Query`1.Execute">
            <summary>
Executes the OQL Query on the cache server and returns
the results. The default timeout for the query is 15 secs.
</summary>
            <exception cref="!:QueryException">
if some query error occurred at the server.
</exception>
            <exception cref="!:IllegalStateException">
if some other error occurred.
</exception>
            <exception cref="!:NotConnectedException">
if no java cache server is available.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <returns>
An <see cref="T:GemStone.GemFire.Cache.Generic.ISelectResults`1" /> object which can either be a
<see cref="T:GemStone.GemFire.Cache.StructSet" /> or a <see cref="T:GemStone.GemFire.Cache.StructSet" />.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Query`1">
            <summary>
Class to encapsulate a query.
</summary>
            <remarks>
A Query is obtained from a QueryService which in turn is obtained
from the Cache.
This can be executed to return SelectResults which can be either
a ResultSet or a StructSet.

This class is intentionally not thread-safe. So multiple threads
should not operate on the same <c>Query</c> object concurrently
rather should have their own <c>Query</c> objects.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableUndefined.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableUndefined.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableUndefined.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableUndefined.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableUndefined.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableUndefined.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableUndefined.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableUndefined">
            <summary>
Encapsulate an undefined result.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteArrayOfByteArrays(System.String,System.Byte[][])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="byteArrays">The byteArrays to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteObjectArray(System.String,System.Collections.Generic.List`1{System.Object^})">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="objectArray">The objectArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteStringArray(System.String,System.String[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="stringArray">The stringArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteDoubleArray(System.String,System.Double[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="doubleArray">The doubleArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteFloatArray(System.String,System.Single[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="floatArray">The floatArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteUnsignedLongArray(System.String,System.UInt64[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="ulongArray">The ulongArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteLongArray(System.String,System.Int64[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="longArray">The longArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteUnsignedIntArray(System.String,System.UInt32[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="uintArray">The uintArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteIntArray(System.String,System.Int32[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="intArray">The intArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteUnsignedShortArray(System.String,System.UInt16[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="ushortArray">The ushortArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteShortArray(System.String,System.Int16[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="shortArray">The shortArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteSByteArray(System.String,System.SByte[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="sbyteArray">The sbyteArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteByteArray(System.String,System.Byte[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="byteArray">The byteArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteCharArray(System.String,System.Char[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="charArray">The charArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteBooleanArray(System.String,System.Boolean[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="boolArray">The boolArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteDate(System.String,System.DateTime)">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="date">The date to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteCollection(System.String,System.Collections.IList)">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="collection">The collection to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteObject(System.String,System.Object)">
            <summary>
Write an <c>Object</c> object to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteASCIIHuge(System.String,System.String)">
            <summary>
Write a string(only ASCII char) to
<c>IPdxWriter</c>.
Length should be more than 2^16 -1.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteUTFHuge(System.String,System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>IPdxWriter</c>.
Length should be more than 2^16 -1. 
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteString(System.String,System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>IPdxWriter</c>.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteDouble(System.String,System.Double)">
            <summary>
Write a double precision real number to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">
The double precision real number to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteFloat(System.String,System.Single)">
            <summary>
Write a float to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The float value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteLong(System.String,System.Int64)">
            <summary>
Write a 64-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteInt(System.String,System.Int32)">
            <summary>
Write a 32-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteShort(System.String,System.Int16)">
            <summary>
Write a 16-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteUInt64(System.String,System.UInt64)">
            <summary>
Write an unsigned 64-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteUInt32(System.String,System.UInt32)">
            <summary>
Write an unsigned 32-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteUInt16(System.String,System.UInt16)">
            <summary>
Write an unsigned short integer (int16_t) to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteChar(System.String,System.Char)">
            <summary>
Write a char value to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The char value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteBoolean(System.String,System.Boolean)">
            <summary>
Write a boolean value to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The boolean value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteSByte(System.String,System.SByte)">
            <summary>
Write a signed byte to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The signed byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteWriter.WriteByte(System.String,System.SByte)">
            <summary>
Write a byte to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadArrayOfByteArrays(System.String)">
            <summary>
Read a two-dimenesional byte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadObjectArray(System.String)">
            <summary>
Read a object array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadStringArray(System.String)">
            <summary>
Read a string array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadDoubleArray(System.String)">
            <summary>
Read a double array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadFloatArray(System.String)">
            <summary>
Read a float from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadUnsignedLongArray(System.String)">
            <summary>
Read a ulong array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadLongArray(System.String)">
            <summary>
Read a long array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadUnsignedIntArray(System.String)">
            <summary>
Read a uint from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadIntArray(System.String)">
            <summary>
Read a int array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadUnsignedShortArray(System.String)">
            <summary>
Read a ushort array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadShortArray(System.String)">
            <summary>
Read a short from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadSByteArray(System.String)">
            <summary>
Read a sbyte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadByteArray(System.String)">
            <summary>
Read a byte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadCharArray(System.String)">
            <summary>
Read a char array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadBooleanArray(System.String)">
            <summary>
Read a boolean array from the data. 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadDate(System.String)">
            <summary>
Read a Date from the data. 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadCollection(System.String,System.Collections.IList)">
            <summary>
Read a collection from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadObject(System.String)">
            <summary>
Read a serializable object from the data. Null objects are handled.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadASCIIHuge(System.String)">
            <summary>
Read a ASCII string from the stream. Where size is more than 2^16-1 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadUTFHuge(System.String)">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadString(System.String)">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadDouble(System.String)">
            <summary>
Read a double precision number from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadFloat(System.String)">
            <summary>
Read a floating point number from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadLong(System.String)">
            <summary>
Read a 64-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadInt(System.String)">
            <summary>
Read a 32-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadShort(System.String)">
            <summary>
Read a 16-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadUInt64(System.String)">
            <summary>
Read a 64-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadUInt32(System.String)">
            <summary>
Read a 32-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadUInt16(System.String)">
            <summary>
Read a 16-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadChar(System.String)">
            <summary>
Read a char value from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadBoolean(System.String)">
            <summary>
Read a boolean value from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadSByte(System.String)">
            <summary>
Read a signed byte from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxRemoteReader.ReadByte(System.String)">
            <summary>
Read a byte from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteArrayOfByteArrays(System.String,System.Byte[][])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="byteArrays">The byteArrays to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteObjectArray(System.String,System.Collections.Generic.List`1{System.Object^})">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="objectArray">The objectArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteStringArray(System.String,System.String[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="stringArray">The stringArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteDoubleArray(System.String,System.Double[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="doubleArray">The doubleArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteFloatArray(System.String,System.Single[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="floatArray">The floatArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteUnsignedLongArray(System.String,System.UInt64[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="ulongArray">The ulongArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteLongArray(System.String,System.Int64[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="longArray">The longArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteUnsignedIntArray(System.String,System.UInt32[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="uintArray">The uintArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteIntArray(System.String,System.Int32[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="intArray">The intArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteUnsignedShortArray(System.String,System.UInt16[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="ushortArray">The ushortArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteShortArray(System.String,System.Int16[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="shortArray">The shortArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteSByteArray(System.String,System.SByte[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="sbyteArray">The sbyteArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteByteArray(System.String,System.Byte[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="byteArray">The byteArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteCharArray(System.String,System.Char[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="charArray">The charArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteBooleanArray(System.String,System.Boolean[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="boolArray">The boolArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteDate(System.String,System.DateTime)">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="date">The date to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteCollection(System.String,System.Collections.IList)">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="collection">The collection to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteObject(System.String,System.Object)">
            <summary>
Write an <c>Object</c> object to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteASCIIHuge(System.String,System.String)">
            <summary>
Write a string(only ASCII char) to
<c>IPdxWriter</c>.
Length should be more than 2^16 -1.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteUTFHuge(System.String,System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>IPdxWriter</c>.
Length should be more than 2^16 -1. 
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteString(System.String,System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>IPdxWriter</c>.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteDouble(System.String,System.Double)">
            <summary>
Write a double precision real number to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">
The double precision real number to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteFloat(System.String,System.Single)">
            <summary>
Write a float to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The float value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteLong(System.String,System.Int64)">
            <summary>
Write a 64-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteInt(System.String,System.Int32)">
            <summary>
Write a 32-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteShort(System.String,System.Int16)">
            <summary>
Write a 16-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteUInt64(System.String,System.UInt64)">
            <summary>
Write an unsigned 64-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteUInt32(System.String,System.UInt32)">
            <summary>
Write an unsigned 32-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteUInt16(System.String,System.UInt16)">
            <summary>
Write an unsigned short integer (int16_t) to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteChar(System.String,System.Char)">
            <summary>
Write a char value to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The char value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteBoolean(System.String,System.Boolean)">
            <summary>
Write a boolean value to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The boolean value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteSByte(System.String,System.SByte)">
            <summary>
Write a signed byte to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The signed byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxWriterWithTypeCollector.WriteByte(System.String,System.SByte)">
            <summary>
Write a byte to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteArrayOfByteArrays(System.String,System.Byte[][])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="byteArrays">The byteArrays to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteObjectArray(System.String,System.Collections.Generic.List`1{System.Object^})">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="objectArray">The objectArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteStringArray(System.String,System.String[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="stringArray">The stringArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteDoubleArray(System.String,System.Double[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="doubleArray">The doubleArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteFloatArray(System.String,System.Single[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="floatArray">The floatArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteUnsignedLongArray(System.String,System.UInt64[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="ulongArray">The ulongArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteLongArray(System.String,System.Int64[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="longArray">The longArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteUnsignedIntArray(System.String,System.UInt32[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="uintArray">The uintArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteIntArray(System.String,System.Int32[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="intArray">The intArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteUnsignedShortArray(System.String,System.UInt16[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="ushortArray">The ushortArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteShortArray(System.String,System.Int16[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="shortArray">The shortArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteSByteArray(System.String,System.SByte[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="sbyteArray">The sbyteArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteByteArray(System.String,System.Byte[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="byteArray">The byteArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteCharArray(System.String,System.Char[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="charArray">The charArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteBooleanArray(System.String,System.Boolean[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="boolArray">The boolArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteDate(System.String,System.DateTime)">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="date">The date to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteCollection(System.String,System.Collections.IList)">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="collection">The collection to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteObject(System.String,System.Object)">
            <summary>
Write an <c>Object</c> object to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteASCIIHuge(System.String,System.String)">
            <summary>
Write a string(only ASCII char) to
<c>IPdxWriter</c>.
Length should be more than 2^16 -1.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteUTFHuge(System.String,System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>IPdxWriter</c>.
Length should be more than 2^16 -1. 
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteString(System.String,System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>IPdxWriter</c>.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteDouble(System.String,System.Double)">
            <summary>
Write a double precision real number to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">
The double precision real number to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteFloat(System.String,System.Single)">
            <summary>
Write a float to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The float value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteLong(System.String,System.Int64)">
            <summary>
Write a 64-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteInt(System.String,System.Int32)">
            <summary>
Write a 32-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteShort(System.String,System.Int16)">
            <summary>
Write a 16-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteUInt64(System.String,System.UInt64)">
            <summary>
Write an unsigned 64-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteUInt32(System.String,System.UInt32)">
            <summary>
Write an unsigned 32-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteUInt16(System.String,System.UInt16)">
            <summary>
Write an unsigned short integer (int16_t) to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The unsigned 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteChar(System.String,System.Char)">
            <summary>
Write a char value to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The char value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteBoolean(System.String,System.Boolean)">
            <summary>
Write a boolean value to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The boolean value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteSByte(System.String,System.SByte)">
            <summary>
Write a signed byte to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The signed byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteByte(System.String,System.SByte)">
            <summary>
Write a byte to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.SystemProperties.#ctor(gemfire.SystemProperties*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.SystemProperties.Create(gemfire.SystemProperties*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.ConflateEvents">
            <summary>
Returns the conflate event's option
</summary>
            <returns>the conflate event option</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.ConnectTimeout">
            <summary>
Returns the connect timeout used for server and locator handshakes.
</summary>
            <returns>the connect timeout used for server and locator handshakes</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.DurableTimeout">
            <summary>
Returns the durable client's timeout.
</summary>
            <returns>the durable client timeout</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.DurableClientId">
            <summary>
Returns the durable client's ID.
</summary>
            <returns>the durable client ID</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.GetSecurityProperties">
            <summary>
Returns all the security properties
</summary>
            <returns>the security properties</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.IsSecurityOn">
            <summary>
True if client needs to be authenticated
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.SSLTrustStore">
            <summary>
Returns the SSL public certificate trust store file path.
</summary>
            <returns>the SSL public certificate trust store file path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.SSLKeyStore">
            <summary>
Returns the SSL private keystore file path.
</summary>
            <returns>the SSL private keystore file path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.SSLEnabled">
            <summary>
True if ssl connection support is enabled.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.MaxQueueSize">
            <summary>
Returns the max queue size for notification messages
</summary>
            <returns>the max queue size</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.StatsDiskSpaceLimit">
            <summary>
Returns the maximum statistics Disk size, in bytes, or 0 if unlimited.
</summary>
            <returns>the maximum limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.StatsFileSizeLimit">
            <summary>
Returns the maximum statistics file size, in bytes, or 0 if unlimited.
</summary>
            <returns>the maximum limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.LogDiskSpaceLimit">
            <summary>
Returns the maximum log Disk size, in bytes, or 0 if unlimited.
</summary>
            <returns>the maximum limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.LogFileSizeLimit">
            <summary>
Returns the maximum log file size, in bytes, or 0 if unlimited.
</summary>
            <returns>the maximum limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.CacheXmlFile">
            <summary>
Returns the name of the "cache.xml" file.
</summary>
            <returns>the filename</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.Name">
            <summary>
Returns the system name.
</summary>
            <returns>the name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.AppDomainEnabled">
            <summary>
Whether client is running in multiple AppDomain or not.
Default value is "false".
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.CrashDumpEnabled">
            <summary>
True if the crash dump generation for unhandled fatal exceptions
is enabled. If "log-file" property has been specified then they are
created in the same directory as the log file, and having the same
prefix as log file. By default crash dumps are created in the
current working directory and have the "gemfire_cpp" prefix.

The actual dump file will have timestamp and process ID
in the full name.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.DebugStackTraceEnabled">
            <summary>
True if the stack trace is enabled.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.NotifyDupCheckLife">
            <summary>
Returns the expiry time of an idle event id map entry for duplicate notification checking
</summary>
            <returns>the NotifyDupCheckLife value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.NotifyAckInterval">
            <summary>
Returns the periodic notify ack interval
</summary>
            <returns>the NotifyAckInterval value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.RedundancyMonitorInterval">
            <summary>
Returns  the time between two consecutive checks for redundancy for HA
</summary>
            <returns>the RedundancyMonitorInterval value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.PingInterval">
            <summary>
Returns  the time between two consecutive ping to servers
</summary>
            <returns>the PingInterval value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.MaxSocketBufferSize">
            <summary>
Returns  the maximum socket buffer size to use
</summary>
            <returns>the MaxSocketBufferSize value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.HeapLRUDelta">
            <summary>
Returns  the HeapLRUDelta value (a percent value). This specifies the
percentage of entries the system will evict each time it detects that
it has exceeded the HeapLRULimit. Defaults to 10%
</summary>
            <returns>the HeapLRUDelta value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.HeapLRULimit">
            <summary>
Returns  the HeapLRULimit value (in bytes), the maximum memory that values
in a cache can use to store data before overflowing to disk or destroying
entries to ensure that the server process never runs out of memory due to
cache memory usage
</summary>
            <returns>the HeapLRULimit value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.HeapLRULimitEnabled">
            <summary>
Returns  a boolean that specifies if heapLRULimit has been enabled for the
process. If enabled, the HeapLRULimit specifies the maximum amount of memory
that values in a cache can use to store data before overflowing to disk or
destroying entries to ensure that the server process never runs out of
memory
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.GFLogLevel">
            <summary>
Returns the message logging level.
</summary>
            <returns>the log level</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.LogFileName">
            <summary>
Returns the name of the message log file.
</summary>
            <returns>the filename</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.StatisticsArchiveFile">
            <summary>
Returns the name of the statistics archive file.
</summary>
            <returns>the filename</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.StatisticsEnabled">
            <summary>
True if statistics are enabled (archived).
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.SystemProperties.StatisticsSampleInterval">
            <summary>
Returns the sampling interval, that is,
how often the statistics thread writes to disk, in seconds.
</summary>
            <returns>the statistics sampling interval</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.SystemProperties.LogSettings">
            <summary>
Prints all settings to the process log.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.SystemProperties.#ctor(GemStone.GemFire.Cache.Properties,System.String)">
            <summary>
Constructor.
<ol><li>Sets the default (hard-coded) values.</li><li>Overwrites those with any values from <c>systemDefault/gfcpp.properties</c></li><li>Overwrites those with any values from the given file (if it exists)
or the local <c>./gfcpp.properties</c> (if the given file does not exist).</li><li>Overwrites those with any values found in the given properties.</li></ol></summary>
            <param name="properties">these overwrite any other values already set</param>
            <param name="configFile">see summary</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.SystemProperties.#ctor(GemStone.GemFire.Cache.Properties)">
            <summary>
Constructor. Sets the default (hard-coded) values first, and then overwrites those with
any values found in the given properties.
</summary>
            <param name="properties">initialize with the given properties</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.SystemProperties">
            <summary>
A class for internal use, that encapsulates the properties that can be
set through <see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" />
or a gfcpp.properties file.
</summary>
        </member>
        <member name="M:gemfire.SystemProperties.getAuthLoader">
Gets the authInitialize loader for the system.
   * @return  a pointer that points to the system's ,
   * <code>AuthLoader</code> , NULLPTR if there is no AuthLoader for this
   * system.

</member>
        <member name="M:gemfire.SystemProperties.processProperty(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Processes the given property/value pair, saving
the results internally:

</member>
        <member name="M:gemfire.SystemProperties.autoReadyForEvents">
Whether a non durable client starts to receive and process
subscription events automatically.
If set to false then a non durable client should call the
Cache::readyForEvents() method after all regions are created
and listeners attached for the client to start receiving events
whether the client is initialized programmatically or declaratively.
@return the value of the property.

</member>
        <member name="M:gemfire.SystemProperties.isAppDomainEnabled">
This property checks whether C# client is running in multiple appdoamin or not.
Default value is "false".

</member>
        <member name="M:gemfire.SystemProperties.isGridClient">
 Checks to see if this native client is being invoked as part of small
 grid jobs; use this setting to disable some creation of threads and
 reducing start/stop time. Note that this setting can cause improper
 behaviour in some cases like:
  1) client that is setup in listening mode and a server failure may not
     lead to failover by client
  2) while shutting down the client will not send a proper CLOSE_CONNECTION
     message so server will report EOF exceptions and may detect client
     disconnect after quite some time
 Also note that there may be some performance loss in queries and
 Region::getAll due to unavailability of parallel processing threads.

 @return true if the "grid-client" property is set

</member>
        <member name="M:gemfire.SystemProperties.isDhOn">
Check whether Diffie-Hellman based credentials encryption is on.
@return bool flag to indicate whether DH for credentials is on.

</member>
        <member name="M:gemfire.SystemProperties.isEndpointShufflingDisabled">
Checks whether list of endpoint is shuffeled or not.
   * @return  bool value.

</member>
        <member name="M:gemfire.SystemProperties.isSecurityOn">
Checks whether Security is on or off.
   * @return  bool value.

</member>
        <member name="M:gemfire.SystemProperties.getSecurityProperties">
Returns securityPropertiesPtr.
   * @return  PropertiesPtr value.

</member>
        <member name="M:gemfire.SystemProperties.securityClientKsPath">
Return the keystore (.pem file ) path 
</member>
        <member name="M:gemfire.SystemProperties.securityClientDhAlgo">
Return the security diffie hellman secret key algo 
</member>
        <member name="M:gemfire.SystemProperties.authInitFactory">
Return the security auth factory 
</member>
        <member name="M:gemfire.SystemProperties.authInitLibrary">
Return the security auth library 
</member>
        <member name="M:gemfire.SystemProperties.statsDiskSpaceLimit">
Returns the stat-disk-size-limit.

</member>
        <member name="M:gemfire.SystemProperties.statsFileSizeLimit">
Returns the stat-file-space-limit.

</member>
        <member name="M:gemfire.SystemProperties.logDiskSpaceLimit">
Returns the log-disk-space-limit.

</member>
        <member name="M:gemfire.SystemProperties.logFileSizeLimit">
Returns the log-file-size-limit.

</member>
        <member name="M:gemfire.SystemProperties.crashDumpEnabled">
Returns true if crash dump generation for unhandled fatal errors
is enabled, false otherwise.
By default crash dumps are created in the current working directory.
If log-file has been specified then they are created in the same
directory as the log file, and having the same prefix as log file.
The default prefix is "gemfire_cpp".
The actual dump file will have timestamp and process ID in the full name.

</member>
        <member name="M:gemfire.SystemProperties.debugStackTraceEnabled">
Returns  true if the stack trace is enabled ,false otherwise

</member>
        <member name="M:gemfire.SystemProperties.conflateEvents">
Returns client Queueconflation option

</member>
        <member name="M:gemfire.SystemProperties.connectTimeout">
Returns the connect timeout used for server and locator handshakes

</member>
        <member name="M:gemfire.SystemProperties.durableTimeout">
Returns the durable timeout

</member>
        <member name="M:gemfire.SystemProperties.durableClientId">
Returns the durable client ID

</member>
        <member name="M:gemfire.SystemProperties.notifyDupCheckLife">
Returns the expiry time of an idle event id map entry for duplicate notification checking

</member>
        <member name="M:gemfire.SystemProperties.notifyAckInterval">
Returns the periodic notify ack interval

</member>
        <member name="M:gemfire.SystemProperties.redundancyMonitorInterval">
Returns  the time between two consecutive checks for redundancy for HA

</member>
        <member name="M:gemfire.SystemProperties.pingInterval">
Returns  the time between two consecutive ping to servers

</member>
        <member name="M:gemfire.SystemProperties.maxSocketBufferSize">
Returns  the maximum socket buffer size to use

</member>
        <member name="M:gemfire.SystemProperties.heapLRUDelta">
Returns  the HeapLRUDelta value (a percent value). This specifies the
percentage of entries the system will evict each time it detects that
it has exceeded the HeapLRULimit. Defaults to 10%

</member>
        <member name="M:gemfire.SystemProperties.heapLRULimit">
 Returns  the HeapLRULimit value (in bytes), the maximum memory that values
 in a cache can use to store data before overflowing to disk or destroying
 entries to ensure that the server process never runs out of memory due to
 cache memory usage


</member>
        <member name="M:gemfire.SystemProperties.heapLRULimitEnabled">
 Returns  a boolean that specifies if heapLRULimit has been enabled for the
 process. If enabled, the HeapLRULimit specifies the maximum amount of memory
 that values in a cache can use to store data before overflowing to disk or
 destroying entries to ensure that the server process never runs out of
 memory


</member>
        <member name="M:gemfire.SystemProperties.logLevel">
Returns the log level at which logging would be done.

</member>
        <member name="M:gemfire.SystemProperties.logFilename">
Returns the name of the filename into which logging would
be done.

</member>
        <member name="M:gemfire.SystemProperties.statisticsArchiveFile">
Returns the name of the filename into which statistics would
be archived.

</member>
        <member name="M:gemfire.SystemProperties.sslTrustStore">
Returns the path of the public key file for SSL use.

</member>
        <member name="M:gemfire.SystemProperties.sslKeyStore">
Returns the path of the private key file for SSL use.

</member>
        <member name="M:gemfire.SystemProperties.getEnableTimeStatistics">
Whether time stats are enabled for the statistics.

</member>
        <member name="M:gemfire.SystemProperties.sslEnabled">
Whether SSL is enabled for socket connections.

</member>
        <member name="M:gemfire.SystemProperties.statisticsEnabled">
Tells whether statistics needs to be archived or not.

</member>
        <member name="M:gemfire.SystemProperties.statisticsSampleInterval">
Returns the sampling interval of the sampling thread.
This would be how often the statistics thread writes to disk in seconds.

</member>
        <member name="M:gemfire.SystemProperties.logSettings">
print all settings to the process log. 
</member>
        <member name="M:gemfire.SystemProperties.Dispose">
Destructor.

</member>
        <member name="M:gemfire.SystemProperties.#ctor(gemfire.SharedPtr&lt;gemfire.Properties&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Constructor. Will set the default values first, and then overwrite with
 the values found in the given Properties object (if any), and
 then from the values in the given file (if it exists).

 If useMemType is true, use the given member type; if false, always set member type to SERVER.

</member>
        <member name="D:gemfire.LibraryAuthInitializeFn">
 The SystemProperties class

 @author Neeraj Kumar

</member>
        <member name="M:GemStone.GemFire.Cache.CacheAttributes.#ctor(gemfire.CacheAttributes*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheAttributes.Create(gemfire.CacheAttributes*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheAttributes.Endpoints">
            <summary>
Gets cache level endpoints list.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheAttributes.RedundancyLevel">
            <summary>
Gets redundancy level for regions in the cache.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheAttributes">
            <summary>
Defines attributes for configuring a cache.
</summary>
            <remarks>
Currently the following attributes are defined:
<c>redundancyLevel</c>: Redundancy for HA client queues.
<c>endpoints</c>: Cache level endpoints list.
To create an instance of this interface, use
<see cref="M:GemStone.GemFire.Cache.CacheAttributesFactory.CreateCacheAttributes" />.

For compatibility rules and default values, see
<see cref="T:GemStone.GemFire.Cache.CacheAttributesFactory" />.

Note that the <c>CacheAttributes</c> are not distributed with
the region.
</remarks>
            <seealso cref="T:GemStone.GemFire.Cache.CacheAttributesFactory" />
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.#ctor(gemfire.CacheFactory*,GemStone.GemFire.Cache.Properties)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.Set(System.String,System.String)">
            <summary>
Sets a gemfire property that will be used when creating the ClientCache.
</summary>
            <param>
name the name of the gemfire property
</param>
            <param>
value the value of the gemfire property
</param>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetMultiuserAuthentication(System.Boolean)">
            <summary>
Sets whether pool is in multiuser mode
</summary>
            <param>
multiuserAuthentication should be true/false. Default value is false;
</param>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetSubscriptionAckInterval(System.Int32)">
            <summary>
Sets the is the interval in milliseconds to wait before sending
acknowledgements to the bridge server for events received from the server subscriptions.
</summary>
            <param>
ackInterval number of milliseconds to wait before sending event acknowledgements.
</param>
            <exception>
throws IllegalArgumentException if ackInterval is less than or equal to 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetSubscriptionMessageTrackingTimeout(System.Int32)">
            <summary>
Sets the messageTrackingTimeout attribute which is the time-to-live period,
in milliseconds, for subscription events the client has received from the server.
</summary>
            <remarks>
It's used to minimize duplicate events. Entries that have not been modified
for this amount of time are expired from the list.
</remarks>
            <param>
messageTrackingTimeout number of milliseconds to set the timeout to.
</param>
            <exception>
throws IllegalArgumentException if messageTrackingTimeout is less than or equal to 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetSubscriptionRedundancy(System.Int32)">
            <summary>
Sets the redundancy level for this pools server-to-client subscriptions.
</summary>
            <remarks>
If 0 then no redundant copies will be kept on the servers.
Otherwise an effort will be made to maintain the requested number of
copies of the server-to-client subscriptions. At most one copy per server will
be made up to the requested level.
</remarks>
            <param>
redundancy the number of redundant servers for this client's subscriptions.
</param>
            <exception>
throws IllegalArgumentException if redundancyLevel is less than -1.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetSubscriptionEnabled(System.Boolean)">
            <summary>
Enable subscriptions.
</summary>
            <remarks>
If set to true then the created pool will have server-to-client
subscriptions enabled. If set to false then all Subscription*
attributes are ignored at create time.
</remarks>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.AddServer(System.String,System.Int32)">
            <summary>
Add a server, given its host and port, to this factory.
</summary>
            <remarks>
The server must be a bridge server and this client will
directly connect to without consulting a server locator.
</remarks>
            <param>
host the host name or ip address that the server is listening on.
</param>
            <param>
port the port that the server is listening on
</param>
            <exception>
throws IllegalArgumentException if host is an unknown host
or if port is outside the valid range of [1..65535] inclusive.
</exception>
            <exception>
throws IllegalStateException if a server has already been added to this factory.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.AddLocator(System.String,System.Int32)">
            <summary>
Add a locator, given its host and port, to this factory.
</summary>
            <remarks>
The locator must be a server locator and will be used to discover other running
bridge servers and locators.
</remarks>
            <param>
host the host name or ip address that the locator is listening on.
</param>
            <param>
port the port that the locator is listening on
</param>
            <exception>
throws IllegalArgumentException if host is an unknown host
or if port is outside the valid range of [1..65535] inclusive.
</exception>
            <exception>
throws IllegalStateException if a locator has already been added to this factory.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetServerGroup(System.String)">
            <summary>
Configures the group that all servers this pool connects to must belong to.
</summary>
            <param>
group the server group that this pool will connect to.
If null or "" then all servers will be connected to.
</param>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetStatisticInterval(System.Int32)">
            <summary>
Set how often to send client statistics to the server.
</summary>
            <remarks>
Doing this allows gfmon to monitor clients.
A value of -1 disables the sending of client statistics
to the server.
</remarks>
            <param>
statisticInterval The amount of time in milliseconds between
sends of client statistics to the server.
</param>
            <exception>
throws IllegalArgumentException if statisticInterval
is less than -1.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetPingInterval(System.Int32)">
            <summary>
Set how often to ping servers to verify that they are still alive.
</summary>
            <remarks>
Each server will be sent a ping every pingInterval if there has not
been any other communication with the server.
These pings are used by the server to monitor the health of
the client. Make sure that the pingInterval is less than the
maximum time between pings allowed by the bridge server.
see in CacheServer: setMaximumTimeBetweenPings(int)
</remarks>
            <param>
pingInterval The amount of time in milliseconds between pings.
</param>
            <exception>
throws IllegalArgumentException if pingInterval is less than 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetRetryAttempts(System.Int32)">
            <summary>
Set the number of times to retry a request after timeout/exception.
</summary>
            <param>
retryAttempts The number of times to retry a request
after timeout/exception. -1 indicates that a request should be
tried against every available server before failing.
</param>
            <exception>
throws IllegalArgumentException if idleTimout is less than 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetIdleTimeout(System.Int32)">
            <summary>
Set the amount of time a connection can be idle before expiring the connection.
</summary>
            <remarks>
If the pool size is greater than the minimum specified, connections which have
been idle for longer than the idleTimeout will be closed.
</remarks>
            <param>
idleTimeout The amount of time in milliseconds that an idle connection
should live before expiring. -1 indicates that connections should never expire.
</param>
            <exception>
throws IllegalArgumentException if idleTimout is less than 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetMaxConnections(System.Int32)">
            <summary>
Set the max number of client to server connections that the pool will create.
</summary>
            <remarks>
If all of the connections are in use, an operation requiring a client to
server connection will block until a connection is available.
see setFreeConnectionTimeout(int)
</remarks>
            <param>
maxConnections the maximum number of connections in the pool.
-1 indicates that there is no maximum number of connections.
</param>
            <exception>
throws IllegalArgumentException if maxConnections is less than minConnections.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetMinConnections(System.Int32)">
            <summary>
Set the minimum number of connections to keep available at all times.
</summary>
            <remarks>
When the pool is created, it will create this many connections.
If 0 then connections will not be made until an actual operation
is done that requires client-to-server communication.
</remarks>
            <param>
minConnections the initial number of connections this pool will create.
</param>
            <exception>
throws IllegalArgumentException if minConnections is less than 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetReadTimeout(System.Int32)">
            <summary>
Sets the number of milliseconds to wait for a response from a server before
timing out the operation and trying another server (if any are available).
</summary>
            <param>
timeout number of milliseconds to wait for a response from a server
</param>
            <exception>
throws IllegalArgumentException if timeout
is less than or equal to 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetSocketBufferSize(System.Int32)">
            <summary>
Sets the socket buffer size for each connection made in this pool.
</summary>
            <remarks>
Large messages can be received and sent faster when this buffer is larger.
Larger buffers also optimize the rate at which servers can send events
for client subscriptions.
</remarks>
            <param>
bufferSize the size of the socket buffers used for reading and
writing on each connection in this pool.
</param>
            <exception>
throws IllegalArgumentException if bufferSize
is less than or equal to 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetLoadConditioningInterval(System.Int32)">
            <summary>
Sets the load conditioning interval for this pool.
</summary>
            <remarks>
This interval controls how frequently the pool will check to see if
a connection to a given server should be moved to a different
server to improve the load balance.
</remarks>
            <param>
loadConditioningInterval the connection lifetime in milliseconds
A value of -1 disables load conditioning.
</param>
            <exception>
throws IllegalArgumentException if connectionLifetime
is less than -1.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetFreeConnectionTimeout(System.Int32)">
            <summary>
Sets the free connection timeout for this pool.
</summary>
            <remarks>
If the pool has a max connections setting, operations will block
if all of the connections are in use. The free connection timeout
specifies how long those operations will block waiting for
a free connection before receiving an AllConnectionsInUseException.
If max connections is not set this setting has no effect.
</remarks>
            <param>
connectionTimeout the connection timeout in milliseconds
</param>
            <exception>
IllegalArgumentException if connectionTimeout 
is less than or equal to 0.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheFactory.ProductDescription">
            <summary>
Returns the product description string including product name and version.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheFactory.Version">
            <summary>
Returns the version of the cache implementation.
For the 1.0 release of GemFire, the string returned is <c>1.0</c>.
</summary>
            <returns>the version of the cache implementation as a <c>String</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.SetNewAndDelete">
            <summary>
Set allocators for non default Microsoft CRT versions.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.GetAnyInstance">
            <summary>
Gets an arbitrary open instance of <see cref="T:GemStone.GemFire.Cache.Cache" /> produced by an
earlier call to <see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" />.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if a cache has not been created or the only created one is
closed ( <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> )
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if a cache with specified system not found
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.GetInstanceCloseOk(GemStone.GemFire.Cache.DistributedSystem)">
            <summary>
Gets the instance of <see cref="T:GemStone.GemFire.Cache.Cache" /> produced by an
earlier call to <see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" />, even if it has been closed.
</summary>
            <param name="system">
the <see cref="T:GemStone.GemFire.Cache.DistributedSystem" /> the cache was created with.
</param>
            <returns>
the <c>Cache</c> associated with the specified system.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the distributed system argument is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if a cache has not been created.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if a cache with specified system not found
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.GetInstance(GemStone.GemFire.Cache.DistributedSystem)">
            <summary>
Gets the instance of <see cref="T:GemStone.GemFire.Cache.Cache" /> produced by an
earlier call to <see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" />.
</summary>
            <param name="system">
the <see cref="T:GemStone.GemFire.Cache.DistributedSystem" /> the cache was created with.
</param>
            <returns>the <see cref="T:GemStone.GemFire.Cache.Cache" /> associated with the specified system.</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the distributed system argument is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if a cache has not been created or the created one is closed
( <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> )
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if a cache with specified system not found
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.Create(System.String,GemStone.GemFire.Cache.DistributedSystem,System.String,GemStone.GemFire.Cache.CacheAttributes)">
            <summary>
Creates a new cache using the specified system using parameters
from the given <a href="cacheXml.html">XML</a> file and with
the given <c>CacheAttributes</c>.
</summary>
            <param name="name">the name to associate with the new cache</param>
            <param name="system">
a DistributedSystem obtained by calling
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" /></param>
            <param name="cacheXml">
name of the cache configuration XML file
</param>
            <param name="attributes">
optional <c>CacheAttributes</c> for this cache; these
override the ones provided in <c>cacheXml</c>.
</param>
            <returns>
a <c>Cache</c> that uses the specified <c>DistributedSystem</c>
for distribution.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If <c>system</c> is not <see cref="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected" />
or name is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheExistsException">
ff an open cache already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheXmlException">
if something went wrong while parsing the XML
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the XML file is well-formed but not valid (consistent)
</exception>
            <deprecated>
as of NativeClient 3.5, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" /> instead.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.Create(System.String,GemStone.GemFire.Cache.DistributedSystem,GemStone.GemFire.Cache.CacheAttributes)">
            <summary>
Creates a new cache using the specified system using the given
<c>CacheAttributes</c>.
</summary>
            <param name="name">the name to associate with the new cache</param>
            <param name="system">
a DistributedSystem obtained by calling
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" /></param>
            <param name="attributes">
optional <c>CacheAttributes</c> for this cache
</param>
            <returns>
a <c>Cache</c> that uses the specified <c>DistributedSystem</c>
for distribution.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If <c>system</c> is not <see cref="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected" />
or name is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheExistsException">
ff an open cache already exists
</exception>
            <deprecated>
as of NativeClient 3.5, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" /> instead.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.Create(System.String,GemStone.GemFire.Cache.DistributedSystem,System.String)">
            <summary>
Creates a new cache using the specified system using parameters
from the given <a href="cacheXml.html">XML</a> file.
</summary>
            <param name="name">the name to associate with the new cache</param>
            <param name="system">
a DistributedSystem obtained by calling
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" /></param>
            <param name="cacheXml">
name of the cache configuration XML file
</param>
            <returns>
a <c>Cache</c> that uses the specified <c>DistributedSystem</c>
for distribution.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If <c>system</c> is not <see cref="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected" />
or name is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheExistsException">
ff an open cache already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheXmlException">
if something went wrong while parsing the XML
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the XML file is well-formed but not valid (consistent)
</exception>
            <deprecated>
as of NativeClient 3.5, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" /> instead.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.Create(System.String,GemStone.GemFire.Cache.DistributedSystem)">
            <summary>
Creates a new cache using the specified system.
</summary>
            <param name="name">the name to associate with the new cache</param>
            <param name="system">
a DistributedSystem obtained by calling
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" /></param>
            <returns>
a <c>Cache</c> that uses the specified <c>DistributedSystem</c>
for distribution.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If <c>system</c> is not connected
( <see cref="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected" /> ) or name is null.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheExistsException">
If an open cache already exists.
</exception>
            <deprecated>
as of NativeClient 3.5, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" /> instead.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.Create">
            <summary>
To create the instance of <see cref="T:GemStone.GemFire.Cache.Cache" />.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory">
            <summary>
A factory class that must be used to obtain instance of <see cref="T:GemStone.GemFire.Cache.Cache" />.
This should be called once. Using this one can set default values of <see cref="T:GemStone.GemFire.Cache.Pool" />.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)">
            <summary>
A factory class that must be used to obtain instance of <see cref="T:GemStone.GemFire.Cache.Cache" />.
This should be called once. Using this one can set default values of <see cref="T:GemStone.GemFire.Cache.Pool" />.
</summary>
            <param name="dsProps">Properties which are applicable at client level.</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheFactory">
            <summary>
A factory class that must be used to obtain instance of <see cref="T:GemStone.GemFire.Cache.Cache" />.
</summary>
            <remarks>
To create a new cache instance, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" />.
<para>
To get an existing unclosed cache instance, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.GetInstance(GemStone.GemFire.Cache.DistributedSystem)" />.
</para></remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheWriterAdapter">
            <summary>
Utility class that implements all methods in <c>ICacheWriter</c>
with empty implementations. Applications can subclass this class
and only override the methods for the events of interest.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheListenerAdapter">
            <summary>
Utility class that implements all methods in <c>ICacheListener</c>
with empty implementations. Applications can subclass this class
and only override the methods for the events of interest.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheLoaderGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheLoader
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheLoaderGeneric.close(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external
resources, such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <param name="region">the region pointer</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheLoaderGeneric.load(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Loads a value. Application writers should implement this
method to customize the loading of a value.
</summary>
            <remarks>
This method is called by the caching service when the requested
value is not in the cache. Any exception thrown by this method
is propagated back to and thrown by the invocation of
<see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" /> that triggered this load.
</remarks>
            <param name="region">a Region Pointer for which this is called.</param>
            <param name="key">the key for the cacheable</param>
            <param name="aCallbackArgument">any related user data, or null</param>
            <returns>
the value supplied for this key, or null if no value can be
supplied. 
If every available loader returns
a null value, <see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
will return null.
</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheLoaderGeneric.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedCacheLoader</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheLoader</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>ICacheLoader</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedCacheLoaderGeneric.#ctor(System.Object)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="userptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheLoaderGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.ICacheLoader" />
object and implements the native <c>gemfire::CacheLoader</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqServiceStatistics.#ctor(gemfire.CqServiceStatistics*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqServiceStatistics.Create(gemfire.CqServiceStatistics*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqServiceStatistics.numCqsOnClient">
            <summary>
Get number of CQs that are currently active or stopped. 
The CQs included in this number are either running or stopped (suspended).
Closed CQs are not included.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqServiceStatistics.numCqsStopped">
            <summary>
Get the number of stopped CQs currently.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqServiceStatistics.numCqsClosed">
            <summary>
Get the total number of closed CQs. This is a cumulative number.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqServiceStatistics.numCqsCreated">
            <summary>
Get the total number of CQs created. This is a cumulative number.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqServiceStatistics.numCqsActive">
            <summary>
Get the number of CQs currently active. 
Active CQs are those which are executing (in running state).
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqServiceStatistics">
            <summary>
Defines common statistical information for cqservice 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticDescriptor.#ctor(gemfire_statistics.StatisticDescriptor*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticDescriptor.Create(gemfire_statistics.StatisticDescriptor*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticDescriptor.Unit">
            <summary>
Returns the unit in which this statistic is measured.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticDescriptor.IsLargerBetter">
            <summary>
Returns true if a larger statistic value indicates better performance.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticDescriptor.IsCounter">
            <summary>
Returns true if this statistic is a counter; false if its a gauge.
Counter statistics have values that always increase.
Gauge statistics have unconstrained values.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticDescriptor.Description">
            <summary>
Returns the description of this statistic
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticDescriptor.Name">
            <summary>
Returns the name of this statistic
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticDescriptor.ID">
            <summary>
Returns the id of this statistic in a <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> class.
The id is initialized when its statistics
type is created.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.StatisticDescriptor">
            <summary>
A class that describes an individual statistic whose value is updated by an
application and may be archived by GemFire. These descriptions are gathered
together in a <see cref="T:GemStone.GemFire.Cache.StatisticsType" /> class.
</summary>
            <para>
To get an instance of this interface use an instance of
<see cref="T:GemStone.GemFire.Cache.StatisticsFactory" /> class.
</para>
            <para>
StatisticDescriptors are naturally ordered by their name.
</para>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsType.#ctor(gemfire_statistics.StatisticsType*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsType.Create(gemfire_statistics.StatisticsType*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticsType.DescriptorsCount">
            <summary>
Returns the total number of statistics descriptors in the type.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsType.NameToDescriptor(System.String)">
            <summary>
Returns the descriptor of the statistic with the given name in this
statistics instance.
</summary>
            <param name="name">the statistic name</param>
            <returns>the descriptor of the statistic with the given name</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if no statistic named <c>name</c> exists in this
statistic instance.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.StatisticsType.NameToId(System.String)">
            <summary>
Returns the id of the statistic with the given name in this
statistics instance.
</summary>
            <param name="name">the statistic name</param>
            <returns>the id of the statistic with the given name</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if no statistic named <c>name</c> exists in this
statistic instance.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticsType.Statistics">
            <summary>
Returns descriptions of the statistics that this statistics type
gathers together.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticsType.Description">
            <summary>
Returns a description of this statistics type.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.StatisticsType.Name">
            <summary>
Returns the name of this statistics type.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.StatisticsType">
            <summary>
This class is used to describe a logical collection of StatisticDescriptors.These descriptions
are used to create an instance of <see cref="P:GemStone.GemFire.Cache.StatisticsType.Statistics" /> class.
</summary>
            <para>
To get an instance of this interface use an instance of
<see cref="T:GemStone.GemFire.Cache.StatisticsFactory" /> class.
</para>
            <para>
The class is purposefully inherited from UMWrapN and not UMWrap as the destructor
of the class is protected, and so it is now not called from inside the InternalCleanup
method.
</para>
        </member>
        <member name="M:gemfire_statistics.StatisticsType.Dispose">
Destructor

</member>
        <member name="M:gemfire_statistics.StatisticsType.getDescriptorsCount">
Returns the total number of statistics descriptors in the type.

</member>
        <member name="M:gemfire_statistics.StatisticsType.nameToDescriptor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Returns the descriptor of the statistic with the given name in this
 statistics instance.

 @throws IllegalArgumentException
         No statistic named <code>name</code> exists in this
         statistics instance.

</member>
        <member name="M:gemfire_statistics.StatisticsType.nameToId(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Returns the id of the statistic with the given name in this
 statistics instance.

 @throws IllegalArgumentException
         No statistic named <code>name</code> exists in this
         statistics instance.

</member>
        <member name="M:gemfire_statistics.StatisticsType.getStatistics">
Returns descriptions of the statistics that this statistics type
gathers together.

</member>
        <member name="M:gemfire_statistics.StatisticsType.getDescription">
Returns a description of this statistics type.

</member>
        <member name="M:gemfire_statistics.StatisticsType.getName">
Returns the name of this statistics type.

</member>
        <member name="M:gemfire_statistics.StatisticDescriptor.getUnit">
Returns the unit in which this statistic is measured

</member>
        <member name="M:gemfire_statistics.StatisticDescriptor.isLargerBetter">
Returns true if a larger statistic value indicates better performance.

</member>
        <member name="M:gemfire_statistics.StatisticDescriptor.isCounter">
Returns true if this statistic is a counter; false if its a gauge.
Counter statistics have values that always increase.
Gauge statistics have unconstrained values.

</member>
        <member name="M:gemfire_statistics.StatisticDescriptor.getDescription">
Returns a description of this statistic

</member>
        <member name="M:gemfire_statistics.StatisticDescriptor.getName">
Returns the name of this statistic

</member>
        <member name="M:gemfire_statistics.StatisticDescriptor.getId">
Returns the id of this statistic in a {@link StatisticsType
}. The id is initialized when its statistics
type is created.

</member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheAttributes.#ctor(gemfire.CacheAttributes*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheAttributes.Create(gemfire.CacheAttributes*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheAttributes.Endpoints">
            <summary>
Gets cache level endpoints list.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheAttributes.RedundancyLevel">
            <summary>
Gets redundancy level for regions in the cache.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheAttributes">
            <summary>
Defines attributes for configuring a cache.
</summary>
            <remarks>
Currently the following attributes are defined:
<c>redundancyLevel</c>: Redundancy for HA client queues.
<c>endpoints</c>: Cache level endpoints list.
To create an instance of this interface, use
<see cref="M:GemStone.GemFire.Cache.CacheAttributesFactory.CreateCacheAttributes" />.

For compatibility rules and default values, see
<see cref="T:gemfire.CacheAttributesFactory" />.

Note that the <c>CacheAttributes</c> are not distributed with
the region.
</remarks>
            <seealso cref="T:gemfire.CacheAttributesFactory" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.#ctor(gemfire.CacheFactory*,GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.String^})">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.Set(System.String,System.String)">
            <summary>
Sets a gemfire property that will be used when creating the ClientCache.
</summary>
            <param>
name the name of the gemfire property
</param>
            <param>
value the value of the gemfire property
</param>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetMultiuserAuthentication(System.Boolean)">
            <summary>
Sets whether pool is in multiuser mode
</summary>
            <param>
multiuserAuthentication should be true/false. Default value is false;
</param>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetSubscriptionAckInterval(System.Int32)">
            <summary>
Sets the is the interval in milliseconds to wait before sending
acknowledgements to the bridge server for events received from the server subscriptions.
</summary>
            <param>
ackInterval number of milliseconds to wait before sending event acknowledgements.
</param>
            <exception>
throws IllegalArgumentException if ackInterval is less than or equal to 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetSubscriptionMessageTrackingTimeout(System.Int32)">
            <summary>
Sets the messageTrackingTimeout attribute which is the time-to-live period,
in milliseconds, for subscription events the client has received from the server.
</summary>
            <remarks>
It's used to minimize duplicate events. Entries that have not been modified
for this amount of time are expired from the list.
</remarks>
            <param>
messageTrackingTimeout number of milliseconds to set the timeout to.
</param>
            <exception>
throws IllegalArgumentException if messageTrackingTimeout is less than or equal to 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetSubscriptionRedundancy(System.Int32)">
            <summary>
Sets the redundancy level for this pools server-to-client subscriptions.
</summary>
            <remarks>
If 0 then no redundant copies will be kept on the servers.
Otherwise an effort will be made to maintain the requested number of
copies of the server-to-client subscriptions. At most one copy per server will
be made up to the requested level.
</remarks>
            <param>
redundancy the number of redundant servers for this client's subscriptions.
</param>
            <exception>
throws IllegalArgumentException if redundancyLevel is less than -1.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetSubscriptionEnabled(System.Boolean)">
            <summary>
Enable subscriptions.
</summary>
            <remarks>
If set to true then the created pool will have server-to-client
subscriptions enabled. If set to false then all Subscription*
attributes are ignored at create time.
</remarks>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.AddServer(System.String,System.Int32)">
            <summary>
Add a server, given its host and port, to this factory.
</summary>
            <remarks>
The server must be a bridge server and this client will
directly connect to without consulting a server locator.
</remarks>
            <param>
host the host name or ip address that the server is listening on.
</param>
            <param>
port the port that the server is listening on
</param>
            <exception>
throws IllegalArgumentException if host is an unknown host
or if port is outside the valid range of [1..65535] inclusive.
</exception>
            <exception>
throws IllegalStateException if a server has already been added to this factory.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.AddLocator(System.String,System.Int32)">
            <summary>
Add a locator, given its host and port, to this factory.
</summary>
            <remarks>
The locator must be a server locator and will be used to discover other running
bridge servers and locators.
</remarks>
            <param>
host the host name or ip address that the locator is listening on.
</param>
            <param>
port the port that the locator is listening on
</param>
            <exception>
throws IllegalArgumentException if host is an unknown host
or if port is outside the valid range of [1..65535] inclusive.
</exception>
            <exception>
throws IllegalStateException if a locator has already been added to this factory.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetServerGroup(System.String)">
            <summary>
Configures the group that all servers this pool connects to must belong to.
</summary>
            <param>
group the server group that this pool will connect to.
If null or "" then all servers will be connected to.
</param>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetStatisticInterval(System.Int32)">
            <summary>
Set how often to send client statistics to the server.
</summary>
            <remarks>
Doing this allows gfmon to monitor clients.
A value of -1 disables the sending of client statistics
to the server.
</remarks>
            <param>
statisticInterval The amount of time in milliseconds between
sends of client statistics to the server.
</param>
            <exception>
throws IllegalArgumentException if statisticInterval
is less than -1.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetPingInterval(System.Int32)">
            <summary>
Set how often to ping servers to verify that they are still alive.
</summary>
            <remarks>
Each server will be sent a ping every pingInterval if there has not
been any other communication with the server.
These pings are used by the server to monitor the health of
the client. Make sure that the pingInterval is less than the
maximum time between pings allowed by the bridge server.
see in CacheServer: setMaximumTimeBetweenPings(int)
</remarks>
            <param>
pingInterval The amount of time in milliseconds between pings.
</param>
            <exception>
throws IllegalArgumentException if pingInterval is less than 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetRetryAttempts(System.Int32)">
            <summary>
Set the number of times to retry a request after timeout/exception.
</summary>
            <param>
retryAttempts The number of times to retry a request
after timeout/exception. -1 indicates that a request should be
tried against every available server before failing.
</param>
            <exception>
throws IllegalArgumentException if idleTimout is less than 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetIdleTimeout(System.Int32)">
            <summary>
Set the amount of time a connection can be idle before expiring the connection.
</summary>
            <remarks>
If the pool size is greater than the minimum specified, connections which have
been idle for longer than the idleTimeout will be closed.
</remarks>
            <param>
idleTimeout The amount of time in milliseconds that an idle connection
should live before expiring. -1 indicates that connections should never expire.
</param>
            <exception>
throws IllegalArgumentException if idleTimout is less than 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetMaxConnections(System.Int32)">
            <summary>
Set the max number of client to server connections that the pool will create.
</summary>
            <remarks>
If all of the connections are in use, an operation requiring a client to
server connection will block until a connection is available.
see setFreeConnectionTimeout(int)
</remarks>
            <param>
maxConnections the maximum number of connections in the pool.
-1 indicates that there is no maximum number of connections.
</param>
            <exception>
throws IllegalArgumentException if maxConnections is less than minConnections.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetMinConnections(System.Int32)">
            <summary>
Set the minimum number of connections to keep available at all times.
</summary>
            <remarks>
When the pool is created, it will create this many connections.
If 0 then connections will not be made until an actual operation
is done that requires client-to-server communication.
</remarks>
            <param>
minConnections the initial number of connections this pool will create.
</param>
            <exception>
throws IllegalArgumentException if minConnections is less than 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetReadTimeout(System.Int32)">
            <summary>
Sets the number of milliseconds to wait for a response from a server before
timing out the operation and trying another server (if any are available).
</summary>
            <param>
timeout number of milliseconds to wait for a response from a server
</param>
            <exception>
throws IllegalArgumentException if timeout
is less than or equal to 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetSocketBufferSize(System.Int32)">
            <summary>
Sets the socket buffer size for each connection made in this pool.
</summary>
            <remarks>
Large messages can be received and sent faster when this buffer is larger.
Larger buffers also optimize the rate at which servers can send events
for client subscriptions.
</remarks>
            <param>
bufferSize the size of the socket buffers used for reading and
writing on each connection in this pool.
</param>
            <exception>
throws IllegalArgumentException if bufferSize
is less than or equal to 0.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetLoadConditioningInterval(System.Int32)">
            <summary>
Sets the load conditioning interval for this pool.
</summary>
            <remarks>
This interval controls how frequently the pool will check to see if
a connection to a given server should be moved to a different
server to improve the load balance.
</remarks>
            <param>
loadConditioningInterval the connection lifetime in milliseconds
A value of -1 disables load conditioning.
</param>
            <exception>
throws IllegalArgumentException if connectionLifetime
is less than -1.
</exception>
            <returns>
a instance of <c>CacheFactory</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetFreeConnectionTimeout(System.Int32)">
            <summary>
Sets the free connection timeout for this pool.
</summary>
            <remarks>
If the pool has a max connections setting, operations will block
if all of the connections are in use. The free connection timeout
specifies how long those operations will block waiting for
a free connection before receiving an AllConnectionsInUseException.
If max connections is not set this setting has no effect.
</remarks>
            <param>
connectionTimeout the connection timeout in milliseconds
</param>
            <exception>
IllegalArgumentException if connectionTimeout 
is less than or equal to 0.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheFactory.ProductDescription">
            <summary>
Returns the product description string including product name and version.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheFactory.Version">
            <summary>
Returns the version of the cache implementation.
For the 1.0 release of GemFire, the string returned is <c>1.0</c>.
</summary>
            <returns>the version of the cache implementation as a <c>String</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.SetNewAndDelete">
            <summary>
Set allocators for non default Microsoft CRT versions.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.GetAnyInstance">
            <summary>
Gets an arbitrary open instance of <see cref="T:GemStone.GemFire.Cache.Generic.Cache" /> produced by an
earlier call to <see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" />.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if a cache has not been created or the only created one is
closed ( <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> )
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.EntryNotFoundException">
if a cache with specified system not found
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.GetInstanceCloseOk(GemStone.GemFire.Cache.Generic.DistributedSystem)">
            <summary>
Gets the instance of <see cref="T:GemStone.GemFire.Cache.Generic.Cache" /> produced by an
earlier call to <see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" />, even if it has been closed.
</summary>
            <param name="system">
the <see cref="T:GemStone.GemFire.Cache.Generic.DistributedSystem" /> the cache was created with.
</param>
            <returns>
the <c>Cache</c> associated with the specified system.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the distributed system argument is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if a cache has not been created.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.EntryNotFoundException">
if a cache with specified system not found
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.GetInstance(GemStone.GemFire.Cache.Generic.DistributedSystem)">
            <summary>
Gets the instance of <see cref="T:GemStone.GemFire.Cache.Generic.Cache" /> produced by an
earlier call to <see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" />.
</summary>
            <param name="system">
the <see cref="T:GemStone.GemFire.Cache.Generic.DistributedSystem" /> the cache was created with.
</param>
            <returns>the <see cref="T:GemStone.GemFire.Cache.Generic.Cache" /> associated with the specified system.</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the distributed system argument is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if a cache has not been created or the created one is closed
( <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> )
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.EntryNotFoundException">
if a cache with specified system not found
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.Create(System.String,GemStone.GemFire.Cache.Generic.DistributedSystem,System.String,GemStone.GemFire.Cache.Generic.CacheAttributes)">
            <summary>
Creates a new cache using the specified system using parameters
from the given <a href="cacheXml.html">XML</a> file and with
the given <c>CacheAttributes</c>.
</summary>
            <param name="name">the name to associate with the new cache</param>
            <param name="system">
a DistributedSystem obtained by calling
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" /></param>
            <param name="cacheXml">
name of the cache configuration XML file
</param>
            <param name="attributes">
optional <c>CacheAttributes</c> for this cache; these
override the ones provided in <c>cacheXml</c>.
</param>
            <returns>
a <c>Cache</c> that uses the specified <c>DistributedSystem</c>
for distribution.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
If <c>system</c> is not <see cref="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected" />
or name is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheExistsException">
ff an open cache already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheXmlException">
if something went wrong while parsing the XML
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the XML file is well-formed but not valid (consistent)
</exception>
            <deprecated>
as of NativeClient 3.5, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" /> instead.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.Create(System.String,GemStone.GemFire.Cache.Generic.DistributedSystem,GemStone.GemFire.Cache.Generic.CacheAttributes)">
            <summary>
Creates a new cache using the specified system using the given
<c>CacheAttributes</c>.
</summary>
            <param name="name">the name to associate with the new cache</param>
            <param name="system">
a DistributedSystem obtained by calling
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" /></param>
            <param name="attributes">
optional <c>CacheAttributes</c> for this cache
</param>
            <returns>
a <c>Cache</c> that uses the specified <c>DistributedSystem</c>
for distribution.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
If <c>system</c> is not <see cref="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected" />
or name is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheExistsException">
ff an open cache already exists
</exception>
            <deprecated>
as of NativeClient 3.5, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" /> instead.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.Create(System.String,GemStone.GemFire.Cache.Generic.DistributedSystem,System.String)">
            <summary>
Creates a new cache using the specified system using parameters
from the given <a href="cacheXml.html">XML</a> file.
</summary>
            <param name="name">the name to associate with the new cache</param>
            <param name="system">
a DistributedSystem obtained by calling
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" /></param>
            <param name="cacheXml">
name of the cache configuration XML file
</param>
            <returns>
a <c>Cache</c> that uses the specified <c>DistributedSystem</c>
for distribution.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
If <c>system</c> is not <see cref="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected" />
or name is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheExistsException">
ff an open cache already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheXmlException">
if something went wrong while parsing the XML
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the XML file is well-formed but not valid (consistent)
</exception>
            <deprecated>
as of NativeClient 3.5, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" /> instead.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.Create(System.String,GemStone.GemFire.Cache.Generic.DistributedSystem)">
            <summary>
Creates a new cache using the specified system.
</summary>
            <param name="name">the name to associate with the new cache</param>
            <param name="system">
a DistributedSystem obtained by calling
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" /></param>
            <returns>
a <c>Cache</c> that uses the specified <c>DistributedSystem</c>
for distribution.
</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
If <c>system</c> is not connected
( <see cref="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected" /> ) or name is null.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheExistsException">
If an open cache already exists.
</exception>
            <deprecated>
as of NativeClient 3.5, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" /> instead.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.Create">
            <summary>
To create the instance of <see cref="T:GemStone.GemFire.Cache.Generic.Cache" />.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.CreateCacheFactory">
            <summary>
A factory class that must be used to obtain instance of <see cref="T:GemStone.GemFire.Cache.Generic.Cache" />.
This should be called once. Using this one can set default values of <see cref="T:gemfire.Pool" />.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.String^})">
            <summary>
A factory class that must be used to obtain instance of <see cref="T:GemStone.GemFire.Cache.Generic.Cache" />.
This should be called once. Using this one can set default values of <see cref="T:gemfire.Pool" />.
</summary>
            <param name="dsProps">Properties which are applicable at client level.</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheFactory">
            <summary>
A factory class that must be used to obtain instance of <see cref="T:GemStone.GemFire.Cache.Generic.Cache" />.
</summary>
            <remarks>
To create a new cache instance, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.CreateCacheFactory(GemStone.GemFire.Cache.Properties)" />.
<para>
To get an existing unclosed cache instance, use <see cref="M:GemStone.GemFire.Cache.CacheFactory.GetInstance(GemStone.GemFire.Cache.DistributedSystem)" />.
</para></remarks>
        </member>
        <member name="F:gemfire.ManagedCqListener.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheListener
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCqListener.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCqListener.onError(gemfire.CqEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCqListener.onEvent(gemfire.CqEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <param name="ev">
Denotes the event object associated with the entry creation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCqListener.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedCqListener.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedCacheListener</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheListener</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>ICacheListener</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedCqListener.#ctor(GemStone.GemFire.Cache.ICqListener)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCqListener">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.ICacheListener" />
object and implements the native <c>gemfire::CacheListener</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICqListener.Close">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources,
such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICqListener.OnError(GemStone.GemFire.Cache.CqEvent)">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICqListener.OnEvent(GemStone.GemFire.Cache.CqEvent)">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <param name="ev">
Denotes the event object associated with the entry creation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.ICqListener">
            <summary>
An application plug-in that can be installed on a region.
Listener change notifications are invoked <c>after</c>
the change has occured.
</summary>
            <remarks>
Listeners receive notifications when entries in a region change or changes occur to the
region attributes themselves.
<para>
A cache listener is defined in the <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />.
</para>
The methods on a <c>ICacheListener</c>
are invoked asynchronously. Multiple events can cause concurrent invocation
of <c>ICacheListener</c> methods.  If event A occurs before event B,
there is no guarantee that their corresponding <c>ICacheListener</c>
method invocations will occur in the same order.  Any exceptions thrown by
the listener are caught by GemFire and logged. 

Listeners are user callbacks that
are invoked by GemFire. It is important to ensure that minimal work is done in the
listener before returning control back to GemFire. For example, a listener
implementation may choose to hand off the event to a thread pool that then processes
the event on its thread rather than the listener thread
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheLoader" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheWriter" />
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributes.#ctor(gemfire.CqAttributes*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributes.Create(gemfire.CqAttributes*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributes.getCqListeners">
            <summary>
get all listeners in this attributes
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqAttributes">
            <summary>
Defines attributes for configuring a cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesFactory.Create">
            <summary>
Creates a <c>CqAttributes</c> with the current settings.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesFactory.InitCqListeners(GemStone.GemFire.Cache.ICqListener[])">
            <summary>
Initialize with an array of listeners
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesFactory.AddCqListener(GemStone.GemFire.Cache.ICqListener)">
            <summary>
add a cqListener 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqAttributesFactory.#ctor">
            <summary>
Creates a new instance of <c>CqAttributesFactory</c> ready
to create a <c>CqAttributes</c> with default settings.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqAttributesFactory">
            <summary>
Creates instances of <c>CqAttributes</c>.
</summary>
            <seealso cref="T:GemStone.GemFire.Cache.CqAttributes" />
        </member>
        <member name="M:gemfire.CqAttributesFactory.create">
Creates a <code>CqAttributes</code> with the current settings.
@return the newly created <code>CqAttributes</code></member>
        <member name="M:gemfire.CqAttributesFactory.initCqListeners(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CqListener&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes all Cq listeners and then adds each listener in the specified array.
@param cqListeners a possibly empty array of listeners to add to this 
factory.
@throws IllegalArgumentException if the <code>cqListeners</code> array has a 
NULLPTR element

</member>
        <member name="M:gemfire.CqAttributesFactory.addCqListener(gemfire.SharedPtr&lt;gemfire.CqListener&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds a CQ listener to the end of the list of cq listeners on this factory.
@param cqListener the CqListener to add to the factory.
@throws IllegalArgumentException if <code>cqListener</code> is NULLPTR

</member>
        <member name="M:gemfire.CqAttributesFactory.#ctor(gemfire.SharedPtr&lt;gemfire.CqAttributes&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Creates a new instance of CqAttributesFactory ready to create a
 <code>CqAttributes</code> with the same settings as those in the
 specified <code>CqAttributes</code>.

 @param cqAttributes
          the <code>CqAttributes</code> used to initialize this
          AttributesFactory

</member>
        <member name="M:gemfire.CqAttributesFactory.#ctor">
Creates a new instance of AttributesFactory ready to create a
<code>CqAttributes</code> with default settings.

</member>
        <member name="T:GemStone.GemFire.Cache.Generic.CharArray">
            <summary>
An immutable wrapper for array of 16-bit characters that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.BooleanArray">
            <summary>
An immutable wrapper for array of booleans that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableInt64Array">
            <summary>
An immutable wrapper for array of 64-bit integers that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableInt32Array">
            <summary>
An immutable wrapper for array of 32-bit integers that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableInt16Array">
            <summary>
An immutable wrapper for array of 16-bit integers that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableFloatArray">
            <summary>
An immutable wrapper for array of floats that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableDoubleArray">
            <summary>
An immutable wrapper for array of doubles that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableBytes">
            <summary>
An immutable wrapper for byte arrays that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableInt64">
            <summary>
An immutable wrapper for 64-bit integers that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableInt32">
            <summary>
An immutable wrapper for 32-bit integers that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableInt16">
            <summary>
An immutable wrapper for 16-bit integers that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableFloat">
            <summary>
An immutable wrapper for floats that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableDouble">
            <summary>
An immutable wrapper for doubles that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableCharacter">
            <summary>
An immutable wrapper for 16-bit characters that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableByte">
            <summary>
An immutable wrapper for bytes that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableBoolean">
            <summary>
An immutable wrapper for booleans that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheStatistics.#ctor(gemfire.CacheStatistics*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheStatistics.Create(gemfire.CacheStatistics*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheStatistics.get_LastAccessedTime">
            <summary>
Get the last accessed time of an entry or a region.
</summary>
            <returns>
the last accessed time expressed as the number of milliseconds since
January 1, 1970.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime">
            <summary>
For an entry, returns the last time it was accessed via <c>Region.Get</c>.
For a region, returns the last time any of its entries or the entries of
its subregions were accessed with <c>Region.Get</c>.
</summary>
            <remarks>
                <para>
Any modifications will also update the <c>LastAccessedTime</c>,
so <c>LastAccessedTime</c> is always greater than or equal to
<c>LastModifiedTime</c>. The <c>LastAccessedTime</c> on a region is
propagated upward to parent regions, transitively, to the the root region.
</para>
                <para>
The number is expressed as the number of milliseconds since
January 1, 1970. The granularity may be as coarse as 100ms, so
the accuracy may be off by up to 50ms.
</para>
            </remarks>
            <returns>
the last access time of the region or the entry's value;
returns 0 if entry is invalid or access time is uninitialized.
</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" />
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheStatistics.get_LastModifiedTime">
            <summary>
Get the last modified time of an entry or a region.
</summary>
            <returns>
the last accessed time expressed as the number of milliseconds since
January 1, 1970.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime">
            <summary>
For an entry, returns the time that the entry's value was last modified.
For a region, returns the last time any of the region's entries' values or
the values in subregions' entries were modified.
</summary>
            <remarks>
                <para>
The modification may have been initiated locally, or it may have been
an update distributed from another cache. It may also have been a new
value provided by a loader. The modification time on a region is
propagated upward to parent regions, transitively, to the root region.
</para>
                <para>
The number is expressed as the number of milliseconds since January 1, 1970.
The granularity may be as coarse as 100ms, so the accuracy may be off by
up to 50ms.
</para>
                <para>
Entry and subregion creation will update the modification time on a
region, but <c>Region.Destroy</c>, <c>Region.DestroyRegion</c>,
<c>Region.Invalidate</c>, and <c>Region.InvalidateRegion</c>
do not update the modification time.
</para>
            </remarks>
            <returns>
the last modification time of the region or the entry;
returns 0 if the entry is invalid or the modification time is uninitialized.
</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.CreateSubRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheStatistics">
            <summary>
Defines common statistical information for both the region and its entries.
</summary>
            <remarks>
All of these methods may throw a <c>CacheClosedException</c>,
<c>RegionDestroyedException</c>, or <c>EntryDestroyedException</c>.
</remarks>
            <seealso cref="P:GemStone.GemFire.Cache.Region.Statistics" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionEntry.Statistics" />
        </member>
        <member name="M:GemStone.GemFire.Cache.StructSet.#ctor(gemfire.StructSet*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.StructSet.Create(gemfire.StructSet*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.StructSet.GetEnumerator">
            <summary>
Returns an enumerator that iterates through the <c>StructSet</c>.
</summary>
            <returns>
A <c>System.Collections.Generic.IEnumerator</c> that
can be used to iterate through the <c>StructSet</c>.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.StructSet.GetFieldName(System.UInt32)">
            <summary>
Get the field name of the <c>StructSet</c> from the
specified index number.
</summary>
            <param name="index">
the index number of the field name to get.
</param>
            <returns>
the field name from the specified index number or null if not found.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.StructSet.GetFieldIndex(System.String)">
            <summary>
Get the index number of the specified field name
in the <c>StructSet</c>.
</summary>
            <param name="fieldName">
the field name for which the index is required.
</param>
            <returns>the index number of the specified field name.</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the field name is not found.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.StructSet.GetIterator">
            <summary>
Get a <c>SelectResultsIterator</c> with which to iterate
over the items in the <c>StructSet</c>.
</summary>
            <returns>
The <c>SelectResultsIterator</c> with which to iterate.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.StructSet.Item(System.UInt32)">
            <summary>
Index operator to directly access an item in the <c>StructSet</c>.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the index is out of bounds.
</exception>
            <returns>Item at the given index.</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.StructSet.Size">
            <summary>
The size of the <c>StructSet</c>.
</summary>
            <returns>
the number of items in the <c>StructSet</c>.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.StructSet.IsModifiable">
            <summary>
True if this <c>StructSet</c> is modifiable.
</summary>
            <returns>returns false always at this time.</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.StructSet">
            <summary>
Encapsulates a query struct set.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.ICqResults">
            <summary>
Interface to encapsulate a select query result set.
</summary>
        </member>
        <member name="M:gemfire.StructSet.Dispose">
Destructor

</member>
        <member name="M:gemfire.StructSet.getIterator">
 Get a SelectResultsIterator with which to iterate over the items in the StructSet.

 @returns The SelectResultsIterator with which to iterate.

</member>
        <member name="M:gemfire.StructSet.getFieldName(System.Int32)">
 Get the field name of the StructSet from the specified index number.

 @param index the index number of the field name to get.
 @returns the field name from the specified index number or NULL if not found.

</member>
        <member name="M:gemfire.StructSet.getFieldIndex(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Get the index number of the specified field name in the StructSet.

 @param fieldname the field name for which the index is required.
 @returns the index number of the specified field name.
 @throws IllegalArgumentException if the field name is not found.

</member>
        <member name="M:gemfire.StructSet.op_Subscript(System.Int32)">
 Index operator to directly access an item in the StructSet.

 @param index the index number of the item to get.
 @throws IllegalArgumentException if the index is out of bounds.
 @returns A smart pointer to the item indexed.

</member>
        <member name="M:gemfire.StructSet.size">
 Get the size of the StructSet.

 @returns the number of items in the StructSet.

</member>
        <member name="M:gemfire.StructSet.isModifiable">
 Check whether the StructSet is modifiable.

 @returns false always at this time.

</member>
        <member name="T:gemfire.StructSet">
 @class StructSet StructSet.hpp

 A StructSet may be obtained after executing a Query which is obtained from a
 QueryService which in turn is obtained from a Cache.
 It is the parent of a Struct which contains the field values.

</member>
        <member name="M:gemfire.Struct.objectSize">
always returns 0

</member>
        <member name="M:gemfire.Struct.getFieldName(System.Int32)">
Returns the name of the field corresponding to the index number in the Struct

</member>
        <member name="M:gemfire.Struct.DSFID">
Return the data serializable fixed ID size type for internal use.
@since GFE 5.7

</member>
        <member name="M:gemfire.Struct.typeId">
Returns the typeId of Struct class.

</member>
        <member name="M:gemfire.Struct.classId">
Returns the classId for internal use.

</member>
        <member name="M:gemfire.Struct.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Serializes this Struct object. @TODO KN: better comment

</member>
        <member name="M:gemfire.Struct.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Deserializes the Struct object from the DataInput. @TODO KN: better comment

</member>
        <member name="M:gemfire.Struct.next">
 Get the next field value item available in this Struct.

 @returns A smart pointer to the next item in the Struct or NULLPTR if no more available.

</member>
        <member name="M:gemfire.Struct.length">
 Get the number of field values available.

 @returns the number of field values available.

</member>
        <member name="M:gemfire.Struct.hasNext">
 Check whether another field value is available to iterate over in this Struct.

 @returns true if available otherwise false.

</member>
        <member name="M:gemfire.Struct.getStructSet">
 Get the parent StructSet of this Struct.

 @returns A smart pointer to the parent StructSet of this Struct.

</member>
        <member name="M:gemfire.Struct.op_Subscript(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Get the field value for the given field name.

 @param fieldName the name of the field whos value is required.
 @returns A smart pointer to the field value.
 @throws IllegalArgumentException if the field name is not found.

</member>
        <member name="M:gemfire.Struct.op_Subscript(System.Int32)">
 Get the field value for the given index number.

 @param index the index number of the field value to get.
 @returns A smart pointer to the field value or NULLPTR if index out of bounds.

</member>
        <member name="M:gemfire.Struct.createDeserializable">
Factory function for registration of <code>Struct</code>.

</member>
        <member name="M:gemfire.Struct.#ctor(gemfire.StructSet*,gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.Serializable&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor - meant only for internal use.

</member>
        <member name="T:gemfire.Struct">
@class Struct Struct.hpp
A Struct has a StructSet as its parent. It contains the field values
returned after executing a Query obtained from a QueryService which in turn
is obtained from a Cache.

</member>
        <member name="M:GemStone.GemFire.Cache.ResultSet.#ctor(gemfire.ResultSet*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultSet.Create(gemfire.ResultSet*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultSet.GetEnumerator">
            <summary>
Returns an enumerator that iterates through the collection.
</summary>
            <returns>
A <c>System.Collections.Generic.IEnumerator</c> that
can be used to iterate through the <c>ResultSet</c>.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.ResultSet.GetIterator">
            <summary>
Get an iterator for the result set.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.ResultSet.Item(System.UInt32)">
            <summary>
Get an object at the given index.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.ResultSet.Size">
            <summary>
The size of the <c>ResultSet</c>.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.ResultSet.IsModifiable">
            <summary>
True if this <c>ResultSet</c> is modifiable.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.ResultSet">
            <summary>
Encapsulates a query result set.
It specifies the interface for the resultset obtained from the
Gemfire cache server
</summary>
        </member>
        <member name="M:gemfire.ResultSet.Dispose">
Destructor

</member>
        <member name="M:gemfire.ResultSet.getIterator">
 Get a SelectResultsIterator with which to iterate over the items in the ResultSet.

 @returns The SelectResultsIterator with which to iterate.

</member>
        <member name="M:gemfire.ResultSet.op_Subscript(System.Int32)">
 Index operator to directly access an item in the ResultSet.

 @param index the index number of the required item.
 @throws IllegalArgumentException if the index is out of bounds.
 @returns A smart pointer to the item indexed.

</member>
        <member name="M:gemfire.ResultSet.size">
 Get the size of the ResultSet.

 @returns the number of items in the ResultSet.

</member>
        <member name="M:gemfire.ResultSet.isModifiable">
 Check whether the ResultSet is modifiable.

 @returns false always at this time.

</member>
        <member name="T:gemfire.ResultSet">
@class ResultSet ResultSet.hpp
A ResultSet may be obtained after executing a Query which is obtained from a
QueryService which in turn is obtained from a Cache.

</member>
        <member name="M:gemfire.SelectResultsIterator.#ctor(gemfire.SharedPtr&lt;gemfire.CacheableVector&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.SelectResults&gt;)">
Constructor - meant only for internal use.

</member>
        <member name="M:gemfire.SelectResultsIterator.reset">
Reset the SelectResultsIterator to point to the start of the items.

</member>
        <member name="M:gemfire.SelectResultsIterator.current">
 Get the current item pointed to by the SelectResultsIterator.

 @returns A smart pointer to the current item pointed to by the SelectResultsIterator.

</member>
        <member name="M:gemfire.SelectResultsIterator.moveNext">
 Move the iterator to point to the next item to get.

 @returns true if another item was available to move to otherwise false.

</member>
        <member name="M:gemfire.SelectResultsIterator.next">
 Get the next item from the SelectResultsIterator.

 @returns a smart pointer to the next item from the iterator or NULLPTR if no further items are available.

</member>
        <member name="M:gemfire.SelectResultsIterator.hasNext">
 Check whether the SelectResultsIterator has another item to get.

 @returns true if another item is available otherwise false.

</member>
        <member name="T:gemfire.SelectResultsIterator">
@class SelectResultsIterator SelectResultsIterator.hpp
A SelectResultsIterator is obtained from a ResultSet or StructSet and
is used to iterate over the items available in them.

</member>
        <member name="M:GemStone.GemFire.Cache.ISelectResults.GetIterator">
            <summary>
Get an iterator for the result set.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.ISelectResults.Item(System.UInt32)">
            <summary>
Get an object at the given index.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.ISelectResults.Size">
            <summary>
The size of the <c>ISelectResults</c>.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.ISelectResults.IsModifiable">
            <summary>
True if this <c>ISelectResults</c> is modifiable.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.ISelectResults">
            <summary>
Interface to encapsulate a select query result set.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Query.#ctor(gemfire.Query*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Query.Create(gemfire.Query*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Query.IsCompiled">
            <summary>
Check if the query is compiled -- NOT IMPLEMENTED.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Query.Compile">
            <summary>
Compile the given query -- NOT IMPLEMENTED.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Query.QueryString">
            <summary>
Get the string for this query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Query.Execute(GemStone.GemFire.Cache.IGFSerializable[])">
            <summary>
Executes the OQL Parameterized Query on the cache server with the specified
paramList and returns the results. The default timeout for the query is 15 secs.
</summary>
            <param name="paramList">The Parameter List for the specified Query.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if timeout parameter is greater than 2^31/1000.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
if some query error occurred at the server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if some other error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if no java cache server is available
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <returns>
An <see cref="T:GemStone.GemFire.Cache.ISelectResults" /> object which can either be a
<see cref="T:GemStone.GemFire.Cache.StructSet" /> or a <see cref="T:GemStone.GemFire.Cache.StructSet" />.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Query.Execute(System.UInt32)">
            <summary>
Executes the OQL Query on the cache server with the specified
timeout and returns the results.
</summary>
            <param name="timeout">The time (in seconds) to wait for query response.
This should be less than or equal to 2^31/1000 i.e. 2147483.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if timeout parameter is greater than 2^31/1000.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
if some query error occurred at the server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if some other error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if no java cache server is available
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <returns>
An <see cref="T:GemStone.GemFire.Cache.ISelectResults" /> object which can either be a
<see cref="T:GemStone.GemFire.Cache.StructSet" /> or a <see cref="T:GemStone.GemFire.Cache.StructSet" />.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Query.Execute">
            <summary>
Executes the OQL Query on the cache server and returns
the results. The default timeout for the query is 15 secs.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
if some query error occurred at the server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if some other error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if no java cache server is available.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <returns>
An <see cref="T:GemStone.GemFire.Cache.ISelectResults" /> object which can either be a
<see cref="T:GemStone.GemFire.Cache.StructSet" /> or a <see cref="T:GemStone.GemFire.Cache.StructSet" />.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Query">
            <summary>
Class to encapsulate a query.
</summary>
            <remarks>
A Query is obtained from a QueryService which in turn is obtained
from the Cache.
This can be executed to return SelectResults which can be either
a ResultSet or a StructSet.

This class is intentionally not thread-safe. So multiple threads
should not operate on the same <c>Query</c> object concurrently
rather should have their own <c>Query</c> objects.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStringArray.#ctor(gemfire.Serializable*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStringArray.#ctor(System.String[])">
            <summary>
Allocates a new instance copying from the given string array.
</summary>
            <exception cref="!:IllegalArgumentException">
If the array contains a string greater than or equal 64K in length.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStringArray.Create(gemfire.Serializable*)">
            <summary>
Factory function to register wrapper
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStringArray.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableStringArray.Length">
            <summary>
Gets the length of the array.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableStringArray.Item(System.Int32)">
            <summary>
Returns a copy of the underlying string at the given index.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStringArray.GetValues">
            <summary>
Returns a copy of the underlying array of strings.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableStringArray.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableStringArray.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStringArray.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserializes the managed object -- returns an instance of the
<c>IGFSerializable</c> class.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStringArray.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this managed object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStringArray.Create(System.String[])">
            <summary>
Static function to create a new instance copying from the given
string array.
</summary>
            <remarks>
If the given array of strings is null or of zero-length then
this method returns null.
</remarks>
            <exception cref="!:IllegalArgumentException">
If the array contains a string greater than or equal 64K in length.
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableStringArray">
            <summary>
An immutable wrapper for array of strings that can serve as
a distributable object for caching.
</summary>
        </member>
        <member name="M:gemfire.ManagedVisitor.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedVisitor.visit(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Invokes the managed <c>PropertyVisitor</c> delegate for the given
<c>Property</c> key and value.
</summary>
        </member>
        <member name="M:gemfire.ManagedVisitor.#ctor(GemStone.GemFire.Cache.PropertyVisitor)">
            <summary>
Create a <c>gemfire::Properties::Visitor</c> from the given managed
<c>PropertyVisitor</c> delegate.
</summary>
        </member>
        <member name="T:gemfire.ManagedVisitor">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.PropertyVisitor" />
delegate and implements the native <c>gemfire::Properties::Visitor</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedResultCollectorGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheListener
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedResultCollectorGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedResultCollectorGeneric.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedResultCollectorGeneric.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedResultCollector</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheListener</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>IResultCollector</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedResultCollectorGeneric.#ctor(GemStone.GemFire.Cache.Generic.ResultCollectorG)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="userptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedResultCollectorGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IResultCollector" />
object and implements the native <c>gemfire::ResultCollector</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IResultCollector`1.ClearResults">
            <summary>
GemFire will invoke this method before re-executing function (in case of
Function Execution HA) This is to clear the previous execution results from
the result collector
@since 6.5
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IResultCollector`1.EndResults">
            <summary>
Call back provided to caller, which is called after function execution is
complete and caller can retrieve results using getResult()
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IResultCollector`1.GetResult(System.UInt32)">
            <summary>
get result 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IResultCollector`1.GetResult">
            <summary>
get result 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IResultCollector`1.AddResult(`0)">
            <summary>
add result from a single function execution
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IResultCollector`1">
            <summary>
collect function execution results, can be overriden 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.AuthenticatedCache.#ctor(gemfire.RegionService*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AuthenticatedCache.Create(gemfire.RegionService*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.AuthenticatedCache.RootRegions">
            <summary>
Returns an array of root regions in the cache. This set is a
snapshot and is not backed by the cache.
</summary>
            <remarks>
It is not supported when Cache is created from Pool.
</remarks>
            <returns>array of regions</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.AuthenticatedCache.GetQueryService">
            <summary>
Get a query service object to be able to query the cache.
Supported only when cache is created from Pool(pool is in multiuserSecure mode)
</summary>
            <remarks>
Currently only works against the java server in native mode, and
at least some endpoints must have been defined in some regions
before actually firing a query.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.AuthenticatedCache.Close">
            <summary>
Terminates this object cache and releases all the local resources.
If Cache instance created from Pool(pool is in multiuser mode), then it reset user related security data.
</summary>
            <remarks>
After this cache is closed, any further
method call on this cache or any region object will throw
<c>CacheClosedException</c>, unless otherwise noted.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache is already closed.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.AuthenticatedCache.IsClosed">
            <summary>
True if this cache has been closed.
</summary>
            <remarks>
After a new cache object is created, this method returns false.
After <see cref="M:GemStone.GemFire.Cache.AuthenticatedCache.Close" /> is called on this cache object, this method
returns true.
</remarks>
            <returns>true if this cache is closed, otherwise false</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.AuthenticatedCache">
            <summary>
Provides a distributed cache.
</summary>
            <remarks>
Caches are obtained from static methods on the
<see cref="T:GemStone.GemFire.Cache.CacheFactory" /> class.
<para>
When a cache is created a <see cref="T:GemStone.GemFire.Cache.DistributedSystem" />
must be specified.
</para><para>
When a cache will no longer be used, call <see cref="M:GemStone.GemFire.Cache.Cache.Close" />.
Once it <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> any attempt to use it
will cause a <c>CacheClosedException</c> to be thrown.
</para><para>
A cache can have multiple root regions, each with a different name.
</para></remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.#ctor(gemfire.Execution*)">
            <summary>
Private constructor to wrap a native object pointer.
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.Create(gemfire.Execution*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.Execute(System.String)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.Execute(System.String,System.Boolean)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
            <param name="getResult"> Indicating if results are expected. </param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.Execute(System.String,System.Boolean,System.UInt32)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
            <param name="getResult"> Indicating if results are expected. </param>
            <param name="timeout"> Value to wait for the operation to finish before timing out.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.Execute(System.String,System.Boolean,System.UInt32,System.Boolean)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
            <param name="func"> The name of the function to be executed. </param>
            <param name="getResult"> Indicating if results are expected. </param>
            <param name="timeout"> Value to wait for the operation to finish before timing out.</param>
            <param name="isHA"> Whether the given function is HA. </param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.Execute(System.String,System.Boolean,System.UInt32,System.Boolean,System.Boolean)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
            <param name="func"> The name of the function to be executed. </param>
            <param name="getResult"> Indicating if results are expected. </param>
            <param name="timeout"> Value to wait for the operation to finish before timing out.</param>
            <param name="isHA"> Whether the given function is HA. </param>
            <param name="optimizeForWrite"> Whether the function should be optmized for write operation. </param>
            <deprecated>
parameters hasResult, isHA and optimizeForWrite are deprecated as of NativeClient 3.6, use of these parameters is ignored.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.WithCollector(GemStone.GemFire.Cache.IResultCollector)">
            <summary>
Add a result collector, 
Return self.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.WithArgs(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Add an argument, 
Return self.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Execution.WithFilter(GemStone.GemFire.Cache.IGFSerializable[])">
            <summary>
Add a routing object, 
Return self.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Execution">
            <summary>
This class encapsulates events that occur for cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Pool.#ctor(gemfire.Pool*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Pool.Create(gemfire.Pool*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Pool.GetQueryService">
            <summary>
Returns the QueryService for this Pool.
</summary>
            <remarks>
The query operations performed using this QueryService will be executed
on the servers that are associated with this pool.
To perform Query operation on the local cache obtain the QueryService
instance from the Cache.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.Destroyed">
            <summary>
Indicates whether this Pool has been
destroyed.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Pool.Destroy">
            <summary>
Destroys this pool closing any connections it produced.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the pool is still in use
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Pool.Destroy(System.Boolean)">
            <summary>
Destroys this pool closing any connections it produced.
</summary>
            <param name="keepAlive">
whether the server should keep the durable client's
subscriptions alive for the timeout period
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the pool is still in use
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.Locators">
            <summary>
Returns an unmodifiable list of locators
this pool is using. Each locator is either one
added explicitly when the pool was created or
were discovered using the explicit locators.
</summary>
            <remarks>
If a pool has no locators then it can not discover servers or locators at runtime.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.ServerGroup">
            <summary>
Returns the server group of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.SubscriptionAckInterval">
            <summary>
Returns the subscription ack interval of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.SubscriptionMessageTrackingTimeout">
            <summary>
Returns the subscription message tracking timeout of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.SubscriptionRedundancy">
            <summary>
Returns the subscription redundancy level of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.PRSingleHopEnabled">
            <summary>
Returns the true if a pr-single-hop is set to true on this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.SubscriptionEnabled">
            <summary>
Returns the true if a server-to-client subscriptions are enabled on this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.RetryAttempts">
            <summary>
Get the retry attempts for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.StatisticInterval">
            <summary>
Get the statistic interval for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.PingInterval">
            <summary>
Get the ping interval for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.IdleTimeout">
            <summary>
Get the Idle connection timeout for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.MaxConnections">
            <summary>
Get the maximum connections for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.MinConnections">
            <summary>
Get the minimum connections for this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.ReadTimeout">
            <summary>
Returns the read timeout of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.SocketBufferSize">
            <summary>
Returns the socket buffer size of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.LoadConditioningInterval">
            <summary>
Returns the load conditioning interval of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.FreeConnectionTimeout">
            <summary>
Returns the connection timeout of this pool.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Pool.Name">
            <summary>
Get the name of the pool
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Pool">
            <summary>
A pool of connections.
</summary>
            <remarks>
A pool of connections from a GemFire client to a set of GemFire servers.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.FunctionService.#ctor(gemfire.FunctionService*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.FunctionService.OnServers(GemStone.GemFire.Cache.IRegionService)">
            <summary>
Creates a new Execution object on all servers in the pool.
</summary>
            <remarks />
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">when Pool has been closed.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.FunctionService.OnServer(GemStone.GemFire.Cache.IRegionService)">
            <summary>
Creates a new Execution object on one server.
</summary>
            <remarks />
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">when Pool has been closed.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.FunctionService.OnServers(GemStone.GemFire.Cache.Pool)">
            <summary>
Creates a new Execution object on all servers in the pool
</summary>
            <remarks />
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">unsupported operation exception, when Pool is in multiusersecure mode.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.FunctionService.OnServer(GemStone.GemFire.Cache.Pool)">
            <summary>
Creates a new Execution object on one server
</summary>
            <remarks />
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">unsupported operation exception, when Pool is in multiusersecure mode.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.#ctor(gemfire.Cache*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.Create(gemfire.Cache*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.CreateAuthenticatedView(GemStone.GemFire.Cache.Properties,System.String)">
            <summary>
Returns the instance of <see cref="T:GemStone.GemFire.Cache.IRegionService" /> to do the operation on Cache with different Credential.
</summary>
            <remarks>
Deafault pool should be in multiuser mode <see cref="M:GemStone.GemFire.Cache.CacheFactory.SetMultiuserAuthentication(System.Boolean)" /></remarks>
            <param name="credentials">the user Credentials.</param>
            <param name="poolName">Pool, which is in multiuser mode.</param>
            <returns>Instance of IRegionService</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.CreateAuthenticatedView(GemStone.GemFire.Cache.Properties)">
            <summary>
Returns the instance of <see cref="T:GemStone.GemFire.Cache.IRegionService" /> to do the operation on Cache with different Credential.
</summary>
            <remarks>
Deafault pool should be in multiuser mode <see cref="M:GemStone.GemFire.Cache.CacheFactory.SetMultiuserAuthentication(System.Boolean)" /></remarks>
            <param name="credentials">the user Credentials.</param>
            <returns>Instance of IRegionService</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.CreateRegionFactory(GemStone.GemFire.Cache.RegionShortcut)">
            <summary>
Returns the instance of <see cref="T:GemStone.GemFire.Cache.RegionFactory" /> to create the region
</summary>
            <remarks>
Pass the <see cref="T:GemStone.GemFire.Cache.RegionShortcut" /> to set the deafult region attributes
</remarks>
            <param name="regionShortcut">the regionShortcut to set the default region attributes</param>
            <returns>Instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.GetQueryService(System.String)">
            <summary>
Get a query service object to be able to query the cache.
Use only when Cache has more than one Pool.
</summary>
            <remarks>
Currently only works against the java server in native mode, and
at least some endpoints must have been defined in some regions
before actually firing a query.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.GetQueryService">
            <summary>
Get a query service object to be able to query the cache.
Supported only when cache is created from Pool(pool is in multiuserSecure mode)
</summary>
            <remarks>
Currently only works against the java server in native mode, and
at least some endpoints must have been defined in some regions
before actually firing a query.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.RootRegions">
            <summary>
Returns an array of root regions in the cache. This set is a
snapshot and is not backed by the cache.
</summary>
            <remarks>
It is not supported when Cache is created from Pool.
</remarks>
            <returns>array of regions</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.GetRegion(System.String)">
            <summary>
Returns an existing region given the full path from root, or null 
if no such region exists.
</summary>
            <remarks>
If Pool attached with Region is in multiusersecure mode then don't use return instance of region as no credential are attached with this instance.
Get region from RegionService instance of Cache.<see cref="!:Cache.CreateAuthenticatedView(PropertiesPtr)" />.
</remarks>
            <param name="path">the pathname of the region</param>
            <returns>the region</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.ReadyForEvents">
            <summary>
Send the client-ready message to the server for a durable client.        
</summary>
            <remarks>
This method should only be called for durable clients and
with a cache server version 5.5 onwards.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if there was a problem sending the message to the server.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.Close(System.Boolean)">
            <summary>
Terminates this object cache and releases all the local resources.
</summary>
            <remarks>
After this cache is closed, any further
method call on this cache or any region object will throw
<c>CacheClosedException</c>, unless otherwise noted.
</remarks>
            <param name="keepalive">whether to keep a durable client's queue alive</param>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache is already closed.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.Close">
            <summary>
Terminates this object cache and releases all the local resources.
</summary>
            <remarks>
After this cache is closed, any further
method call on this cache or any region object will throw
<c>CacheClosedException</c>, unless otherwise noted.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache is already closed.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Cache.DistributedSystem">
            <summary>
Returns the distributed system used to
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> this cache.
</summary>
            <remarks>
This method does not throw
<c>CacheClosedException</c> if the cache is closed.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.Cache.IsClosed">
            <summary>
True if this cache has been closed.
</summary>
            <remarks>
After a new cache object is created, this method returns false.
After <see cref="M:GemStone.GemFire.Cache.Cache.Close" /> is called on this cache object, this method
returns true.
</remarks>
            <returns>true if this cache is closed, otherwise false</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Cache.Name">
            <summary>
Returns the name of this cache.
</summary>
            <remarks>
This method does not throw
<c>CacheClosedException</c> if the cache is closed.
</remarks>
            <returns>the string name of this cache</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Cache.InitializeDeclarativeCache(System.String)">
            <summary>
Initializes the cache from an XML file.
</summary>
            <param name="cacheXml">pathname of a <c>cache.xml</c> file</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Cache">
            <summary>
Provides a distributed cache.
</summary>
            <remarks>
Caches are obtained from Create methods on the
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> class.
<para>
When a cache will no longer be used, call <see cref="M:GemStone.GemFire.Cache.Cache.Close" />.
Once it <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> any attempt to use it
will cause a <c>CacheClosedException</c> to be thrown.
</para><para>
A cache can have multiple root regions, each with a different name.
</para></remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.IGemFireCache.DistributedSystem">
            <summary>
Returns the distributed system used to
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> this cache.
</summary>
            <remarks>
This method does not throw
<c>CacheClosedException</c> if the cache is closed.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.IGemFireCache.InitializeDeclarativeCache(System.String)">
            <summary>
Initializes the cache from an XML file.
</summary>
            <param name="cacheXml">pathname of a <c>cache.xml</c> file</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.IGemFireCache.Name">
            <summary>
Returns the name of this cache.
</summary>
            <remarks>
This method does not throw
<c>CacheClosedException</c> if the cache is closed.
</remarks>
            <returns>the string name of this cache</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.IGemFireCache">
            <summary>
GemFireCache represents the singleton cache that must be created
in order to connect to Gemfire server.
</summary>
            <remarks>
Caches are obtained from Crest methods on the
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> class.
<para>
When a cache is created a <see cref="P:GemStone.GemFire.Cache.IGemFireCache.DistributedSystem" />
must be specified.
</para><para>
When a cache will no longer be used, call <see cref="M:GemStone.GemFire.Cache.Cache.Close" />.
Once it <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> any attempt to use it
will cause a <c>CacheClosedException</c> to be thrown.
</para><para>
A cache can have multiple root regions, each with a different name.
</para></remarks>
        </member>
        <member name="F:GemStone.GemFire.Cache.DistributedSystem.m_singletonSync">
            <summary>
Static lock object to protect the singleton instance of this class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.DistributedSystem.m_instance">
            <summary>
Singleton instance of this class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.DistributedSystem.m_memoryPressureHandler">
            <summary>
Timer task to periodically invoke <c>HandleMemoryPressure</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.HandleMemoryPressure(System.Object)">
            <summary>
Periodically adjust memory pressure of unmanaged heap for GC.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.Dispose">
            <summary>
Finalizer for the singleton instance of this class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.#ctor(gemfire.DistributedSystem*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.UnregisterBuiltinManagedTypes">
            <summary>
Unregister the builtin managed types like CacheableObject.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.AppDomainInstancePostInitialization">
            <summary>
Stuff that needs to be done for Connect in each AppDomain but
only after the first Connect has completed.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.ManagedPostConnect">
            <summary>
Managed registrations and other stuff to be done for the manage
layer after the first connect.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.AppDomainInstanceInitialization(gemfire.SharedPtr&lt;gemfire.Properties&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Stuff that needs to be done for Connect in each AppDomain.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.Create(gemfire.DistributedSystem*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.GetInstance">
            <summary>
Returns a reference to this DistributedSystem instance.
</summary>
            <returns>the DistributedSystem instance</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.DistributedSystem.IsConnected">
            <summary>
The current connection status of this client to the <c>DistributedSystem</c>.
</summary>
            <returns>true if connected, false otherwise</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.DistributedSystem.Name">
            <summary>
Get the name that identifies this DistributedSystem instance.
</summary>
            <returns>the name of the DistributedSystem instance.</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.DistributedSystem.SystemProperties">
            <summary>
Returns the SystemProperties used to create this instance of a
<c>DistributedSystem</c>.
</summary>
            <returns>the SystemProperties</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.Disconnect">
            <summary>
Disconnect from the distributed system.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">if not connected</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String,GemStone.GemFire.Cache.Properties)">
            <summary>
Initializes the Native Client system to be able to connect to the
GemFire Java servers.
</summary>
            <param name="name">the name of the system to connect to</param>
            <param name="config">the set of properties</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if name is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.NoSystemException">
if the connecting target is not running
</exception>
            <exception cref="T:GemStone.GemFire.Cache.AlreadyConnectedException">
if trying a second connect.
An application can have one only one connection to a DistributedSystem.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">otherwise</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)">
            <summary>
Initializes the Native Client system to be able to connect to the GemFire Java servers.
</summary>
            <param name="name">the name of the system to connect to</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if name is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.NoSystemException">
if the connecting target is not running
</exception>
            <exception cref="T:GemStone.GemFire.Cache.AlreadyConnectedException">
if trying a second connect.
An application can have one only one connection to a DistributedSystem.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">otherwise</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.DistributedSystem">
            <summary>
DistributedSystem encapsulates this applications "connection" into the
GemFire Java servers.
</summary>
            <remarks>
In order to participate as a client in the GemFire Java servers
distributed system, each application needs to connect to the
DistributedSystem.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.IRegionService.RootRegions">
            <summary>
Returns an array of root regions in the cache. This set is a
snapshot and is not backed by the cache.
</summary>
            <remarks>
It is not supported when Cache is created from Pool.
</remarks>
            <returns>array of regions</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.IRegionService.GetQueryService">
            <summary>
Get a query service object to be able to query the cache.
</summary>
            <remarks>
Currently only works against the java server in native mode, and
at least some endpoints must have been defined in some regions
before actually firing a query.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.IRegionService.GetRegion(System.String)">
            <summary>
Returns an existing region given the full path from root, or null 
if no such region exists.
</summary>
            <param name="name">the name of the region</param>
            <returns>the region</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.IRegionService.Close">
            <summary>
Terminates this object cache and releases all the local resources.
If RegionService is created from <see cref="M:GemStone.GemFire.Cache.Cache.CreateAuthenticatedView(GemStone.GemFire.Cache.Properties)" />, then it clears user related security data.
</summary>
            <remarks>
After this cache is closed, any further
method call on this cache or any region object will throw
<c>CacheClosedException</c>, unless otherwise noted.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache is already closed.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.IRegionService.IsClosed">
            <summary>
True if this cache has been closed.
</summary>
            <remarks>
After a new cache object is created, this method returns false.
After <see cref="M:GemStone.GemFire.Cache.IRegionService.Close" /> is called on this cache object, this method
returns true.
</remarks>
            <returns>true if this cache is closed, otherwise false</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.QueryService.#ctor(gemfire.QueryService*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.QueryService.Create(gemfire.QueryService*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.QueryService.GetCqStatistics">
@nativeclient
<summary>
Get <c>CqServiceStatistics</c>  on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.QueryService.StopCqs">
@nativeclient
<summary>
Stop all  <c>CqQuery</c>  on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.QueryService.ExecuteCqs">
@nativeclient
<summary>
Get the  <c>CqQuery</c> with the given name on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.QueryService.GetCq(System.String)">
@nativeclient
<summary>
Get the  <c>CqQuery</c> with the given name on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.QueryService.GetCqs">
@nativeclient
<summary>
Get all  <c>CqQuery</c> on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.QueryService.CloseCqs">
@nativeclient
<summary>
Close all  <c>CqQuery</c> on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.QueryService.NewCq(System.String,System.String,GemStone.GemFire.Cache.CqAttributes,System.Boolean)">
@nativeclient
<summary>
Get a <c>CqQuery</c> object to enable continuous querying.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.QueryService.NewCq(System.String,GemStone.GemFire.Cache.CqAttributes,System.Boolean)">
@nativeclient
<summary>
Get a <c>CqQuery</c> object to enable continuous querying.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.QueryService.NewQuery(System.String)">
            <summary>
Get a <c>Query</c> object to enable querying.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.QueryService">
            <summary>
Provides a query service.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.#ctor(gemfire.RegionFactory*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.Create(gemfire.RegionFactory*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetCloningEnabled(System.Boolean)">
            <summary>
Set cloning enabled flag for this region.
</summary>
            <remarks>
                <para>
If set to false, then there is no cloning will take place in case of delta.
Delta will be applied on the old value which will change old value in-place.
</para>
                <para>
The default if not set is 'false'
of <c>ScopeType.Local</c> scope. 
</para>
            </remarks>
            <param name="cloningEnabled">
if true, clone old value before applying delta so that in-place change would not occour..
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetCachingEnabled(System.Boolean)">
            <summary>
Set caching enabled flag for this region.
</summary>
            <remarks>
                <para>
If set to false, then no data is stored in the local process,
but events and distributions will still occur, and the region
can still be used to put and remove, etc...
</para>
                <para>
The default if not set is 'true', 'false' is illegal for regions
of <c>ScopeType.Local</c> scope. 
</para>
            </remarks>
            <param name="cachingEnabled">
if true, cache data for this region in this process.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetDiskPolicy(GemStone.GemFire.Cache.DiskPolicyType)">
            <summary>
Sets the disk policy type for the next <c>RegionAttributes</c> created.
</summary>
            <param name="diskPolicy">
the disk policy to use for the region
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetLruEntriesLimit(System.UInt32)">
            <summary>
Sets a limit on the number of entries that will be held in the cache.
If a new entry is added while at the limit, the cache will evict the
least recently used entry.
</summary>
            <param name="entriesLimit">
The limit of the number of entries before eviction starts.
Defaults to 0, meaning no LRU actions will used.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetConcurrencyLevel(System.Int32)">
            <summary>
Sets the concurrency level of the next <c>RegionAttributes</c>
created. This value is used in initializing the map that holds the entries.
</summary>
            <param name="concurrencyLevel">
the concurrency level of the entry map
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if concurrencyLevel is nonpositive
</exception>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetLoadFactor(System.Single)">
            <summary>
Sets the entry load factor for the next <c>RegionAttributes</c>
created. This value is
used in initializing the map that holds the entries.
</summary>
            <param name="loadFactor">the load factor of the entry map</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if loadFactor is nonpositive
</exception>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetInitialCapacity(System.Int32)">
            <summary>
Sets the entry initial capacity for the <c>RegionAttributes</c>
being created. This value is used in initializing the map that
holds the entries.
</summary>
            <param name="initialCapacity">the initial capacity of the entry map</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if initialCapacity is nonpositive
</exception>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetPoolName(System.String)">
            <summary>
Set the pool name for a Thin Client region.
</summary>
            <remarks>
The pool with the name specified must be already created.
</remarks>
            <param name="poolName">
The name of the pool to attach to this region.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetPersistenceManager(System.String,System.String,GemStone.GemFire.Cache.Properties)">
            <summary>
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
This must be used to set the PersistenceManager.
</summary>
            <param name="libPath">The path of the PersistenceManager shared library.</param>
            <param name="factoryFunctionName">
The name of the factory function to create an instance of PersistenceManager object.
</param>
            <param name="config">
The configuration properties to use for the PersistenceManager.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetPersistenceManager(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
This must be used to set the PersistenceManager.
</summary>
            <param name="libPath">The path of the PersistenceManager shared library.</param>
            <param name="factoryFunctionName">
The name of the factory function to create an instance of PersistenceManager object.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetRegionTimeToLive(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)">
            <summary>
Sets the timeToLive expiration attributes for the region itself for the
next <c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="timeToLive">
the timeToLive in seconds for the region as a whole.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetRegionIdleTimeout(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)">
            <summary>
Sets the idleTimeout expiration attributes for the region itself for the
next <c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="idleTimeout">
the idleTimeout in seconds for the region as a whole.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetEntryTimeToLive(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)">
            <summary>
Sets the timeToLive expiration attributes for region entries for the next
<c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="timeToLive">
the timeToLive in seconds for entries in this region.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetEntryIdleTimeout(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)">
            <summary>
Sets the idleTimeout expiration attributes for region entries for the next
<c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="idleTimeout">
the idleTimeout in seconds for entries in this region.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetPartitionResolver(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the partition resolver of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>PartitionResolver</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>IPartitionResolver</c> for a managed library.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetCacheListener(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the listener of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheListener</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheListener</c> for a managed library.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetCacheWriter(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the writer of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheWriter</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheWriter</c> for a managed library.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetCacheLoader(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the loader of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheLoader</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheLoader</c> for a managed library.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetPartitionResolver(GemStone.GemFire.Cache.IPartitionResolver)">
            <summary>
Sets the PartitionResolver for the <c>RegionAttributes</c> being created.
</summary>
            <param name="partitionresolver">
user-defined partition resolver, or null for no partition resolver
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)">
            <summary>
Sets the CacheListener for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheListener">
user-defined cache listener, or null for no cache listener
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetCacheWriter(GemStone.GemFire.Cache.ICacheWriter)">
            <summary>
Sets the cache writer for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheWriter">
user-defined cache writer, or null for no cache writer
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionFactory.SetCacheLoader(GemStone.GemFire.Cache.ICacheLoader)">
            <summary>
Sets the cache loader for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheLoader">
a user-defined cache loader, or null for no cache loader
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.RegionFactory">
            <summary>
This interface provides for the configuration and creation of instances of Region.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.RegionShortcut.LOCAL_ENTRY_LRU">
            <summary>
A LOCAL_ENTRY_LRU region only has local state and never sends operations to a server.
It will also destroy entries once it detects once it detects that the number of enteries crossing default limit of #100000.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.RegionShortcut.LOCAL">
            <summary>
A LOCAL region only has local state and never sends operations to a server.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.RegionShortcut.CACHING_PROXY_ENTRY_LRU">
            <summary>
A CACHING_PROXY_ENTRY_LRU region has local state but can also send operations to a server.
If the local state is not found then the operation is sent to the server
and the local state is updated to contain the server result.
It will also destroy entries once it detects that the number of enteries crossing default limit of #100000.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.RegionShortcut.CACHING_PROXY">
            <summary>
A CACHING_PROXY region has local state but can also send operations to a server.
If the local state is not found then the operation is sent to the server
and the local state is updated to contain the server result.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.RegionShortcut.PROXY">
            <summary>
A PROXY region has no local state and forwards all operations to a server.
</summary>
        </member>
        <member name="M:gemfire.FunctionService.onServers(gemfire.SharedPtr&lt;gemfire.RegionService&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a {@link Execution} object that can be used to execute a data
independent function on all the servers where Cache is attached.
If one of the servers goes down while dispatching or executing the function
on the server, an Exception will be thrown.

@param cache 
       the {@link Cache} where function need to execute.
@return Execution
@throws NullPointerException
                if Pool instance passed in is NULLPTR
@throws UnsupportedOperationException
                if Pool is in multiusersecure Mode

</member>
        <member name="M:gemfire.FunctionService.onServers(gemfire.SharedPtr&lt;gemfire.Pool&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a {@link Execution} object that can be used to execute a data
independent function on all the servers in the provided {@link Pool}.
If one of the servers goes down while dispatching or executing the function
on the server, an Exception will be thrown.

@param pool the set of servers to execute the function
@return Execution
@throws NullPointerException
                if Pool instance passed in is NULLPTR
@throws UnsupportedOperationException
                if Pool is in multiusersecure Mode

</member>
        <member name="T:gemfire.FunctionService">
@class FunctionService FunctionService.hpp
entry point for function execution
@see Execution

</member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.#ctor(System.Char[])">
            <summary>
Allocates a new instance copying from the given character array.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.#ctor(System.String)">
            <summary>
Allocates a new instance from the given string.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableFileName.Value">
            <summary>
Gets the string value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.Equals(System.Object)">
            <summary>
Return true if this key matches other object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.Equals(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Return true if this key matches other object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.GetHashCode">
            <summary>
Return the hashcode for this key.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.ToString">
            <summary>
Return a string representation of the object.
This returns the same string as <c>Value</c> property.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableFileName.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableFileName.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.Create(System.Char[])">
            <summary>
Static function to create a new instance from the
given character array.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableFileName.Create(System.String)">
            <summary>
Static function to create a new instance from the given string.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableFileName">
            <summary>
An immutable filename wrapper that can serve as a distributable
key object for caching as well as being a string value.
</summary>
        </member>
        <member name="F:gemfire.ManagedFixedPartitionResolverGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IFixedPartitionResolver
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolverGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolverGeneric.getName">
            <summary>
Returns the name of the FixedPartitionResolver.
</summary>
            <remarks>
                <para>
This function does not throw any exception.
</para>
                <returns>
the name of the FixedPartitionResolver
</returns>
            </remarks>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolverGeneric.getRoutingObject(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return object associated with entry event which allows the Partitioned Region to store associated data together.
</summary>
            <remarks>
throws RuntimeException - any exception thrown will terminate the operation and the exception will be passed to the
calling thread.
</remarks>
            <param name="key">
key the detail of the entry event.
</param>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolverGeneric.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolverGeneric.#ctor(System.Object)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="userptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedFixedPartitionResolverGeneric">
            <summary>
Wraps the managed <see cref="!:GemStone.GemFire.Cache.IFixedPartitionResolver" />
object and implements the native <c>gemfire::FixedPartitionResolver</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionEntry`2.#ctor(gemfire.RegionEntry*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionEntry`2.Create(gemfire.RegionEntry*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionEntry`2.IsDestroyed">
            <summary>
True if this entry has been destroyed.
</summary>
            <remarks>
Does not throw a <c>EntryDestroyedException</c> if this entry
has been destroyed.
</remarks>
            <returns>true if this entry has been destroyed</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if the cache is closed at the time of invocation
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionEntry`2.Statistics">
            <summary>
Returns the statistics for this entry.
</summary>
            <returns>the CacheStatistics for this entry</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.StatisticsDisabledException">
if statistics have been disabled for this region
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionEntry`2.Region">
            <summary>
Returns the region that contains this entry.
</summary>
            <returns>the region that contains this entry</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if the cache is closed at the time of invocation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.EntryDestroyedException">
if the entry has been destroyed
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionEntry`2.Value">
            <summary>
Returns the value of this entry in the local cache. Does not invoke
an <c>ICacheLoader</c>, does not do a netSearch, netLoad, etc.
</summary>
            <returns>
the value, or null if this entry is invalid -- see <see cref="P:GemStone.GemFire.Cache.Generic.RegionEntry`2.IsDestroyed" /></returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if the cache is closed at the time of invocation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.EntryDestroyedException">
if the entry has been destroyed
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionEntry`2.Key">
            <summary>
Returns the key for this entry.
</summary>
            <returns>the key for this entry</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if the cache is closed at the time of invocation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.EntryDestroyedException">
if the entry has been destroyed
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.RegionEntry`2">
            <summary>
An object in a region that represents an <em>entry</em>, that is, a key-value pair.
</summary>
            <remarks>
This object's operations are not distributed, do not acquire any locks, and do not affect
<c>CacheStatistics</c>.

Unless otherwise noted, all of these methods throw a
<c>CacheClosedException</c> if the cache is closed at the time of
invocation, or an <c>EntryDestroyedException</c> if the entry has been
destroyed.

Call <see cref="P:GemStone.GemFire.Cache.Generic.RegionEntry`2.IsDestroyed" /> to see if an entry has already been destroyed.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.#ctor(gemfire.AttributesMutator*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.Create(gemfire.AttributesMutator*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetCacheWriter(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the writer of the region.
The previous cache writer will be replaced with a writer created
using the factory function provided in the given library.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheWriter</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheWriter</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetCacheWriter(GemStone.GemFire.Cache.Generic.ICacheWriter`2{`0,`1})">
            <summary>
Sets the CacheListener for the region.
The previous cache writer (if any) will be replaced with the given <c>cacheWriter</c>.
</summary>
            <param name="cacheWriter">
user-defined cache writer, or null for no cache writer
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetCacheLoader(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the loader of the region.
The previous cache loader will be replaced with a loader created
using the factory function provided in the given library.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheLoader</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheLoader</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetCacheLoader(GemStone.GemFire.Cache.Generic.ICacheLoader`2{`0,`1})">
            <summary>
Sets the CacheLoader for the region.
The previous cache loader (if any) will be replaced with the given <c>cacheLoader</c>.
</summary>
            <param name="cacheLoader">
user-defined cache loader, or null for no cache loader
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetCacheListener(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the listener of the region.
The previous cache listener will be replaced with a listener created
using the factory function provided in the given library.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheListener</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheListener</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetCacheListener(GemStone.GemFire.Cache.Generic.ICacheListener`2{`0,`1})">
            <summary>
Sets the CacheListener for the region.
The previous cache listener (if any) will be replaced with the given <c>cacheListener</c>.
</summary>
            <param name="cacheListener">
user-defined cache listener, or null for no cache listener
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetLruEntriesLimit(System.UInt32)">
            <summary>
Sets the maximum entry count in the region before LRU eviction.
</summary>
            <param name="entriesLimit">the number of entries to allow, or 0 to disable LRU</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the new entriesLimit changes LRU from
disabled to enabled or enabled to disabled.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetRegionTimeToLiveAction(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Sets the timeToLive action for the region itself.
</summary>
            <param name="action">
the timeToLiv eaction for this region
</param>
            <returns>the previous action</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetRegionTimeToLive(System.Int32)">
            <summary>
Sets the timeToLive duration for the region itself.
</summary>
            <param name="timeToLive">
the timeToLive for this region, in seconds, or 0 to disable time-to-live
</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the new timeToLive changes region expiration from
disabled to enabled or enabled to disabled.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetRegionIdleTimeoutAction(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Sets the idleTimeout action for the region itself.
</summary>
            <param name="action">
the idleTimeout action for this region
</param>
            <returns>the previous action</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetRegionIdleTimeout(System.Int32)">
            <summary>
Sets the idleTimeout duration for the region itself.
</summary>
            <param name="idleTimeout">
the idleTimeout for this region, in seconds, or 0 to disable idle timeout
</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the new idleTimeout changes region expiration from
disabled to enabled or enabled to disabled.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetEntryTimeToLiveAction(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Set the timeToLive action for region entries.
</summary>
            <param name="action">
the timeToLive action for entries in this region
</param>
            <returns>the previous action</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetEntryTimeToLive(System.Int32)">
            <summary>
Sets the timeToLive duration for region entries.
</summary>
            <param name="timeToLive">
the timeToLive in seconds for entries in this region, or 0 to disable time-to-live
</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the new timeToLive changes entry expiration from
disabled to enabled or enabled to disabled
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetEntryIdleTimeoutAction(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Sets the idleTimeout action for region entries.
</summary>
            <param name="action">
the idleTimeout action for entries in this region
</param>
            <returns>the previous action</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AttributesMutator`2.SetEntryIdleTimeout(System.Int32)">
            <summary>
Sets the idleTimeout duration for region entries.
</summary>
            <param name="idleTimeout">
the idleTimeout in seconds for entries in this region, or 0 for no idle timeout
</param>
            <returns>the previous value</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the new idleTimeout changes entry expiration from
disabled to enabled or enabled to disabled.
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.AttributesMutator`2">
            <summary>
Supports modification of certain region attributes after the region
has been created.
</summary>
            <remarks>
                <para>
It is required that the attributes be completely initialized using an
<see cref="T:gemfire.AttributesFactory" /> before creating the region.
AttributesMutator can be applied to adjusting and tuning a subset of
attributes that are modifiable at runtime.
</para>
                <para>
The setter methods all return the previous value of the attribute.
</para>
            </remarks>
            <seealso cref="!:Region.AttributesMutator" />
            <seealso cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" />
            <seealso cref="T:gemfire.AttributesFactory" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheStatistics.#ctor(gemfire.CacheStatistics*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheStatistics.Create(gemfire.CacheStatistics*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheStatistics.get_LastAccessedTime">
            <summary>
Get the last accessed time of an entry or a region.
</summary>
            <returns>
the last accessed time expressed as the number of milliseconds since
January 1, 1970.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheStatistics.LastAccessedTime">
            <summary>
For an entry, returns the last time it was accessed via <c>Region.Get</c>.
For a region, returns the last time any of its entries or the entries of
its subregions were accessed with <c>Region.Get</c>.
</summary>
            <remarks>
                <para>
Any modifications will also update the <c>LastAccessedTime</c>,
so <c>LastAccessedTime</c> is always greater than or equal to
<c>LastModifiedTime</c>. The <c>LastAccessedTime</c> on a region is
propagated upward to parent regions, transitively, to the the root region.
</para>
                <para>
The number is expressed as the number of milliseconds since
January 1, 1970. The granularity may be as coarse as 100ms, so
the accuracy may be off by up to 50ms.
</para>
            </remarks>
            <returns>
the last access time of the region or the entry's value;
returns 0 if entry is invalid or access time is uninitialized.
</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="P:GemStone.GemFire.Cache.Generic.CacheStatistics.LastModifiedTime" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheStatistics.get_LastModifiedTime">
            <summary>
Get the last modified time of an entry or a region.
</summary>
            <returns>
the last accessed time expressed as the number of milliseconds since
January 1, 1970.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheStatistics.LastModifiedTime">
            <summary>
For an entry, returns the time that the entry's value was last modified.
For a region, returns the last time any of the region's entries' values or
the values in subregions' entries were modified.
</summary>
            <remarks>
                <para>
The modification may have been initiated locally, or it may have been
an update distributed from another cache. It may also have been a new
value provided by a loader. The modification time on a region is
propagated upward to parent regions, transitively, to the root region.
</para>
                <para>
The number is expressed as the number of milliseconds since January 1, 1970.
The granularity may be as coarse as 100ms, so the accuracy may be off by
up to 50ms.
</para>
                <para>
Entry and subregion creation will update the modification time on a
region, but <c>Region.Destroy</c>, <c>Region.DestroyRegion</c>,
<c>Region.Invalidate</c>, and <c>Region.InvalidateRegion</c>
do not update the modification time.
</para>
            </remarks>
            <returns>
the last modification time of the region or the entry;
returns 0 if the entry is invalid or the modification time is uninitialized.
</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.CreateSubRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheStatistics">
            <summary>
Defines common statistical information for both the region and its entries.
</summary>
            <remarks>
All of these methods may throw a <c>CacheClosedException</c>,
<c>RegionDestroyedException</c>, or <c>EntryDestroyedException</c>.
</remarks>
            <seealso cref="P:GemStone.GemFire.Cache.Region.Statistics" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionEntry.Statistics" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.LocalRegion`2.#ctor(gemfire.Region*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.LocalRegion`2.Create(gemfire.Region*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.#ctor(System.Char[])">
            <summary>
Allocates a new instance copying from the given character array.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.#ctor(System.String)">
            <summary>
Allocates a new instance from the given string.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableFileName.Value">
            <summary>
Gets the string value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.Equals(System.Object)">
            <summary>
Return true if this key matches other object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.Equals(GemStone.GemFire.Cache.Generic.ICacheableKey)">
            <summary>
Return true if this key matches other object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.GetHashCode">
            <summary>
Return the hashcode for this key.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.ToString">
            <summary>
Return a string representation of the object.
This returns the same string as <c>Value</c> property.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableFileName.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableFileName.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.Create(System.Char[])">
            <summary>
Static function to create a new instance from the
given character array.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableFileName.Create(System.String)">
            <summary>
Static function to create a new instance from the given string.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableFileName">
            <summary>
An immutable filename wrapper that can serve as a distributable
key object for caching as well as being a string value.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheListenerGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheListener
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.close(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources,
such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.afterRegionLive(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a region being live.
</summary>
            <remarks>
Each subregion gets its own <c>afterRegionLive</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region going live.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.ReadyForEvents" />
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.afterRegionDestroy(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a region being destroyed.
</summary>
            <remarks>
Events are not invoked for each individual entry that is destroyed
as a result of the region being destroyed. Each subregion, however,
gets its own <c>afterRegionDestroyed</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region destruction.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.afterRegionInvalidate(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a region being invalidated.
</summary>
            <remarks>
Events are not invoked for each individual value that is invalidated
as a result of the region being invalidated. Each subregion, however,
gets its own <c>regionInvalidated</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region invalidation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.afterRegionClear(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a region being cleared.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.afterDestroy(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of an entry being destroyed.
</summary>
            <param name="ev">
EntryEvent denotes the event object associated with the entry destruction.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.afterInvalidate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of an entry's value being invalidated.
</summary>
            <param name="ev">
EntryEvent denotes the event object associated with the entry invalidation.
</param>
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.afterUpdate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.afterCreate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <param name="ev">
Denotes the event object associated with the entry creation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedCacheListener</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheListener</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>ICacheListener</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedCacheListenerGeneric.#ctor(System.Object)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="userptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheListenerGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.ICacheListener" />
object and implements the native <c>gemfire::CacheListener</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.#ctor(gemfire.RegionService*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.Create(gemfire.RegionService*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.RootRegions``2">
            <summary>
Returns an array of root regions in the cache. This set is a
snapshot and is not backed by the cache.
</summary>
            <remarks>
It is not supported when Cache is created from Pool.
</remarks>
            <returns>array of regions</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.GetQueryService``2">
            <summary>
Get a query service object to be able to query the cache.
Supported only when cache is created from Pool(pool is in multiuserSecure mode)
</summary>
            <remarks>
Currently only works against the java server in native mode, and
at least some endpoints must have been defined in some regions
before actually firing a query.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.Close">
            <summary>
Terminates this object cache and releases all the local resources.
If Cache instance created from Pool(pool is in multiuser mode), then it reset user related security data.
</summary>
            <remarks>
After this cache is closed, any further
method call on this cache or any region object will throw
<c>CacheClosedException</c>, unless otherwise noted.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if the cache is already closed.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.AuthenticatedCache.IsClosed">
            <summary>
True if this cache has been closed.
</summary>
            <remarks>
After a new cache object is created, this method returns false.
After <see cref="M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.Close" /> is called on this cache object, this method
returns true.
</remarks>
            <returns>true if this cache is closed, otherwise false</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.AuthenticatedCache">
            <summary>
Provides a distributed cache.
</summary>
            <remarks>
Caches are obtained from static methods on the
<see cref="T:gemfire.CacheFactory" /> class.
<para>
When a cache is created a <see cref="T:GemStone.GemFire.Cache.Generic.DistributedSystem" />
must be specified.
</para><para>
When a cache will no longer be used, call <see cref="M:GemStone.GemFire.Cache.Cache.Close" />.
Once it <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> any attempt to use it
will cause a <c>CacheClosedException</c> to be thrown.
</para><para>
A cache can have multiple root regions, each with a different name.
</para></remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.#ctor(gemfire.RegionFactory*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.Create(gemfire.RegionFactory*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetPartitionResolver``2(GemStone.GemFire.Cache.Generic.IPartitionResolver`2{``0,``1})">
            <summary>
Sets the PartitionResolver for the <c>RegionAttributes</c> being created.
</summary>
            <param name="partitionresolver">
user-defined partition resolver, or null for no partition resolver
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetCacheListener``2(GemStone.GemFire.Cache.Generic.ICacheListener`2{``0,``1})">
            <summary>
Sets the CacheListener for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheListener">
user-defined cache listener, or null for no cache listener
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetCacheWriter``2(GemStone.GemFire.Cache.Generic.ICacheWriter`2{``0,``1})">
            <summary>
Sets the cache writer for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheWriter">
user-defined cache writer, or null for no cache writer
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetCacheLoader``2(GemStone.GemFire.Cache.Generic.ICacheLoader`2{``0,``1})">
            <summary>
Sets the cache loader for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheLoader">
a user-defined cache loader, or null for no cache loader
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetCloningEnabled(System.Boolean)">
            <summary>
Set cloning enabled flag for this region.
</summary>
            <remarks>
                <para>
If set to false, then there is no cloning will take place in case of delta.
Delta will be applied on the old value which will change old value in-place.
</para>
                <para>
The default if not set is 'false'
of <c>ScopeType.Local</c> scope. 
</para>
            </remarks>
            <param name="cloningEnabled">
if true, clone old value before applying delta so that in-place change would not occour..
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetCachingEnabled(System.Boolean)">
            <summary>
Set caching enabled flag for this region.
</summary>
            <remarks>
                <para>
If set to false, then no data is stored in the local process,
but events and distributions will still occur, and the region
can still be used to put and remove, etc...
</para>
                <para>
The default if not set is 'true', 'false' is illegal for regions
of <c>ScopeType.Local</c> scope. 
</para>
            </remarks>
            <param name="cachingEnabled">
if true, cache data for this region in this process.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetDiskPolicy(GemStone.GemFire.Cache.Generic.DiskPolicyType)">
            <summary>
Sets the disk policy type for the next <c>RegionAttributes</c> created.
</summary>
            <param name="diskPolicy">
the disk policy to use for the region
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetLruEntriesLimit(System.UInt32)">
            <summary>
Sets a limit on the number of entries that will be held in the cache.
If a new entry is added while at the limit, the cache will evict the
least recently used entry.
</summary>
            <param name="entriesLimit">
The limit of the number of entries before eviction starts.
Defaults to 0, meaning no LRU actions will used.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetConcurrencyLevel(System.Int32)">
            <summary>
Sets the concurrency level of the next <c>RegionAttributes</c>
created. This value is used in initializing the map that holds the entries.
</summary>
            <param name="concurrencyLevel">
the concurrency level of the entry map
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if concurrencyLevel is nonpositive
</exception>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetLoadFactor(System.Single)">
            <summary>
Sets the entry load factor for the next <c>RegionAttributes</c>
created. This value is
used in initializing the map that holds the entries.
</summary>
            <param name="loadFactor">the load factor of the entry map</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if loadFactor is nonpositive
</exception>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetInitialCapacity(System.Int32)">
            <summary>
Sets the entry initial capacity for the <c>RegionAttributes</c>
being created. This value is used in initializing the map that
holds the entries.
</summary>
            <param name="initialCapacity">the initial capacity of the entry map</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if initialCapacity is nonpositive
</exception>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetPoolName(System.String)">
            <summary>
Set the pool name for a Thin Client region.
</summary>
            <remarks>
The pool with the name specified must be already created.
</remarks>
            <param name="poolName">
The name of the pool to attach to this region.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetPersistenceManager(System.String,System.String,GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.String^})">
            <summary>
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
This must be used to set the PersistenceManager.
</summary>
            <param name="libPath">The path of the PersistenceManager shared library.</param>
            <param name="factoryFunctionName">
The name of the factory function to create an instance of PersistenceManager object.
</param>
            <param name="config">
The configuration properties to use for the PersistenceManager.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetPersistenceManager(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
This must be used to set the PersistenceManager.
</summary>
            <param name="libPath">The path of the PersistenceManager shared library.</param>
            <param name="factoryFunctionName">
The name of the factory function to create an instance of PersistenceManager object.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetRegionTimeToLive(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)">
            <summary>
Sets the timeToLive expiration attributes for the region itself for the
next <c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="timeToLive">
the timeToLive in seconds for the region as a whole.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetRegionIdleTimeout(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)">
            <summary>
Sets the idleTimeout expiration attributes for the region itself for the
next <c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="idleTimeout">
the idleTimeout in seconds for the region as a whole.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetEntryTimeToLive(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)">
            <summary>
Sets the timeToLive expiration attributes for region entries for the next
<c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="timeToLive">
the timeToLive in seconds for entries in this region.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetEntryIdleTimeout(GemStone.GemFire.Cache.Generic.ExpirationAction,System.UInt32)">
            <summary>
Sets the idleTimeout expiration attributes for region entries for the next
<c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="idleTimeout">
the idleTimeout in seconds for entries in this region.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetPartitionResolver(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the partition resolver of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>PartitionResolver</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>IPartitionResolver</c> for a managed library.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetCacheListener(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the listener of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheListener</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheListener</c> for a managed library.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetCacheWriter(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the writer of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheWriter</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheWriter</c> for a managed library.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionFactory.SetCacheLoader(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the loader of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheLoader</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheLoader</c> for a managed library.
</param>
            <returns>the instance of RegionFactory</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.RegionFactory">
            <summary>
This interface provides for the configuration and creation of instances of Region.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2.GetPartitionName(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1},System.Collections.Generic.ICollection`1{System.String^})">
            <summary>
This method is used to get the name of the partition for the given entry
operation.
</summary>
            <param name="opDetails"> 
the details of the entry event e.g. {@link Region#get(Object)}
</param>
            <param name="targetPartitions">
represents all the available primary partitions on the nodes
</param>
            <return> partition-name associated with node which allows mapping of given
data to user defined partition
</return>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.#ctor(gemfire.Execution*,GemStone.GemFire.Cache.Generic.IResultCollector`1{`0})">
            <summary>
Private constructor to wrap a native object pointer.
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.Create(gemfire.Execution*,GemStone.GemFire.Cache.Generic.IResultCollector`1{`0})">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.Execute(System.String)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.Execute(System.String,System.Boolean)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
            <param name="getResult"> Indicating if results are expected. </param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.Execute(System.String,System.Boolean,System.UInt32)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
            <param name="getResult"> Indicating if results are expected. </param>
            <param name="timeout"> Value to wait for the operation to finish before timing out.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.Execute(System.String,System.Boolean,System.UInt32,System.Boolean)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
            <param name="func"> The name of the function to be executed. </param>
            <param name="getResult"> Indicating if results are expected. </param>
            <param name="timeout"> Value to wait for the operation to finish before timing out.</param>
            <param name="isHA"> Whether the given function is HA. </param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.Execute(System.String,System.Boolean,System.UInt32,System.Boolean,System.Boolean)">
            <summary>
Execute a function, 
Return resultCollector.
</summary>
            <param name="func"> The name of the function to be executed. </param>
            <param name="getResult"> Indicating if results are expected. </param>
            <param name="timeout"> Value to wait for the operation to finish before timing out.</param>
            <param name="isHA"> Whether the given function is HA. </param>
            <param name="optimizeForWrite"> Whether the function should be optmized for write operation. </param>
            <deprecated>
parameters hasResult, isHA and optimizeForWrite are deprecated as of NativeClient 3.6, use of these parameters is ignored.
</deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.WithCollector(GemStone.GemFire.Cache.Generic.IResultCollector`1{`0})">
            <summary>
Add a result collector, 
Return self.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.WithArgs``1(``0)">
            <summary>
Add an argument, 
Return self.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Execution`1.WithFilter``1(System.Collections.Generic.ICollection`1{``0})">
            <summary>
Add a routing object, 
Return self.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Execution`1">
            <summary>
This class encapsulates events that occur for cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.FunctionService`1.#ctor(gemfire.FunctionService*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.FunctionService`1.OnServers(GemStone.GemFire.Cache.Generic.IRegionService)">
            <summary>
Creates a new Execution object on all servers in the pool.
</summary>
            <remarks />
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">when Pool has been closed.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.FunctionService`1.OnServer(GemStone.GemFire.Cache.Generic.IRegionService)">
            <summary>
Creates a new Execution object on one server.
</summary>
            <remarks />
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">when Pool has been closed.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.FunctionService`1.OnServers(GemStone.GemFire.Cache.Generic.Pool)">
            <summary>
Creates a new Execution object on all servers in the pool
</summary>
            <remarks />
            <exception cref="T:GemStone.GemFire.Cache.Generic.UnsupportedOperationException">unsupported operation exception, when Pool is in multiusersecure mode.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.FunctionService`1.OnServer(GemStone.GemFire.Cache.Generic.Pool)">
            <summary>
Creates a new Execution object on one server
</summary>
            <remarks />
            <exception cref="T:GemStone.GemFire.Cache.Generic.UnsupportedOperationException">unsupported operation exception, when Pool is in multiusersecure mode.</exception>
        </member>
        <member name="M:gemfire.Execution.withCollector(gemfire.SharedPtr&lt;gemfire.ResultCollector&gt;)">
Specifies the {@link ResultCollector} that will receive the results after
the function has been executed.
@return an Execution with a collector
@throws IllegalArgumentException if {@link ResultCollector} is NULLPTR
@see ResultCollector

</member>
        <member name="M:gemfire.Execution.withArgs(gemfire.SharedPtr&lt;gemfire.Serializable&gt;)">
Specifies the user data passed to the function when it is executed.
@param args user data passed to the function execution
@return an Execution with args 
@throws IllegalArgumentException if the input parameter is NULLPTR
                

</member>
        <member name="M:gemfire.Execution.withFilter(gemfire.SharedPtr&lt;gemfire.CacheableVector&gt;)">
Specifies a data filter of routing objects for selecting the GemFire members
to execute the function.
<p>
If the filter set is empty the function is executed on all members
that have the  FunctionService::onRegion(Region).</p>
@param routingObj Set defining the data filter to be used for executing the function
@return an Execution with the filter
@throws IllegalArgumentException if filter passed is NULLPTR.
@throws UnsupportedOperationException if not called after
   FunctionService::onRegion(Region).

</member>
        <member name="T:gemfire.Execution">
@class Execution Execution.hpp
gathers results from function execution
@see FunctionService

</member>
        <member name="M:gemfire.ResultCollector.clearResults">
GemFire will invoke this method before re-executing function (in case of
Function Execution HA) This is to clear the previous execution results from
the result collector
@since 6.5

</member>
        <member name="M:gemfire.ResultCollector.endResults">
GemFire will invoke this method when function execution has completed
and all results for the execution have been obtained and  added to the ResultCollector}

</member>
        <member name="M:gemfire.ResultCollector.addResult(gemfire.SharedPtr&lt;gemfire.Serializable&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Adds a single function execution result to the ResultCollector

 @param resultOfSingleExecution
 @since 5.8LA

</member>
        <member name="M:gemfire.ResultCollector.getResult(System.UInt32)">
 Returns the result of function execution, potentially blocking until all the results are available.

 @param timeout in seconds, if result is not ready within this time, exception will be thrown
 @return the result
 @throws FunctionException if result retrieval fails

</member>
        <member name="M:gemfire.ResultCollector.#ctor">
@brief public methods

</member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableObjectArray.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableObjectArray.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.Create(System.Int32)">
            <summary>
Static function to create a new instance with given initial size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.Create(System.Collections.Generic.IEnumerable`1{System.Object^})">
            <summary>
Static function to create a new instance copying from the
given collection.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the vector.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.#ctor(System.Collections.Generic.IEnumerable`1{System.Object^})">
            <summary>
Allocates a new instance copying from the given collection.
</summary>
            <param name="collection">
The collection whose elements are copied to this list.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableObjectArray.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableObjectArray">
            <summary>
A mutable <c>IGFSerializable</c> object array wrapper that can serve
as a distributable object for caching. Though this class provides
compatibility with java Object[] serialization, it provides the
semantics of .NET generic <c>List</c> class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap.Create(System.Int32)">
            <summary>
Static function to create a new instance with given initial size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap.Create(System.Object)">
            <summary>
Static function to create a new instance copying from the
given dictionary.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the HashMap.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap.#ctor(System.Object)">
            <summary>
Allocates a new instance copying from the given dictionary.
</summary>
            <param name="dictionary">
The dictionary whose elements are copied to this HashMap.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableIdentityHashMap">
            <summary>
A mutable <c>ICacheableKey</c> to <c>IGFSerializable</c> hash map
that can serve as a distributable object for caching. This class
extends .NET generic <c>Dictionary</c> class. This class is meant
as a means to interoperate with java server side
<c>IdentityHashMap</c> class objects but is intentionally not
intended to provide <c>java.util.IdentityHashMap</c> semantics.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashMap.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableHashMap.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableHashMap.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashMap.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashMap.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashMap.Create(System.Object)">
            <summary>
Static function to create a new instance copying from the
given dictionary.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashMap.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashMap.#ctor(System.Object)">
            <summary>
Allocates a new instance copying from the given dictionary.
</summary>
            <param name="dictionary">
The dictionary whose elements are copied to this HashMap.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableHashMap.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableHashMap">
            <summary>
A mutable <c>ICacheableKey</c> to <c>IGFSerializable</c> hash map
that can serve as a distributable object for caching. This class
extends .NET generic <c>Dictionary</c> class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.#ctor(gemfire.Cache*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.Create(gemfire.Cache*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.GetPdxIgnoreUnreadFields">
            <summary>
Returns whether Cache saves unread fields for Pdx types.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.CreateAuthenticatedView(GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.Object^},System.String)">
            <summary>
Returns the instance of <see cref="T:GemStone.GemFire.Cache.Generic.IRegionService" /> to do the operation on Cache with different Credential.
</summary>
            <remarks>
Deafault pool should be in multiuser mode <see cref="M:GemStone.GemFire.Cache.CacheFactory.SetMultiuserAuthentication(System.Boolean)" /></remarks>
            <param name="credentials">the user Credentials.</param>
            <param name="poolName">Pool, which is in multiuser mode.</param>
            <returns>Instance of IRegionService</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.CreateAuthenticatedView(GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.Object^})">
            <summary>
Returns the instance of <see cref="T:GemStone.GemFire.Cache.Generic.IRegionService" /> to do the operation on Cache with different Credential.
</summary>
            <remarks>
Deafault pool should be in multiuser mode <see cref="M:GemStone.GemFire.Cache.CacheFactory.SetMultiuserAuthentication(System.Boolean)" /></remarks>
            <param name="credentials">the user Credentials.</param>
            <returns>Instance of IRegionService</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.CreateRegionFactory(GemStone.GemFire.Cache.Generic.RegionShortcut)">
            <summary>
Returns the instance of <see cref="T:GemStone.GemFire.Cache.Generic.RegionFactory" /> to create the region
</summary>
            <remarks>
Pass the <see cref="T:GemStone.GemFire.Cache.Generic.RegionShortcut" /> to set the deafult region attributes
</remarks>
            <param name="regionShortcut">the regionShortcut to set the default region attributes</param>
            <returns>Instance of RegionFactory</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.GetQueryService``2(System.String)">
            <summary>
Get a query service object to be able to query the cache.
Use only when Cache has more than one Pool.
</summary>
            <remarks>
Currently only works against the java server in native mode, and
at least some endpoints must have been defined in some regions
before actually firing a query.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.GetQueryService``2">
            <summary>
Get a query service object to be able to query the cache.
Supported only when cache is created from Pool(pool is in multiuserSecure mode)
</summary>
            <remarks>
Currently only works against the java server in native mode, and
at least some endpoints must have been defined in some regions
before actually firing a query.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.RootRegions``2">
            <summary>
Returns an array of root regions in the cache. This set is a
snapshot and is not backed by the cache.
</summary>
            <remarks>
It is not supported when Cache is created from Pool.
</remarks>
            <returns>array of regions</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.GetRegion``2(System.String)">
            <summary>
Returns an existing region given the full path from root, or null 
if no such region exists.
</summary>
            <remarks>
If Pool attached with Region is in multiusersecure mode then don't use return instance of region as no credential are attached with this instance.
Get region from RegionService instance of Cache.<see cref="!:Cache.CreateAuthenticatedView(PropertiesPtr)" />.
</remarks>
            <param name="path">the pathname of the region</param>
            <returns>the region</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.ReadyForEvents">
            <summary>
Send the client-ready message to the server for a durable client.        
</summary>
            <remarks>
This method should only be called for durable clients and
with a cache server version 5.5 onwards.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if there was a problem sending the message to the server.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.Close(System.Boolean)">
            <summary>
Terminates this object cache and releases all the local resources.
</summary>
            <remarks>
After this cache is closed, any further
method call on this cache or any region object will throw
<c>CacheClosedException</c>, unless otherwise noted.
</remarks>
            <param name="keepalive">whether to keep a durable client's queue alive</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if the cache is already closed.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.Close">
            <summary>
Terminates this object cache and releases all the local resources.
</summary>
            <remarks>
After this cache is closed, any further
method call on this cache or any region object will throw
<c>CacheClosedException</c>, unless otherwise noted.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if the cache is already closed.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Cache.CacheTransactionManager">
            <summary>
Returns the cache transaction manager of
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> this cache.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Cache.DistributedSystem">
            <summary>
Returns the distributed system used to
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> this cache.
</summary>
            <remarks>
This method does not throw
<c>CacheClosedException</c> if the cache is closed.
</remarks>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Cache.IsClosed">
            <summary>
True if this cache has been closed.
</summary>
            <remarks>
After a new cache object is created, this method returns false.
After <see cref="M:GemStone.GemFire.Cache.Generic.Cache.Close" /> is called on this cache object, this method
returns true.
</remarks>
            <returns>true if this cache is closed, otherwise false</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Cache.Name">
            <summary>
Returns the name of this cache.
</summary>
            <remarks>
This method does not throw
<c>CacheClosedException</c> if the cache is closed.
</remarks>
            <returns>the string name of this cache</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Cache.InitializeDeclarativeCache(System.String)">
            <summary>
Initializes the cache from an XML file.
</summary>
            <param name="cacheXml">pathname of a <c>cache.xml</c> file</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Cache">
            <summary>
Provides a distributed cache.
</summary>
            <remarks>
Caches are obtained from Create methods on the
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> class.
<para>
When a cache will no longer be used, call <see cref="M:GemStone.GemFire.Cache.Cache.Close" />.
Once it <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> any attempt to use it
will cause a <c>CacheClosedException</c> to be thrown.
</para><para>
A cache can have multiple root regions, each with a different name.
</para></remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionAttributes`2.#ctor(gemfire.RegionAttributes*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionAttributes`2.Create(gemfire.RegionAttributes*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.ClassId">
            <summary>
Returns the classId of this class for serialization.
</summary>
            <returns>classId of the Properties class</returns>
            <seealso cref="!:../../IGFSerializable.ClassId" />
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionAttributes`2.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserializes this Properties object.
</summary>
            <param name="input">the DataInput stream to use for reading data</param>
            <returns>the deserialized Properties object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionAttributes`2.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this Properties object.
</summary>
            <param name="output">the DataOutput stream to use for serialization</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.PersistenceProperties">
            <summary>
Returns the properties set for persistence.
</summary>
            <returns>properties for the PersistenceManager</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.PersistenceFactory">
            <summary>
Returns the symbol name of the factory function from which
the persistence manager will be created on a cache server.
</summary>
            <returns>the PersistenceManager factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.PersistenceLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the PersistenceManager library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CloningEnabled">
            <summary>
True if cloning is enabled for in case of delta.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.ClientNotificationEnabled">
            <summary>
True if client notification is enabled.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.PoolName">
            <summary>
This method returns the name of the attached pool.
</summary>
            <returns>pool name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.Endpoints">
            <summary>
This method returns the list of endpoints (servername:portnumber) separated by commas.
</summary>
            <returns>list of endpoints</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionAttributes`2.ValidateSerializableAttributes">
            <summary>
Throws IllegalStateException if the attributes are not suited for serialization
such as those that have a cache callback (listener, loader, or writer) set
directly instead of providing the library path and factory function.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">if the attributes cannot be serialized</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionAttributes`2.Equals(System.Object)">
            <summary>
True if all the attributes are equal to those of <c>other</c>.
</summary>
            <param name="other">attribute object to compare</param>
            <returns>true if equal</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionAttributes`2.Equals(GemStone.GemFire.Cache.Generic.RegionAttributes`2{`0,`1})">
            <summary>
True if all the attributes are equal to those of <c>other</c>.
</summary>
            <param name="other">attribute object to compare</param>
            <returns>true if equal</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheWriterFactory">
            <summary>
Returns the symbol name of the factory function from which
the loader will be created on a cache server.
</summary>
            <returns>the CacheWriter factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheWriterLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the CacheWriter library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.PartitionResolverFactory">
            <summary>
Returns the symbol name of the factory function from which
the loader will be created on a cache server.
</summary>
            <returns>the PartitionResolver factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheListenerFactory">
            <summary>
Returns the symbol name of the factory function from which
the loader will be created on a cache server.
</summary>
            <returns>the CacheListener factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.PartitionResolverLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the PartitionResolver library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheListenerLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the CacheListener library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheLoaderFactory">
            <summary>
Rreturns the symbol name of the factory function from which
the loader will be created on a cache server.
</summary>
            <returns>the CacheLoader factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheLoaderLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the CacheLoader library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.LruEvictionAction">
            <summary>
Returns the ExpirationAction used for LRU Eviction, default is LOCAL_DESTROY.
</summary>
            <returns>the LRU eviction action</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.DiskPolicy">
            <summary>
Returns the disk policy type of the region.
</summary>
            <returns>the disk policy type, default is null</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.LruEntriesLimit">
            <summary>
Returns the maximum number of entries this cache will hold before
using LRU eviction. 
</summary>
            <returns>the maximum LRU size, or 0 for no limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.ConcurrencyLevel">
            <summary>
Returns the concurrency level of the entry's local cache.
</summary>
            <returns>the concurrency level</returns>
            <seealso cref="T:gemfire.AttributesFactory" />
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.LoadFactor">
            <summary>
Returns the load factor of the entry's local cache.
</summary>
            <returns>the load factor</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.InitialCapacity">
            <summary>
Returns the initial capacity of the entry's local cache.
</summary>
            <returns>the initial capacity</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CachingEnabled">
            <summary>
If true, this region will store data in the current process.
</summary>
            <returns>true if caching is enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.Scope">
            <summary>
Returns the scope of the region.
</summary>
            <returns>the region's scope</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.EntryIdleTimeoutAction">
            <summary>
Gets the <c>idleTimeout</c> expiration action for entries in this region.
</summary>
            <returns>the idleTimeout action for entries in this region</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.EntryIdleTimeout">
            <summary>
Gets the <c>idleTimeout</c> value for entries in this region.
</summary>
            <returns>the idleTimeout duration for entries in this region, in seconds</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.EntryTimeToLiveAction">
            <summary>
Gets the <c>timeToLive</c> expiration action for entries in this region.
</summary>
            <returns>the timeToLive action for entries in this region</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.EntryTimeToLive">
            <summary>
Gets the <c>timeToLive</c> value for entries in this region.
</summary>
            <returns>the timeToLive duration for entries in this region, in seconds</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.RegionIdleTimeoutAction">
            <summary>
Gets the <c>idleTimeout</c> expiration action for the region as a whole.
</summary>
            <returns>the idleTimeout action for this region</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.RegionIdleTimeout">
            <summary>
Gets the <c>idleTimeout</c> value for the region as a whole.
</summary>
            <returns>the IdleTimeout duration for this region, in seconds</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.RegionTimeToLiveAction">
            <summary>
Gets the <c>timeToLive</c> expiration action for the region as a whole.
</summary>
            <returns>the timeToLive action for this region</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.RegionTimeToLive">
            <summary>
Gets the <c>timeToLive</c> value for the region as a whole.
</summary>
            <returns>the timeToLive duration for this region, in seconds</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.PartitionResolver">
            <summary>
Gets the partition resolver for the region.
</summary>
            <returns>
region's <c>IPartitionResolver</c> or null if none
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheListener">
            <summary>
Gets the cache listener for the region.
</summary>
            <returns>
region's <c>ICacheListener</c> or null if none
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheWriter">
            <summary>
Gets the cache writer for the region.
</summary>
            <returns>
region's <c>ICacheWriter</c> or null if none
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionAttributes`2.CacheLoader">
            <summary>
Gets the cache loader for the region.
</summary>
            <returns>
region's <c>ICacheLoader</c> or null if none
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2">
            <summary>
Defines attributes for configuring a region.
</summary>
            <remarks>
These are
<c>ICacheListener</c>, <c>ICacheLoader</c>, <c>ICacheWriter</c>,
scope, mirroring, and expiration attributes
for the region itself; expiration attributes for the region entries;
and whether statistics are enabled for the region and its entries.

To create an instance of this interface, use
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.CreateRegionAttributes" />.

For compatibility rules and default values, see <see cref="T:gemfire.AttributesFactory" />.
<para>
Note that the <c>RegionAttributes</c> are not distributed with the region.
</para></remarks>
            <seealso cref="T:gemfire.AttributesFactory" />
            <seealso cref="T:GemStone.GemFire.Cache.Generic.AttributesMutator`2" />
            <seealso cref="P:GemStone.GemFire.Cache.Region.Attributes" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPartitionResolver`2.GetRoutingObject(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1})">
            <summary>
return object associated with entry event which allows the Partitioned Region to store associated data together.
</summary>
            <remarks>
throws RuntimeException - any exception thrown will terminate the operation and the exception will be passed to the
calling thread.
</remarks>
            <param name="key">
key the detail of the entry event.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPartitionResolver`2.GetName">
            <summary>
Returns the name of the PartitionResolver.
</summary>
            <remarks>
                <para>
This function does not throw any exception.
</para>
                <returns>
the name of the PartitionResolver
</returns>
            </remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.Close(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources,
such as database connections. Any runtime exceptions this method
throws will be logged.
</remarks>
            <param>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionLive(GemStone.GemFire.Cache.Generic.RegionEvent`2{`0,`1})">
            <summary>
Handles the event of a region going live.
</summary>
            <remarks>
Each subregion gets its own <c>AfterRegionLive</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region going live.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.ReadyForEvents" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDestroy(GemStone.GemFire.Cache.Generic.RegionEvent`2{`0,`1})">
            <summary>
Handles the event of a region being destroyed.
</summary>
            <remarks>
Events are not invoked for each individual entry that is destroyed
as a result of the region being destroyed. Each subregion, however,
gets its own <c>AfterRegionDestroyed</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region destruction.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionInvalidate(GemStone.GemFire.Cache.Generic.RegionEvent`2{`0,`1})">
            <summary>
Handles the event of a region being invalidated.
</summary>
            <remarks>
Events are not invoked for each individual value that is invalidated
as a result of the region being invalidated. Each subregion, however,
gets its own <c>RegionInvalidated</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region invalidation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionClear(GemStone.GemFire.Cache.Generic.RegionEvent`2{`0,`1})">
            <summary>
Handles the event of a region being cleared.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterDestroy(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1})">
            <summary>
Handles the event of an entry being destroyed.
</summary>
            <param name="ev">
EntryEvent denotes the event object associated with the entry destruction.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterInvalidate(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1})">
            <summary>
Handles the event of an entry's value being invalidated.
</summary>
            <param name="ev">
EntryEvent denotes the event object associated with the entry invalidation.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterUpdate(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1})">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterCreate(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1})">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <param name="ev">
Denotes the event object associated with the entry creation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ICacheListener`2">
            <summary>
An application plug-in that can be installed on a region.
</summary>
            <remarks>
Listeners are change notifications that are invoked
AFTER the change has occured for region update operations on a client.
Listeners also receive notifications when entries in a region are modified.
Multiple events can cause concurrent invocation
of <c>ICacheListener</c> methods.  If event A occurs before event B,
there is no guarantee that their corresponding <c>ICacheListener</c>
method invocations will occur in the same order. Any exceptions thrown by
the listener are caught by GemFire and logged. If the exception is due to
listener invocation on the same thread where a region operation has been
performed, then a <c>CacheListenerException</c> is thrown back to
the application. If the exception is for a notification received from
server then that is logged and the notification thread moves on to
receiving other notifications.
<para>
A cache listener is defined in the <see cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" />.
</para>

There are two cases in which listeners are invoked. The first is when a
region modification operation (e.g. put, create, destroy, invalidate)
is performed. For this case it is important to ensure that minimal work is
done in the listener before returning control back to Gemfire since the
operation will block till the listener has not completed. For example,
a listener implementation may choose to hand off the event to a thread pool
that then processes the event on its thread rather than the listener thread.
The second is when notifications are received from java server as a result
of region register interest calls (<c>Region.RegisterKeys</c> etc),
or invalidate notifications when notify-by-subscription is false on the
server. In this case the methods of <c>ICacheListener</c> are invoked
asynchronously (i.e. does not block the thread that receives notification
messages). Additionally for the latter case of notifications from server,
listener is always invoked whether or not local operation is successful
e.g. if a destroy notification is received and key does not exist in the
region, the listener will still be invoked. This is different from the
first case where listeners are invoked only when the region update
operation succeeds.
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener" />
            <seealso cref="T:GemStone.GemFire.Cache.Generic.ICacheLoader`2" />
            <seealso cref="T:GemStone.GemFire.Cache.Generic.ICacheWriter`2" />
            <seealso cref="T:GemStone.GemFire.Cache.Generic.CacheListenerException" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheWriter`2.Close(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
                <para>
Implementations should clean up any external
resources, such as database connections. Any runtime exceptions this method
throws will be logged.
</para>
                <para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para>
            </remarks>
            <param name="region">region to close</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheWriter`2.BeforeRegionDestroy(GemStone.GemFire.Cache.Generic.RegionEvent`2{`0,`1})">
            <summary>
Called before this region is destroyed.
</summary>
            <param name="ev">
event object associated with destroying the region
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheWriter`2.BeforeRegionClear(GemStone.GemFire.Cache.Generic.RegionEvent`2{`0,`1})">
            <summary>
Called before this region is cleared.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheWriter`2.BeforeDestroy(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1})">
            <summary>
Called before an entry is destroyed.
</summary>
            <remarks>
The entry being destroyed may or may
not exist in the local cache where the CacheWriter is installed. This method
is <em>not</em> called as a result of expiration or
<see cref="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />.
</remarks>
            <param name="ev">
event object associated with destroying the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheWriter`2.BeforeCreate(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1})">
            <summary>
Called before an entry is created. Entry creation is initiated by a
<c>Create</c>, a <c>Put</c>, or a <c>Get</c>.
</summary>
            <remarks>
The <c>CacheWriter</c> can determine whether this value comes from a
<c>Get</c> or not from <c>Load</c>. The entry being
created may already exist in the local cache where this <c>CacheWriter</c>
is installed, but it does not yet exist in the cache where the operation was initiated.
</remarks>
            <param name="ev">
event object associated with creating the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheWriter`2.BeforeUpdate(GemStone.GemFire.Cache.Generic.EntryEvent`2{`0,`1})">
            <summary>
Called before an entry is updated. The entry update is initiated by a
<c>Put</c> or a <c>Get</c> that causes the loader to update an existing entry.
</summary>
            <remarks>
The entry previously existed in the cache where the operation was
initiated, although the old value may have been null. The entry being
updated may or may not exist in the local cache where the CacheWriter is
installed.
</remarks>
            <param name="ev">
event object associated with updating the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ICacheWriter`2">
            <summary>
An application plug-in that can be installed on a region.
Defines methods that are called <b>before</b> entry modification,
such as writing the value to a database.
</summary>
            <remarks>
                <para>
A distributed region will typically have a single cache writer.
If the application is designed such that all or most updates to
a region occur on a node, the cache writer for the region should
be installed at that node. 
</para>
                <para>
A cache writer is defined in the <see cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" />.
</para>
                <para>
Cache writer invocations are initiated by the node where the entry or
region modification occurs. 
</para>
                <para>
Before a region is updated via a put, create, or destroy operation,
GemFire will call an <c>ICacheWriter</c> that is installed anywhere in any
participating cache for that region, preferring a local <c>ICacheWriter</c>
if there is one. Usually there will be only one <c>ICacheWriter</c> in
the distributed system. If there are multiple <c>ICacheWriter</c>s
available in the distributed system, the GemFire
implementation always prefers one that is stored locally, or else picks one
arbitrarily. In any case, only one <c>ICacheWriter</c> will be invoked.
</para>
                <para>
The typical use for a <c>ICacheWriter</c> is to update a database.
Application writers should implement these methods to execute
application-specific behavior before the cache is modified.
</para>
                <para>
Note that cache writer callbacks are synchronous callbacks and have the ability
to veto the cache update. Since cache writer invocations require communications
over the network, (especially if they are not co-located on the nodes where the
change occurs) the use of cache writers presents a performance penalty.
</para>
                <para>
The <c>ICacheWriter</c> is capable of aborting the update to the cache by throwing
a <c>CacheWriterException</c>. This exception or any runtime exception
thrown by the <c>ICacheWriter</c> will abort the operation, and the
exception will be propagated to the initiator of the operation, regardless
of whether the initiator is in the same process as the <c>ICacheWriter</c>.
</para>
            </remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheWriter(GemStone.GemFire.Cache.ICacheWriter)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheWriter" />
            <seealso cref="T:GemStone.GemFire.Cache.Generic.ICacheLoader`2" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheListener" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionEvent`2.#ctor(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionEvent`2.RemoteOrigin">
            <summary>
Returns true if the event originated in a remote process.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionEvent`2.CallbackArgument">
            <summary>
Returns the callbackArgument passed to the method that generated
this event. See the <see cref="P:GemStone.GemFire.Cache.Generic.RegionEvent`2.Region" /> interface methods
that take a callbackArgument parameter.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.RegionEvent`2.Region">
            <summary>
Return the region this event occurred in.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.RegionEvent`2.#ctor(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1},System.Object,System.Boolean)">
            <summary>
Constructor to create a <c>RegionEvent</c> for a given region.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if region is null
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.RegionEvent`2">
            <summary>
This class encapsulates events that occur for a region.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.EntryEvent`2.#ctor(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.EntryEvent`2.RemoteOrigin">
            <summary>
If the event originated in a remote process, returns true.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.EntryEvent`2.CallbackArgument">
            <summary>
Returns the callbackArgument passed to the method that generated
this event. See the <see cref="P:GemStone.GemFire.Cache.Generic.EntryEvent`2.Region" /> interface methods
that take a callbackArgument parameter.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.EntryEvent`2.NewValue">
            <summary>
Return the updated value from this event. If the event is a destroy
or invalidate operation, then the new value will be NULL.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.EntryEvent`2.OldValue">
            <summary>
Returns 'null' if there was no value in the cache. If the prior state
 of the entry was invalid, or non-existent/destroyed, then the old
value will be 'null'.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.EntryEvent`2.Key">
            <summary>
Returns the key this event describes.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.EntryEvent`2.Region">
            <summary>
Return the region this event occurred in.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.EntryEvent`2.#ctor(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1},`0,`1,`1,System.Object,System.Boolean)">
            <summary>
Constructor to create an <c>EntryEvent</c> for the given region.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.EntryEvent`2">
            <summary>
This class encapsulates events that occur for an entry in a region.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheLoader`2.Close(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources, such as
database connections. Any runtime exceptions this method throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheLoader`2.Load(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1},`0,System.Object)">
            <summary>
Loads a value. Application writers should implement this
method to customize the loading of a value.
</summary>
            <remarks>
This method is called
by the caching service when the requested value is not in the cache.
Any exception thrown by this method is propagated back to and thrown
by the invocation of <see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" /> that triggered this load.
</remarks>
            <param name="region">a Region for which this is called.</param>
            <param name="key">the key for the cacheable</param>
            <param name="callbackArgument" />
            <returns>
the value supplied for this key, or null if no value can be
supplied. 
If every available loader returns
a null value, <see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" /> will return null.
</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ICacheLoader`2">
            <summary>
A data-loading application plug-in that can be installed on a region.
</summary>
            <remarks>
Loaders facilitate loading of data into the cache from a third-party data source. 
When an application does a
lookup for a key in a region and it does not exist, GemFire checks to
see if any loaders are available for the region in the system and
invokes them to get the value for the key into the cache.
<para>
A cache loader is defined in the <see cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" />.
</para>
When <see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" /> is called for a region
entry that has a null value, the <see cref="M:GemStone.GemFire.Cache.ICacheLoader.Load(GemStone.GemFire.Cache.Region,GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
method of the region's cache loader is invoked.  The <c>Load</c> method
creates the value for the desired key by performing an operation such
as a database query. 
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheLoader(GemStone.GemFire.Cache.ICacheLoader)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheLoader" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheListener" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheWriter" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheLoader">
            <summary>
CacheLoader
</summary>
            <remarks>
CacheLoader
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DiskPolicy.IsNone(GemStone.GemFire.Cache.Generic.DiskPolicyType)">
            <summary>
True if the current policy is <c>None</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DiskPolicy.IsOverflow(GemStone.GemFire.Cache.Generic.DiskPolicyType)">
            <summary>
True if the current policy is <c>Overflows</c>.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DiskPolicy">
            <summary>
Static class containing convenience methods for <c>DiskPolicyType</c>.
</summary>
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.DiskPolicy" />
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetDiskPolicy(GemStone.GemFire.Cache.DiskPolicyType)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DiskPolicyType">
            <summary>
Enumerated type for disk policy.
Contains values for setting the disk policy type.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.DiskPolicyType.Overflows">
            <summary>Overflow to disk.</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.DiskPolicyType.None">
            <summary>No policy.</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Scope.IsAck(GemStone.GemFire.Cache.Generic.ScopeType)">
            <summary>
True if acknowledgements are required for the given scope.
</summary>
            <param name="type">scope</param>
            <returns>
true if <c>DistributedAck</c>, false otherwise
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Scope.IsDistributedAck(GemStone.GemFire.Cache.Generic.ScopeType)">
            <summary>
True if the given scope is distributed-ack.
</summary>
            <param name="type">scope</param>
            <returns>true if <c>DistributedAck</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Scope.IsDistributedNoAck(GemStone.GemFire.Cache.Generic.ScopeType)">
            <summary>
True if the given scope is distributed-no-ack.
</summary>
            <param name="type">scope</param>
            <returns>true if <c>DistributedNoAck</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Scope.IsDistributed(GemStone.GemFire.Cache.Generic.ScopeType)">
            <summary>
True if the given scope is one of the distributed scopes.
</summary>
            <param name="type">scope</param>
            <returns>
true if other than <c>Local</c>; could be <c>Invalid</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Scope.IsLocal(GemStone.GemFire.Cache.Generic.ScopeType)">
            <summary>
True if the given scope is local.
</summary>
            <param name="type">scope</param>
            <returns>true if <c>Local</c></returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Scope">
            <summary>
Static class containing convenience methods for <c>ScopeType</c>.
</summary>
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.Scope" />
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetScope(GemStone.GemFire.Cache.ScopeType)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ScopeType">
            <summary>
Enumerated type for region distribution scope.
Contains values for setting <c>Scope</c>.
Local scope is invalid (it is a non-native client local region), and
DistributedAck and DistributedNoAck have the same behavior.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ScopeType.Invalid">
            <summary>Invalid scope.</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ScopeType.Global">
            <summary>
Distribute with full interprocess synchronization
-- NOT IMPLEMENTED.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ScopeType.DistributedAck">
            <summary>
Distribute and wait for all peers to acknowledge.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ScopeType.DistributedNoAck">
            <summary>
Distribute without waiting for acknowledgement.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ScopeType.Local">
            <summary>No distribution.</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Expiration.IsDistributed(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Returns true if this action is distributed.
</summary>
            <returns>true if this is an <c>Invalidate</c> or
a <c>Destroy</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Expiration.IsLocal(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Returns true if this action is local.
</summary>
            <returns>true if this is <c>LocalInvalidate</c> or
<c>LocalDestroy</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Expiration.IsLocalDestroy(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Returns true if this action is local destroy.
</summary>
            <returns>true if this is <c>LocalDestroy</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Expiration.IsDestroy(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Returns true if this action is distributed destroy.
</summary>
            <returns>true if this is <c>Destroy</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Expiration.IsLocalInvalidate(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Returns true if this action is local invalidate.
</summary>
            <returns>true if this is a <c>LocalInvalidate</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Expiration.IsInvalidate(GemStone.GemFire.Cache.Generic.ExpirationAction)">
            <summary>
Returns true if this action is distributed invalidate.
</summary>
            <returns>true if this an <c>Invalidate</c></returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Expiration">
            <summary>
Static class containing convenience methods for <c>ExpirationAction</c>.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ExpirationAction">
            <summary>
Enumerated type for expiration (LRU) actions.
Contains values for setting an action type.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ExpirationAction.InvalidAction">
            <summary>Invalid action type.</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ExpirationAction.LocalDestroy">
            <summary>
When expired, destroyed locally only.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ExpirationAction.Destroy">
            <summary>
When the region or cached object expires, it is destroyed.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ExpirationAction.LocalInvalidate">
            <summary>
When expired, invalidated locally only.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.ExpirationAction.Invalidate">
            <summary>
When the region or cached object expires, it is invalidated.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IGemFireCache.GetPdxIgnoreUnreadFields">
            <summary>
Returns whether Cache saves unread fields for Pdx types.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IGemFireCache.CacheTransactionManager">
            <summary>
Returns the cache transaction manager of
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> this cache.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IGemFireCache.DistributedSystem">
            <summary>
Returns the distributed system used to
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> this cache.
</summary>
            <remarks>
This method does not throw
<c>CacheClosedException</c> if the cache is closed.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IGemFireCache.InitializeDeclarativeCache(System.String)">
            <summary>
Initializes the cache from an XML file.
</summary>
            <param name="cacheXml">pathname of a <c>cache.xml</c> file</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IGemFireCache.Name">
            <summary>
Returns the name of this cache.
</summary>
            <remarks>
This method does not throw
<c>CacheClosedException</c> if the cache is closed.
</remarks>
            <returns>the string name of this cache</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IGemFireCache">
            <summary>
GemFireCache represents the singleton cache that must be created
in order to connect to Gemfire server.
</summary>
            <remarks>
Caches are obtained from Crest methods on the
<see cref="M:GemStone.GemFire.Cache.CacheFactory.Create" /> class.
<para>
When a cache is created a <see cref="P:GemStone.GemFire.Cache.Generic.IGemFireCache.DistributedSystem" />
must be specified.
</para><para>
When a cache will no longer be used, call <see cref="M:GemStone.GemFire.Cache.Cache.Close" />.
Once it <see cref="P:GemStone.GemFire.Cache.Cache.IsClosed" /> any attempt to use it
will cause a <c>CacheClosedException</c> to be thrown.
</para><para>
A cache can have multiple root regions, each with a different name.
</para></remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheTransactionManager.#ctor(gemfire.CacheTransactionManager*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheTransactionManager.Exists">
            <summary>
Reports the existence of a Transaction for this thread
</summary>
            <returns>true if a transaction exists, false otherwise</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheTransactionManager.Rollback">
            <summary>
Roll back the transaction associated with the current thread. When
this method completes, the thread is no longer associated with a
transaction and the transaction context is destroyed.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the thread is not associated with a transaction
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheTransactionManager.Commit">
            <summary>
Commit the transaction associated with the current thread. If
the commit operation fails due to a conflict it will destroy
the transaction state and throw a <c>CommitConflictException</c>. 
If the commit operation succeeds,it returns after the transaction 
state has been merged with committed state.  When this method 
completes, the thread is no longer associated with a transaction.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the thread is not associated with a transaction
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CommitConflictException">
if the commit operation fails due to a write conflict.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheTransactionManager.Begin">
            <summary>
Creates a new transaction and associates it with the current thread.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
Throws exception if the thread is already associated with a transaction
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheTransactionManager">
            <summary>
CacheTransactionManager encapsulates the transactions for a cache
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.DistributedSystem.m_singletonSync">
            <summary>
Static lock object to protect the singleton instance of this class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.DistributedSystem.m_instance">
            <summary>
Singleton instance of this class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.DistributedSystem.m_memoryPressureHandler">
            <summary>
Timer task to periodically invoke <c>HandleMemoryPressure</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.HandleMemoryPressure(System.Object)">
            <summary>
Periodically adjust memory pressure of unmanaged heap for GC.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.Dispose">
            <summary>
Finalizer for the singleton instance of this class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.#ctor(gemfire.DistributedSystem*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.UnregisterBuiltinManagedTypes">
            <summary>
Unregister the builtin managed types like CacheableObject.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.AppDomainInstancePostInitialization">
            <summary>
Stuff that needs to be done for Connect in each AppDomain but
only after the first Connect has completed.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.ManagedPostConnect">
            <summary>
Managed registrations and other stuff to be done for the manage
layer after the first connect.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.AppDomainInstanceInitialization(gemfire.SharedPtr&lt;gemfire.Properties&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Stuff that needs to be done for Connect in each AppDomain.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.Create(gemfire.DistributedSystem*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.GetInstance">
            <summary>
Returns a reference to this DistributedSystem instance.
</summary>
            <returns>the DistributedSystem instance</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DistributedSystem.IsConnected">
            <summary>
The current connection status of this client to the <c>DistributedSystem</c>.
</summary>
            <returns>true if connected, false otherwise</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DistributedSystem.Name">
            <summary>
Get the name that identifies this DistributedSystem instance.
</summary>
            <returns>the name of the DistributedSystem instance.</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DistributedSystem.SystemProperties">
            <summary>
Returns the SystemProperties used to create this instance of a
<c>DistributedSystem</c>.
</summary>
            <returns>the SystemProperties</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.Disconnect">
            <summary>
Disconnect from the distributed system.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">if not connected</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.Connect(System.String,GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.String^})">
            <summary>
Initializes the Native Client system to be able to connect to the
GemFire Java servers.
</summary>
            <param name="name">the name of the system to connect to</param>
            <param name="config">the set of properties</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">if name is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.NoSystemException">
if the connecting target is not running
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.AlreadyConnectedException">
if trying a second connect.
An application can have one only one connection to a DistributedSystem.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.UnknownException">otherwise</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DistributedSystem.Connect(System.String)">
            <summary>
Initializes the Native Client system to be able to connect to the GemFire Java servers.
</summary>
            <param name="name">the name of the system to connect to</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">if name is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.NoSystemException">
if the connecting target is not running
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.AlreadyConnectedException">
if trying a second connect.
An application can have one only one connection to a DistributedSystem.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.UnknownException">otherwise</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DistributedSystem">
            <summary>
DistributedSystem encapsulates this applications "connection" into the
GemFire Java servers.
</summary>
            <remarks>
In order to participate as a client in the GemFire Java servers
distributed system, each application needs to connect to the
DistributedSystem.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SystemProperties.#ctor(gemfire.SystemProperties*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SystemProperties.Create(gemfire.SystemProperties*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class, with null pointer check.
</summary>
            <param name="nativeptr">native object pointer</param>
            <returns>
the managed wrapper object, or null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.ConflateEvents">
            <summary>
Returns the conflate event's option
</summary>
            <returns>the conflate event option</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.ConnectTimeout">
            <summary>
Returns the connect timeout used for server and locator handshakes.
</summary>
            <returns>the connect timeout used for server and locator handshakes</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.DurableTimeout">
            <summary>
Returns the durable client's timeout.
</summary>
            <returns>the durable client timeout</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.DurableClientId">
            <summary>
Returns the durable client's ID.
</summary>
            <returns>the durable client ID</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.GetSecurityProperties">
            <summary>
Returns all the security properties
</summary>
            <returns>the security properties</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.IsSecurityOn">
            <summary>
True if client needs to be authenticated
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.SSLTrustStore">
            <summary>
Returns the SSL public certificate trust store file path.
</summary>
            <returns>the SSL public certificate trust store file path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.SSLKeyStore">
            <summary>
Returns the SSL private keystore file path.
</summary>
            <returns>the SSL private keystore file path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.SSLEnabled">
            <summary>
True if ssl connection support is enabled.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.MaxQueueSize">
            <summary>
Returns the max queue size for notification messages
</summary>
            <returns>the max queue size</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.StatsDiskSpaceLimit">
            <summary>
Returns the maximum statistics Disk size, in bytes, or 0 if unlimited.
</summary>
            <returns>the maximum limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.StatsFileSizeLimit">
            <summary>
Returns the maximum statistics file size, in bytes, or 0 if unlimited.
</summary>
            <returns>the maximum limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.LogDiskSpaceLimit">
            <summary>
Returns the maximum log Disk size, in bytes, or 0 if unlimited.
</summary>
            <returns>the maximum limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.LogFileSizeLimit">
            <summary>
Returns the maximum log file size, in bytes, or 0 if unlimited.
</summary>
            <returns>the maximum limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.CacheXmlFile">
            <summary>
Returns the name of the "cache.xml" file.
</summary>
            <returns>the filename</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.Name">
            <summary>
Returns the system name.
</summary>
            <returns>the name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.AppDomainEnabled">
            <summary>
Whether client is running in multiple AppDomain or not.
Default value is "false".
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.CrashDumpEnabled">
            <summary>
True if the crash dump generation for unhandled fatal exceptions
is enabled. If "log-file" property has been specified then they are
created in the same directory as the log file, and having the same
prefix as log file. By default crash dumps are created in the
current working directory and have the "gemfire_cpp" prefix.

The actual dump file will have timestamp and process ID
in the full name.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.DebugStackTraceEnabled">
            <summary>
True if the stack trace is enabled.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.NotifyDupCheckLife">
            <summary>
Returns the expiry time of an idle event id map entry for duplicate notification checking
</summary>
            <returns>the NotifyDupCheckLife value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.NotifyAckInterval">
            <summary>
Returns the periodic notify ack interval
</summary>
            <returns>the NotifyAckInterval value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.RedundancyMonitorInterval">
            <summary>
Returns  the time between two consecutive checks for redundancy for HA
</summary>
            <returns>the RedundancyMonitorInterval value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.PingInterval">
            <summary>
Returns  the time between two consecutive ping to servers
</summary>
            <returns>the PingInterval value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.MaxSocketBufferSize">
            <summary>
Returns  the maximum socket buffer size to use
</summary>
            <returns>the MaxSocketBufferSize value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.HeapLRUDelta">
            <summary>
Returns  the HeapLRUDelta value (a percent value). This specifies the
percentage of entries the system will evict each time it detects that
it has exceeded the HeapLRULimit. Defaults to 10%
</summary>
            <returns>the HeapLRUDelta value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.HeapLRULimit">
            <summary>
Returns  the HeapLRULimit value (in bytes), the maximum memory that values
in a cache can use to store data before overflowing to disk or destroying
entries to ensure that the server process never runs out of memory due to
cache memory usage
</summary>
            <returns>the HeapLRULimit value</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.HeapLRULimitEnabled">
            <summary>
Returns  a boolean that specifies if heapLRULimit has been enabled for the
process. If enabled, the HeapLRULimit specifies the maximum amount of memory
that values in a cache can use to store data before overflowing to disk or
destroying entries to ensure that the server process never runs out of
memory
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.GFLogLevel">
            <summary>
Returns the message logging level.
</summary>
            <returns>the log level</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.LogFileName">
            <summary>
Returns the name of the message log file.
</summary>
            <returns>the filename</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.StatisticsArchiveFile">
            <summary>
Returns the name of the statistics archive file.
</summary>
            <returns>the filename</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.StatisticsEnabled">
            <summary>
True if statistics are enabled (archived).
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.SystemProperties.StatisticsSampleInterval">
            <summary>
Returns the sampling interval, that is,
how often the statistics thread writes to disk, in seconds.
</summary>
            <returns>the statistics sampling interval</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SystemProperties.LogSettings">
            <summary>
Prints all settings to the process log.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SystemProperties.#ctor(GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.String^},System.String)">
            <summary>
Constructor.
<ol><li>Sets the default (hard-coded) values.</li><li>Overwrites those with any values from <c>systemDefault/gfcpp.properties</c></li><li>Overwrites those with any values from the given file (if it exists)
or the local <c>./gfcpp.properties</c> (if the given file does not exist).</li><li>Overwrites those with any values found in the given properties.</li></ol></summary>
            <param name="properties">these overwrite any other values already set</param>
            <param name="configFile">see summary</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SystemProperties.#ctor(GemStone.GemFire.Cache.Generic.Properties`2{System.String^,System.String^})">
            <summary>
Constructor. Sets the default (hard-coded) values first, and then overwrites those with
any values found in the given properties.
</summary>
            <param name="properties">initialize with the given properties</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.SystemProperties">
            <summary>
A class for internal use, that encapsulates the properties that can be
set through <see cref="M:GemStone.GemFire.Cache.DistributedSystem.Connect(System.String)" />
or a gfcpp.properties file.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.#ctor(gemfire.Serializable*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.CreateDeserializable(gemfire.Serializable*)">
            <summary>
Factory function to register wrapper
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.Create``2(gemfire.Serializable*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.CreateFromVoidPtr``2(System.Void*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="ptr">The native IntPtr pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Properties`2.NativeIntPtr">
            <summary>
Get the underlying native unmanaged pointer.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Properties`2.ClassId">
            <summary>
Returns the classId of this class for serialization.
</summary>
            <returns>classId of the Properties class</returns>
            <seealso cref="P:GemStone.GemFire.Cache.IGFSerializable.ClassId" />
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Properties`2.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserializes this Properties object.
</summary>
            <param name="input">
the DataInput stream to use for reading data
</param>
            <returns>the deserialized Properties object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this Properties object.
</summary>
            <param name="output">
the DataOutput stream to use for serialization
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.ToString">
            <summary>
Returns a string representation of the current
<c>Properties</c> object.
</summary>
            <returns>
A comma separated list of property name,value pairs.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.Load(System.String)">
            <summary>
Reads property values from a file, overriding what is currently
in the properties object. 
</summary>
            <param name="fileName">the name of the file</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Properties`2.Size">
            <summary>
Return the number of entries in the collection.
</summary>
            <returns>the number of entries</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.ForEach(GemStone.GemFire.Cache.Generic.PropertyVisitorGeneric`2{`0,`1})">
            <summary>
Execute the Visitor delegate for each entry in the collection.
</summary>
            <param name="visitor">visitor delegate</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.Remove(`0)">
            <summary>
Remove the key from the collection. 
</summary>
            <param name="key">the key to remove</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.Insert(`0,`1)">
            <summary>
Add or update the string value for key.
</summary>
            <param name="key">the key to insert</param>
            <param name="value">the string value to insert</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.Find(`0)">
            <summary>
Return the value for the given key, or NULL if not found. 
</summary>
            <param name="key">the key to find</param>
            <returns>the value for the key</returns>
            <exception cref="T:GemStone.GemFire.Cache.Generic.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.Create``2">
            <summary>
Factory method to create an empty collection of properties.
</summary>
            <returns>empty collection of properties</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Properties`2.#ctor">
            <summary>
Default constructor: returns an empty collection.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Properties`2">
            <summary>
Provides a collection of properties, each of which is a key/value
pair. Each key is a string, and the value may be a string
or an integer.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.PropertyVisitorGeneric`2">
            <summary>
Delegate that represents visitor for the <c>Properties</c> class.
</summary>
            <remarks>
This delegate is passed to the <c>Properties.ForEach</c> function
that invokes this delegate for each property having a key
and a value.
</remarks>
            <param name="key">The key of the property.</param>
            <param name="value">The value of the property.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SafeGenericUMKeyConvert``1(gemfire.CacheableKey*)">
            <summary>
Helper function to convert native <c>gemfire::CacheableKey</c> object
to managed <see cref="T:GemStone.GemFire.Cache.Generic.ICacheableKey" /> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SafeMSerializableConvertGeneric(GemStone.GemFire.Cache.Generic.IGFSerializable)">
            <summary>
Helper function to convert managed <see cref="T:GemStone.GemFire.Cache.Generic.IGFSerializable" />
object to native <c>gemfire::Serializable</c> object using
<c>SafeM2UMConvert</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.SafeUMSerializableConvertGeneric(gemfire.Serializable*)">
            <summary>
Helper function to convert native <c>gemfire::Serializable</c> object
to managed <see cref="T:GemStone.GemFire.Cache.Generic.IGFSerializable" /> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxSerializer.FromData(System.String,GemStone.GemFire.Cache.Generic.IPdxReader)">
            <summary>
Deserialize this object.
</summary>
            <param name="classname">
the classname whose object need to de-serialize
</param>
            <param name="reader">
the IPdxReader stream to use for reading the object data
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxSerializer.ToData(System.Object,GemStone.GemFire.Cache.Generic.IPdxWriter)">
            <summary>
Serializes this object in gemfire PDX format.
</summary>
            <param name="o">
the object which need to serialize
</param>
            <param name="writer">
the IPdxWriter object to use for serializing the object
</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IPdxSerializer">
            <summary>
The IPdxSerializer interface allows domain classes to be 
serialized and deserialized as PDXs without modification 
of the domain class.
A domain class should register delgate <see cref="!:Serializable.RegisterPdxType" /> to create new 
instance of type for de-serilization.
</summary>
        </member>
        <member name="F:gemfire.PdxManagedCacheableKeyBytes.m_domainId">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFSerializable
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
            <summary>
Copy the string form of a key into a char* buffer for logging purposes.
implementations should only generate a string as long as maxLength chars,
and return the number of chars written. buffer is expected to be large 
enough to hold at least maxLength chars.
The default implementation renders the classname and instance address.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.hashcode">
            <summary>
return the hashcode for this key.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.op_Equality(gemfire.PdxManagedCacheableKeyBytes!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other ManagedCacheableKeyBytes
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other CacheableKey
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.toString">
            <summary>
Display this object as 'string', which depends on the implementation in
the managed class
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKeyBytes.#ctor(GemStone.GemFire.Cache.Generic.IPdxSerializable,System.Boolean)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.PdxManagedCacheableKeyBytes">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="F:gemfire.PdxManagedCacheableKey.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFSerializable
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
            <summary>
Copy the string form of a key into a char* buffer for logging purposes.
implementations should only generate a string as long as maxLength chars,
and return the number of chars written. buffer is expected to be large 
enough to hold at least maxLength chars.
The default implementation renders the classname and instance address.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.hashcode">
            <summary>
return the hashcode for this key.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.op_Equality(gemfire.PdxManagedCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other ManagedCacheableKey
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other CacheableKey
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.toString">
            <summary>
Display this object as 'string', which depends on the implementation in
the managed class
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.PdxManagedCacheableKey.#ctor(GemStone.GemFire.Cache.Generic.IPdxSerializable)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.PdxManagedCacheableKey">
            <summary>
Wraps the managed <see cref="!:Com.Vmware.Cache.IPdxSerializable" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqEvent`2.#ctor(gemfire.CqEvent!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqEvent`2.getNewValue">
            <summary>
Get the new value of the modification.
If there is no new value returns null, this will happen during delete
operation.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqEvent`2.getKey">
            <summary>
Get the key relating to the event.
In case of REGION_CLEAR and REGION_INVALIDATE operation, the key will be null.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqEvent`2.getQueryOperation">
            <summary>
Get the operation on the query operation that triggered this event.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqEvent`2.getBaseOperation">
            <summary>
Get the operation on the base operation that triggered this event.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqEvent`2.getCq">
            <summary>
Return the cqquery this event occurred in.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqEvent`2">
            <summary>
This class encapsulates events that occur for cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICqEvent`2.getKey">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources,
such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICqEvent`2.getBaseOperation">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICqEvent`2.getCq">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ICqEvent`2">
            <summary>
An application plug-in that can be installed on a region.
Listener change notifications are invoked <c>after</c>
the change has occured.
</summary>
            <remarks>
Listeners receive notifications when entries in a region change or changes occur to the
region attributes themselves.
<para>
A cache listener is defined in the <see cref="T:GemStone.GemFire.Cache.Generic.RegionAttributes`2" />.
</para>
The methods on a <c>ICacheListener</c>
are invoked asynchronously. Multiple events can cause concurrent invocation
of <c>ICacheListener</c> methods.  If event A occurs before event B,
there is no guarantee that their corresponding <c>ICacheListener</c>
method invocations will occur in the same order.  Any exceptions thrown by
the listener are caught by GemFire and logged. 

Listeners are user callbacks that
are invoked by GemFire. It is important to ensure that minimal work is done in the
listener before returning control back to GemFire. For example, a listener
implementation may choose to hand off the event to a thread pool that then processes
the event on its thread rather than the listener thread
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheLoader" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheWriter" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqOperation.#ctor(gemfire.CqOperation*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqOperation.ConvertFromNative(gemfire.CqOperation.CqOperationType)">
            <summary>
conenience function for convertin from c++ 
gemfire::CqOperation::CqOperationType to
CqOperationType here.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqOperationType">
            <summary>
Enumerated type for CqOperationType
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.#ctor(gemfire.CqQuery*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.Create(gemfire.CqQuery*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.IsClosed">
            <summary>
Is this Cq in closed state?
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.IsStopped">
            <summary>
Is this Cq in stopped state?
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.IsRunning">
            <summary>
Is this Cq in running state?
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.GetState">
            <summary>
get the state of this cq query
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.Close">
            <summary>
stop the cq query
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.Stop">
            <summary>
stop the cq query
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.GetQuery">
            <summary>
Get the Query for this cq query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.GetStatistics">
            <summary>
Get the stats for this cq query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.GetCqAttributesMutator">
            <summary>
Get the Attributes Mutator for this cq query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.GetCqAttributes">
            <summary>
Get the Attributes for this cq query.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CqQuery`2.Name">
            <summary>
Get the name for this cq query.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CqQuery`2.QueryString">
            <summary>
Get the string for this cq query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.ExecuteWithInitialResults(System.UInt32)">
            <summary>
Executes the Cq Query on the cache server
with the specified timeout and returns the results.
</summary>
            <param name="timeout">The time (in seconds) to wait for query response.
This should be less than or equal to 2^31/1000 i.e. 2147483.
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if timeout parameter is greater than 2^31/1000.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.ExecuteWithInitialResults">
            <summary>
Executes the Cq Query on the cache server
and returns the Cqresults.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqQuery`2.Execute">
            <summary>
Executes the Cq  Query on the cache server
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqQuery`2">
            <summary>
Class to encapsulate a continuous query (CQ).
</summary>
            <remarks>
A CqQuery is obtained from a QueryService which in turn is obtained
from the Cache.
This can be executed to return SelectResults which can be either
a ResultSet or a StructSet, or it can be just registered on the
java server without returning results immediately rather only
the incremental results.

This class is intentionally not thread-safe. So multiple threads
should not operate on the same <c>CqQuery</c> object concurrently
rather should have their own <c>CqQuery</c> objects.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqState.#ctor(gemfire.CqState*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqState.IsClosing">
            <summary>
Returns true if the CQ is in Closing state.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqState.IsClosed">
            <summary>
Returns true if the CQ is in Closed state.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqState.IsStopped">
            <summary>
Returns true if the CQ is in Stopped state.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqState.IsRunning">
            <summary>
Returns true if the CQ is in Running state.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CqState.ToString">
            <summary>
Returns the state in string form.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqState">
            <summary>
Static class containing convenience methods for <c>CqState</c>.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqStateType">
            <summary>
Enumerated type for cq state
@nativeclient
For Native Clients:
@endnativeclient      
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheableDeltaBytesGeneric.m_domainId">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFDelta
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
            <summary>
Copy the string form of a key into a char* buffer for logging purposes.
implementations should only generate a string as long as maxLength chars,
and return the number of chars written. buffer is expected to be large 
enough to hold at least maxLength chars.
The default implementation renders the classname and instance address.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.op_Equality(gemfire.ManagedCacheableDeltaBytesGeneric!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other ManagedCacheableDeltaBytesGeneric
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other CacheableKey
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.hashcode">
            <summary>
return the hashcode for this key.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytesGeneric.#ctor(GemStone.GemFire.Cache.Generic.IGFDelta,System.Boolean)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedDeltaptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheableDeltaBytesGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFDelta" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheableKeyBytesGeneric.m_domainId">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFSerializable
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
            <summary>
Copy the string form of a key into a char* buffer for logging purposes.
implementations should only generate a string as long as maxLength chars,
and return the number of chars written. buffer is expected to be large 
enough to hold at least maxLength chars.
The default implementation renders the classname and instance address.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.hashcode">
            <summary>
return the hashcode for this key.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.op_Equality(gemfire.ManagedCacheableKeyBytesGeneric!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other ManagedCacheableKeyBytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other CacheableKey
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.toString">
            <summary>
Display this object as 'string', which depends on the implementation in
the managed class
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytesGeneric.#ctor(GemStone.GemFire.Cache.Generic.IGFSerializable,System.Boolean)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheableKeyBytesGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheableDeltaGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFDelta
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
            <summary>
Copy the string form of a key into a char* buffer for logging purposes.
implementations should only generate a string as long as maxLength chars,
and return the number of chars written. buffer is expected to be large 
enough to hold at least maxLength chars.
The default implementation renders the classname and instance address.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.op_Equality(gemfire.ManagedCacheableDeltaGeneric!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other ManagedCacheableDeltaGeneric
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other CacheableKey
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.hashcode">
            <summary>
return the hashcode for this key.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaGeneric.#ctor(GemStone.GemFire.Cache.Generic.IGFDelta)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheableDeltaGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFDelta" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheableKeyGeneric.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFSerializable
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
            <summary>
Copy the string form of a key into a char* buffer for logging purposes.
implementations should only generate a string as long as maxLength chars,
and return the number of chars written. buffer is expected to be large 
enough to hold at least maxLength chars.
The default implementation renders the classname and instance address.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.hashcode">
            <summary>
return the hashcode for this key.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.op_Equality(gemfire.ManagedCacheableKeyGeneric!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other ManagedCacheableKey
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other CacheableKey
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.toString">
            <summary>
Display this object as 'string', which depends on the implementation in
the managed class
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyGeneric.#ctor(GemStone.GemFire.Cache.Generic.IGFSerializable)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheableKeyGeneric">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="M:gemfire.AuthInitialize.close">
@brief Invoked before the cache goes down. 
</member>
        <member name="M:gemfire.AuthInitialize.getCredentials(gemfire.SharedPtr&lt;gemfire.Properties&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief initialize with the given set of security properties
   * and return the credentials for the client as properties.
   * @param props the set of security properties provided to the
   * <code>DistributedSystem.connect</code> method
   * @param server it is the ID of the current endpoint. 
   * The format expected is "host:port".
   * @returns the credentials to be used for the given <code>server</code>
   * @remarks This method can modify the given set of properties. For
   * example it may invoke external agents or even interact with the user.

</member>
        <member name="T:gemfire.AuthInitialize">
@class AuthInitialize AuthInitialize.hpp
Specifies the mechanism to obtain credentials for a client.
It is mandantory for clients when the server is running in secure
mode having a <code>security-client-authenticator</code> module specified.
Implementations should register the library path as
<code>security-client-auth-library</code> system property and factory
function (a zero argument function returning pointer to an
AuthInitialize object) as the <code>security-client-auth-factory</code>
system property.

</member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegionService.RootRegions``2">
            <summary>
Returns an array of root regions in the cache. This set is a
snapshot and is not backed by the cache.
</summary>
            <remarks>
It is not supported when Cache is created from Pool.
</remarks>
            <returns>array of regions</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegionService.GetQueryService``2">
            <summary>
Get a query service object to be able to query the cache.
</summary>
            <remarks>
Currently only works against the java server in native mode, and
at least some endpoints must have been defined in some regions
before actually firing a query.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegionService.GetRegion``2(System.String)">
            <summary>
Returns an existing region given the full path from root, or null 
if no such region exists.
</summary>
            <param name="name">the name of the region</param>
            <returns>the region</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegionService.Close">
            <summary>
Terminates this object cache and releases all the local resources.
If RegionService is created from <see cref="M:GemStone.GemFire.Cache.Cache.CreateAuthenticatedView(GemStone.GemFire.Cache.Properties)" />, then it clears user related security data.
</summary>
            <remarks>
After this cache is closed, any further
method call on this cache or any region object will throw
<c>CacheClosedException</c>, unless otherwise noted.
</remarks>
            <exception cref="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
if the cache is already closed.
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegionService.IsClosed">
            <summary>
True if this cache has been closed.
</summary>
            <remarks>
After a new cache object is created, this method returns false.
After <see cref="M:GemStone.GemFire.Cache.Generic.IRegionService.Close" /> is called on this cache object, this method
returns true.
</remarks>
            <returns>true if this cache is closed, otherwise false</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Region`2.#ctor(gemfire.Region*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Region`2.Create(gemfire.Region*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.#ctor(gemfire.QueryService*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.Create(gemfire.QueryService*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.GetCqStatistics">
@nativeclient
<summary>
Get <c>CqServiceStatistics</c>  on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.StopCqs">
@nativeclient
<summary>
Stop all  <c>CqQuery</c>  on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.ExecuteCqs">
@nativeclient
<summary>
Get the  <c>CqQuery</c> with the given name on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.GetCq(System.String)">
@nativeclient
<summary>
Get the  <c>CqQuery</c> with the given name on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.GetCqs">
@nativeclient
<summary>
Get all  <c>CqQuery</c> on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.CloseCqs">
@nativeclient
<summary>
Close all  <c>CqQuery</c> on this client.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.NewCq(System.String,System.String,GemStone.GemFire.Cache.Generic.CqAttributes`2{`0,`1},System.Boolean)">
@nativeclient
<summary>
Get a <c>CqQuery</c> object to enable continuous querying.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.NewCq(System.String,GemStone.GemFire.Cache.Generic.CqAttributes`2{`0,`1},System.Boolean)">
@nativeclient
<summary>
Get a <c>CqQuery</c> object to enable continuous querying.
</summary>
@endnativeclient
</member>
        <member name="M:GemStone.GemFire.Cache.Generic.QueryService`2.NewQuery(System.String)">
            <summary>
Get a <c>Query</c> object to enable querying.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.QueryService`2">
            <summary>
Provides a query service.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.RegionShortcut.LOCAL_ENTRY_LRU">
            <summary>
A LOCAL_ENTRY_LRU region only has local state and never sends operations to a server.
It will also destroy entries once it detects once it detects that the number of enteries crossing default limit of #100000.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.RegionShortcut.LOCAL">
            <summary>
A LOCAL region only has local state and never sends operations to a server.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.RegionShortcut.CACHING_PROXY_ENTRY_LRU">
            <summary>
A CACHING_PROXY_ENTRY_LRU region has local state but can also send operations to a server.
If the local state is not found then the operation is sent to the server
and the local state is updated to contain the server result.
It will also destroy entries once it detects that the number of enteries crossing default limit of #100000.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.RegionShortcut.CACHING_PROXY">
            <summary>
A CACHING_PROXY region has local state but can also send operations to a server.
If the local state is not found then the operation is sent to the server
and the local state is updated to contain the server result.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.RegionShortcut.PROXY">
            <summary>
A PROXY region has no local state and forwards all operations to a server.
</summary>
        </member>
        <member name="D:_onexit_t">
@file CacheableBuiltins.hpp
 *  @brief Contains generic template definitions for Cacheable types
 *         and instantiations for built-in types.

</member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadArrayOfByteArrays(System.String)">
            <summary>
Read a two-dimenesional byte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadObjectArray(System.String)">
            <summary>
Read a object array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadStringArray(System.String)">
            <summary>
Read a string array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadDoubleArray(System.String)">
            <summary>
Read a double array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadFloatArray(System.String)">
            <summary>
Read a float from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadUnsignedLongArray(System.String)">
            <summary>
Read a ulong array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadLongArray(System.String)">
            <summary>
Read a long array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadUnsignedIntArray(System.String)">
            <summary>
Read a uint from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadIntArray(System.String)">
            <summary>
Read a int array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadUnsignedShortArray(System.String)">
            <summary>
Read a ushort array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadShortArray(System.String)">
            <summary>
Read a short from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadSByteArray(System.String)">
            <summary>
Read a sbyte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadByteArray(System.String)">
            <summary>
Read a byte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadCharArray(System.String)">
            <summary>
Read a char array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadBooleanArray(System.String)">
            <summary>
Read a boolean array from the data. 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadDate(System.String)">
            <summary>
Read a Date from the data. 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadCollection(System.String,System.Collections.IList)">
            <summary>
Read a collection from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadObject(System.String)">
            <summary>
Read a serializable object from the data. Null objects are handled.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadASCIIHuge(System.String)">
            <summary>
Read a ASCII string from the stream. Where size is more than 2^16-1 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadUTFHuge(System.String)">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadString(System.String)">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadDouble(System.String)">
            <summary>
Read a double precision number from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadFloat(System.String)">
            <summary>
Read a floating point number from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadLong(System.String)">
            <summary>
Read a 64-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadInt(System.String)">
            <summary>
Read a 32-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadShort(System.String)">
            <summary>
Read a 16-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadUInt64(System.String)">
            <summary>
Read a 64-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadUInt32(System.String)">
            <summary>
Read a 32-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadUInt16(System.String)">
            <summary>
Read a 16-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadChar(System.String)">
            <summary>
Read a char value from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadBoolean(System.String)">
            <summary>
Read a boolean value from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadSByte(System.String)">
            <summary>
Read a signed byte from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxReaderWithTypeCollector.ReadByte(System.String)">
            <summary>
Read a signed byte from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadField(System.String,System.Type)">
            <summary>
Reads the named field and returns its value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.IsIdentityField(System.String)">
            <summary>
Whether field is used as identity field or not.
</summary>
            <param name="fieldName">The name of a member field.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.HasField(System.String)">
            <summary>
Whether field is available or not.
</summary>
            <param name="fieldName">The name of a member field.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadArrayOfByteArrays(System.String)">
            <summary>
Read a two-dimenesional byte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadObjectArray(System.String)">
            <summary>
Read a object array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadStringArray(System.String)">
            <summary>
Read a string array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadDoubleArray(System.String)">
            <summary>
Read a double array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadFloatArray(System.String)">
            <summary>
Read a float from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadUnsignedLongArray(System.String)">
            <summary>
Read a ulong array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadLongArray(System.String)">
            <summary>
Read a long array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadUnsignedIntArray(System.String)">
            <summary>
Read a uint from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadIntArray(System.String)">
            <summary>
Read a int array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadUnsignedShortArray(System.String)">
            <summary>
Read a ushort array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadShortArray(System.String)">
            <summary>
Read a short from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadSByteArray(System.String)">
            <summary>
Read a sbyte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadByteArray(System.String)">
            <summary>
Read a byte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadCharArray(System.String)">
            <summary>
Read a char array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadBooleanArray(System.String)">
            <summary>
Read a boolean array from the data. 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadDate(System.String)">
            <summary>
Read a Date from the data. 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadCollection(System.String,System.Collections.IList)">
            <summary>
Read a collection from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadObject(System.String)">
            <summary>
Read a serializable object from the data. Null objects are handled.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadASCIIHuge(System.String)">
            <summary>
Read a ASCII string from the stream. Where size is more than 2^16-1 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadUTFHuge(System.String)">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadString(System.String)">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadDouble(System.String)">
            <summary>
Read a double precision number from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadFloat(System.String)">
            <summary>
Read a floating point number from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadLong(System.String)">
            <summary>
Read a 64-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadInt(System.String)">
            <summary>
Read a 32-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadShort(System.String)">
            <summary>
Read a 16-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadUInt64(System.String)">
            <summary>
Read a 64-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadUInt32(System.String)">
            <summary>
Read a 32-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadUInt16(System.String)">
            <summary>
Read a 16-bit unsigned integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadChar(System.String)">
            <summary>
Read a char value from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadBoolean(System.String)">
            <summary>
Read a boolean value from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadSByte(System.String)">
            <summary>
Read a signed byte from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalReader.ReadByte(System.String)">
            <summary>
Read a byte from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxSerializable.FromData(GemStone.GemFire.Cache.Generic.IPdxReader)">
            <summary>
Deserialize this object.
</summary>
            <param name="reader">
the IPdxReader stream to use for reading the object data
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxSerializable.ToData(GemStone.GemFire.Cache.Generic.IPdxWriter)">
            <summary>
Serializes this object in gemfire PDX format.
</summary>
            <param name="writer">
the IPdxWriter object to use for serializing the object
</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IPdxSerializable">
            <summary>
When a domain class implements PdxSerializable it marks 
itself as a PDX. 
The implementation of toData provides the serialization 
code and fromData provides the deserialization code. 
These methods also define each field name and field type 
of the PDX. Domain classes should serialize and de-serialize 
all its member fields in same order in toData and fromData 
method. 
A domain class which implements this interface should register delgate <see cref="!:Serializable.RegisterPdxType" /> to create new 
instance of type for de-serilization.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteUnreadFields(GemStone.GemFire.Cache.Generic.IPdxUnreadFields)">
            <summary>
To append unread data with updated data.

</summary>
            <returns>this PdxWriter</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.MarkIdentityField(System.String)">
            <summary>
Indicate that the given field name should be included in hashCode and equals checks
of this object on a server that is using {@link CacheFactory#setPdxReadSerialized(boolean)}
or when a client executes a query on a server.

The fields that are marked as identity fields are used to generate the hashCode and
equals methods of {@link PdxInstance}. Because of this, the identity fields should themselves
either be primatives, or implement hashCode and equals.

If no fields are set as identity fields, then all fields will be used in hashCode and equals
checks.

The identity fields should make marked after they are written using a write* method.
</summary>
            <param name="fieldName"> the name of the field that should be used in the as part of the identity.</param>
            <returns>this PdxWriter</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteArrayOfByteArrays(System.String,System.Byte[][])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="byteArrays">The byteArrays to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteObjectArray(System.String,System.Collections.Generic.List`1{System.Object^})">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="objectArray">The objectArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteStringArray(System.String,System.String[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="stringArray">The stringArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteDoubleArray(System.String,System.Double[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="doubleArray">The doubleArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteFloatArray(System.String,System.Single[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="floatArray">The floatArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteLongArray(System.String,System.Int64[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="longArray">The longArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteIntArray(System.String,System.Int32[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="intArray">The intArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteShortArray(System.String,System.Int16[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="shortArray">The shortArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteByteArray(System.String,System.Byte[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="byteArray">The byteArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteCharArray(System.String,System.Char[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="charArray">The charArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteBooleanArray(System.String,System.Boolean[])">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="boolArray">The boolArray to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteDate(System.String,System.DateTime)">
            <summary>
Write an collection to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="date">The date to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteObject(System.String,System.Object)">
            <summary>
Write an <c>Object</c> object to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteString(System.String,System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteDouble(System.String,System.Double)">
            <summary>
Write a double precision real number to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">
The double precision real number to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteFloat(System.String,System.Single)">
            <summary>
Write a float to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The float value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteLong(System.String,System.Int64)">
            <summary>
Write a 64-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteInt(System.String,System.Int32)">
            <summary>
Write a 32-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteShort(System.String,System.Int16)">
            <summary>
Write a 16-bit integer to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteChar(System.String,System.Char)">
            <summary>
Write a char value to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The char value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteBoolean(System.String,System.Boolean)">
            <summary>
Write a boolean value to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The boolean value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteByte(System.String,System.SByte)">
            <summary>
Write a byte to the <c>IPdxWriter</c>.
</summary>
            <param name="fieldName">The name of the field associated with the value.</param>
            <param name="value">The byte to write.</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IPdxWriter">
            <summary>
A IPdxWriter will be passed to IPdxSerializable.toData
when it is serializing the domain class. The domain class needs to serialize member 
fields using this interface. This interface is implemented 
by Native Client.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.DataInput.m_buffer">
            <summary>
Internal buffer managed by the class.
This is freed in the disposer/destructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.#ctor(gemfire.DataInput*,System.Boolean)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadUInt64">
            <summary>
Read a 64-bit unsigned integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadUInt32">
            <summary>
Read a 32-bit unsigned integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadUInt16">
            <summary>
Read a 16-bit unsigned integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadByte">
            <summary>
Read a byte from the stream.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DataInput.BytesReadInternally">
            <summary>
Get the count of bytes that have been read from the stream, for internal use only.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadArrayOfByteArrays">
            <summary>
Read a array of signed byte array from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadObjectArray">
            <summary>
Read a object array from the stream from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadDoubleArray">
            <summary>
Read a double array from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadFloatArray">
            <summary>
Read a float array from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadLongArray">
            <summary>
Read a long array from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadIntArray">
            <summary>
Read a int array from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadShortArray">
            <summary>
Read a short int array from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadBooleanArray">
            <summary>
Read a bool array from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadCharArray">
            <summary>
Read a char array from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadCollection(System.Collections.IList)">
            <summary>
Read a collection from the stream in a given collection instance.
</summary>
            <param name="list">Object which implements System::Collections::IList interface.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadDate">
            <summary>
Read a date from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadDictionary(System.Collections.IDictionary)">
            <summary>
Read a dictionary from the stream in a given dictionary instance.
</summary>
            <param name="dictionary">Object which implements System::Collections::IDictionary interface.</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DataInput.NativeIntPtr">
            <summary>
Get the underlying native unmanaged pointer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.Reset">
            <summary>
Reset the cursor to the start of buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.RewindCursor(System.Int32)">
            <summary>
Rewind the cursor of the buffer by the given offset.
</summary>
            <param name="offset">
The offset(number of bytes) by which to rewind the cursor.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.AdvanceCursor(System.Int32)">
            <summary>
Advance the cursor of the buffer by the given offset.
</summary>
            <param name="offset">
The offset(number of bytes) by which to advance the cursor.
</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DataInput.BytesRemaining">
            <summary>
Get the count of bytes that are remaining in the buffer.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DataInput.BytesRead">
            <summary>
Get the count of bytes that have been read from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadObject">
            <summary>
Read a serializable object from the data. Null objects are handled.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadASCIIHuge">
            <summary>
Read a ASCII string from the stream. Where size is more than 2^16-1 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadUTFHuge">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadUTF">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadDouble">
            <summary>
Read a double precision number from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadFloat">
            <summary>
Read a floating point number from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadInt64">
            <summary>
Read a 64-bit integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadInt32">
            <summary>
Read a 32-bit integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadInt16">
            <summary>
Read a 16-bit integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadArrayLen">
            <summary>
Read a array len based on array size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadSBytesOnly(System.UInt32)">
            <summary>
Read the given number of signed bytes from the stream.
</summary>
            <param name="len">Number of signed bytes to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadBytesOnly(System.UInt32)">
            <summary>
Read the given number of bytes from the stream.
</summary>
            <param name="len">Number of bytes to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadSBytes">
            <summary>
Read an array of signed bytes from the stream reading the length
from the stream first.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadBytes">
            <summary>
Read an array of bytes from the stream reading the length
from the stream first.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadChar">
            <summary>
Read a char value from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadBoolean">
            <summary>
Read a boolean value from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.ReadSByte">
            <summary>
Read a signed byte from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.Finalize">
            <summary>
Finalizer: frees the internal buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.Dispose">
            <summary>
Dispose: frees the internal buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.#ctor(System.Byte[],System.Int32)">
            <summary>
Construct <c>DataInput</c> using a given length of an array of
bytes.
</summary>
            <param name="buffer">
The buffer to use for reading data values.
</param>
            <param name="len">
The number of bytes from the start of the buffer to use.
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the buffer is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataInput.#ctor(System.Byte[])">
            <summary>
Construct <c>DataInput</c> using an given array of bytes.
</summary>
            <param name="buffer">
The buffer to use for reading data values.
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the buffer is null
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DataInput">
            <summary>
Provides operations for reading primitive data values, byte arrays,
strings, <c>IGFSerializable</c> objects from a byte stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.#ctor(gemfire.DataOutput*,System.Boolean)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteUInt64(System.UInt64)">
            <summary>
Write an unsigned 64-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The unsigned 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteUInt32(System.UInt32)">
            <summary>
Write an unsigned 32-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The unsigned 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteUInt16(System.UInt16)">
            <summary>
Write an unsigned short integer (int16_t) to the <c>DataOutput</c>.
</summary>
            <param name="value">The unsigned 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteByte(System.Byte)">
            <summary>
Write a byte to the <c>DataOutput</c>.
</summary>
            <param name="value">The byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteArrayOfByteArrays(System.Byte[][])">
            <summary>
Write a array of sign byte array to the DataOutput.
</summary>
            <param name="value">The array of sign byte array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteObjectArray(System.Collections.Generic.List`1{System.Object^})">
            <summary>
Write a object array to the DataOutput.
</summary>
            <param name="value">The object array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteDoubleArray(System.Double[])">
            <summary>
Write a double array to the DataOutput.
</summary>
            <param name="value">The double array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteFloatArray(System.Single[])">
            <summary>
Write a float array to the DataOutput.
</summary>
            <param name="value">The float array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteLongArray(System.Int64[])">
            <summary>
Write a long array to the DataOutput.
</summary>
            <param name="value">The long array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteIntArray(System.Int32[])">
            <summary>
Write a int array to the DataOutput.
</summary>
            <param name="value">The int array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteShortArray(System.Int16[])">
            <summary>
Write a short array to the DataOutput.
</summary>
            <param name="value">The short array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteBooleanArray(System.Boolean[])">
            <summary>
Write a bool array to the DataOutput.
</summary>
            <param name="value">The bool array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteCharArray(System.Char[])">
            <summary>
Write a char array to the DataOutput.
</summary>
            <param name="value">The char array to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteCollection(System.Collections.IList)">
            <summary>
Write a collection to the DataOutput.
</summary>
            <param name="value">The object which implements IList to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteDate(System.DateTime)">
            <summary>
Write a date to the DataOutput.
</summary>
            <param name="value">The date value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteDictionary(System.Collections.IDictionary)">
            <summary>
Write a Dictionary to the DataOutput.
</summary>
            <param name="value">The object which implements IDictionary to write.</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DataOutput.NativeIntPtr">
            <summary>
Get the underlying native unmanaged pointer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.Reset">
            <summary>
Reset the cursor to the start of the buffer.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.DataOutput.BufferLength">
            <summary>
Get the length of current data in the buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.GetBuffer">
            <summary>
Get a copy of the current buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.RewindCursor(System.UInt32)">
            <summary>
Rewind the buffer cursor by the given offset.
</summary>
            <param name="offset">
The offset by which to rewind the cursor.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.AdvanceCursor(System.UInt32)">
            <summary>
Advance the buffer cursor by the given offset.
</summary>
            <param name="offset">
The offset by which to advance the cursor.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteObject(System.Object)">
            <summary>
Write an <c>IGFSerializable</c> object to the <c>DataOutput</c>.
</summary>
            <param name="obj">The object to write.</param>
            <summary>
Write a <c>Serializable</c> object to the <c>DataOutput</c>.
This is provided to conveniently pass primitive types (like string)
that shall be implicitly converted to corresponding
<c>IGFSerializable</c> wrapper types.
</summary>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteASCIIHuge(System.String)">
            <summary>
Write a string(only ASCII char) to
<c>DataOutput</c>.
Length should be more than 2^16 -1.
</summary>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteUTFHuge(System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>DataOutput</c>.
Length should be more than 2^16 -1. 
</summary>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteUTF(System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>DataOutput</c>.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteDouble(System.Double)">
            <summary>
Write a double precision real number to the <c>DataOutput</c>.
</summary>
            <param name="value">
The double precision real number to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteFloat(System.Single)">
            <summary>
Write a float to the DataOutput.
</summary>
            <param name="value">The float value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteInt64(System.Int64)">
            <summary>
Write a 64-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteInt32(System.Int32)">
            <summary>
Write a 32-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteInt16(System.Int16)">
            <summary>
Write a 16-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteSBytesOnly(System.SByte[])">
            <summary>
Write an array of signed bytes without its length
to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of signed bytes to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteSBytesOnly(System.SByte[],System.UInt32)">
            <summary>
Write a given length of signed bytes without its length
to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of signed bytes to write.</param>
            <param name="len">
The number of bytes from the start of array to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteBytesOnly(System.Byte[])">
            <summary>
Write an array of bytes without its length to the
<c>DataOutput</c>.
</summary>
            <param name="bytes">The array of bytes to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteBytesOnly(System.Byte[],System.UInt32)">
            <summary>
Write a given length of bytes without its length to the
<c>DataOutput</c>.
</summary>
            <param name="bytes">The array of bytes to write.</param>
            <param name="len">
The number of bytes from the start of array to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteSBytes(System.SByte[])">
            <summary>
Write an array of signed bytes to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of signed bytes to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteSBytes(System.SByte[],System.Int32)">
            <summary>
Write a given length of signed bytes to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of signed bytes to write.</param>
            <param name="len">
The number of bytes from the start of array to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteBytes(System.Byte[])">
            <summary>
Write an array of bytes to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of bytes to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteBytes(System.Byte[],System.Int32)">
            <summary>
Write a given length of bytes to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of bytes to write.</param>
            <param name="len">
The number of bytes from the start of array to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteChar(System.Char)">
            <summary>
Write a char value to the <c>DataOutput</c>.
</summary>
            <param name="value">The char value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteBoolean(System.Boolean)">
            <summary>
Write a boolean value to the <c>DataOutput</c>.
</summary>
            <param name="value">The boolean value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteSByte(System.SByte)">
            <summary>
Write a signed byte to the <c>DataOutput</c>.
</summary>
            <param name="value">The signed byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.WriteArrayLen(System.Int32)">
            <summary>
Write length of the array to the <c>DataOutput</c>.
</summary>
            <param name="len">Array len to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.DataOutput.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DataOutput">
            <summary>
Provides operations for writing primitive data values, and
user-defined objects implementing IGFSerializable, to a byte stream.
This class is intentionally not thread safe.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStack.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableStack.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableStack.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStack.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStack.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStack.Create(System.Collections.ICollection)">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStack.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableStack.#ctor(System.Collections.ICollection)">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableStack">
            <summary>
A mutable <c>IGFSerializable</c> vector wrapper that can serve as
a distributable object for caching.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableArrayList.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableArrayList.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableArrayList.Create(System.Collections.IList)">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableArrayList.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableArrayList.#ctor(System.Collections.IList)">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableArrayList">
            <summary>
A mutable <c>IGFSerializable</c> vector wrapper that can serve as
a distributable object for caching. This class extends .NET generic
<c>List</c> class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableVector.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableVector.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableVector.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableVector.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableVector.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableVector.Create(System.Collections.IList)">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableVector.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableVector.#ctor(System.Collections.IList)">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableVector">
            <summary>
A mutable <c>IGFSerializable</c> vector wrapper that can serve as
a distributable object for caching. This class extends .NET generic
<c>List</c> class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.CacheableDate.EpochTime">
            <summary>
                <c>DataTime</c> value since 1/1/1970
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableDate.Value">
            <summary>
Gets the <c>System.DateTime</c> value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.Equals(System.Object)">
            <summary>
Return true if this key matches other object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.Equals(GemStone.GemFire.Cache.Generic.ICacheableKey)">
            <summary>
Return true if this key matches other object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.GetHashCode">
            <summary>
Return the hashcode for this key.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.ToString">
            <summary>
Return a string representation of the object.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableDate.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableDate.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.Create(System.DateTime)">
            <summary>
Static function that returns a new instance initialized to the
given <c>System.DateTime</c> value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.Create">
            <summary>
Static function that returns a new default instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.#ctor(System.DateTime)">
            <summary>
Initializes a new instance of the <c>CacheableDate</c> to the
given <c>System.DateTime</c> value.
</summary>
            <param name="dateTime">
A <c>System.DateTime</c> value to initialize this instance.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableDate.#ctor">
            <summary>
Allocates a new default instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableDate">
            <summary>
An immutable date wrapper that can serve as a distributable
key object for caching as well as being a string value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.#ctor(gemfire.Serializable*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.#ctor(System.Char[],System.Boolean)">
            <summary>
Private constructor to create a CacheableString without checking
for arguments.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.#ctor(System.String,System.Boolean)">
            <summary>
Private constructor to create a CacheableString without checking
for arguments.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.GetString(gemfire.CacheableString*)">
            <summary>
Get the <c>System.String</c> from the given
<c>gemfire::CacheableString</c></summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.GetCacheableString(System.Char[],gemfire.SharedPtr&lt;gemfire.CacheableString&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Internal function to create a <c>gemfire::CacheableString</c>
from the given managed array of characters.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.GetCacheableString(System.String,gemfire.SharedPtr&lt;gemfire.CacheableString&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Internal function to create a <c>gemfire::CacheableString</c>
from the given managed string.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.Create(gemfire.Serializable*)">
            <summary>
Factory function to register wrapper
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableString.IsWideString">
            <summary>
True when the underlying C string is a wide-character string.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableString.Length">
            <summary>
Gets the length of the underlying C string.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.op_Implicit(GemStone.GemFire.Cache.Generic.CacheableString)~System.String">
            <summary>
Implicit conversion operator to underlying <c>System.String</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.IsNullOrEmpty(GemStone.GemFire.Cache.Generic.CacheableString)">
            <summary>
Static function to check whether IsNullOrEmpty.
</summary>
            <remarks>
This is similar to the C# string.IsNullOrEmpty method.
</remarks>
            <param name="value">the CacheableString value to check</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableString.Value">
            <summary>
Gets the string value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.GetHashCode">
            <summary>
Return the hashcode for this key.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.Equals(System.Object)">
            <summary>
Return true if this key matches other object.
It invokes the '==' operator of the underlying
<c>gemfire::CacheableString</c> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.Equals(GemStone.GemFire.Cache.Generic.ICacheableKey)">
            <summary>
Return true if this key matches other object.
It invokes the '==' operator of the underlying
<c>gemfire::CacheableString</c> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.ToString">
            <summary>
Return a string representation of the object.
This returns the same string as <c>Value</c> property.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.Create(System.Char[])">
            <summary>
Static function to create a new instance copying from
the given character array.
</summary>
            <remarks>
Providing a null or zero size character array will return a null
<c>CacheableString</c> object.
</remarks>
            <param name="value">
the character array value of the new instance
</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.CacheableString.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserializes the managed object -- returns an instance of the
<c>IGFSerializable</c> class.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this managed object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.Create(System.String)">
            <summary>
Static function to create a new instance copying from
the given string.
</summary>
            <remarks>
Providing a null or zero size string will return a null
<c>CacheableString</c> object.
</remarks>
            <param name="value">the string value of the new instance</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.#ctor(System.Char[])">
            <summary>
Allocates a new instance copying from the given character array.
</summary>
            <param name="value">
the character array value of the new instance
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the provided array is null or has zero length
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableString.#ctor(System.String)">
            <summary>
Allocates a new instance copying from the given string.
</summary>
            <param name="value">the string value of the new instance</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the provided string is null or has zero length
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableString">
            <summary>
An immutable string wrapper that can serve as a distributable
key object for caching as well as being a string value.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableManagedObjectXml">
            <summary>
ClassId of <c>CacheableObjectXml</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableManagedObject">
            <summary>
ClassId of <c>CacheableObject</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableASCIIStringHuge">
            <summary>
ClassId of <c>CacheableString</c> class for huge ASCII strings
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableASCIIString">
            <summary>
ClassId of <c>CacheableString</c> class for ASCII strings
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableNullString">
            <summary>
ClassId of <c>CacheableString</c> class for null strings
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableTimeUnit">
            <summary>
Not used.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableIdentityHashMap">
            <summary>
ClassId of <c>CacheableIdentityHashMap</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableHashTable">
            <summary>
ClassId of <c>CacheableHashTable</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableHashMap">
            <summary>
ClassId of <c>CacheableHashMap</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableLinkedHashSet">
            <summary>
ClassId of <c>CacheableLinkedHashSet</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableHashSet">
            <summary>
ClassId of <c>CacheableHashSet</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableArrayList">
            <summary>
ClassId of <c>CacheableArrayList</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableStack">
            <summary>
ClassId of <c>CacheableStack</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableVector">
            <summary>
ClassId of <c>CacheableVector</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableStringArray">
            <summary>
ClassId of <c>CacheableStringArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableFileName">
            <summary>
ClassId of <c>CacheableFileName</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableDate">
            <summary>
ClassId of <c>CacheableDate</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableDouble">
            <summary>
ClassId of <c>CacheableDouble</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableFloat">
            <summary>
ClassId of <c>CacheableFloat</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableInt64">
            <summary>
ClassId of <c>CacheableInt64</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableInt32">
            <summary>
ClassId of <c>CacheableInt32</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableInt16">
            <summary>
ClassId of <c>CacheableInt16</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableByte">
            <summary>
ClassId of <c>CacheableByte</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableCharacter">
            <summary>
ClassId of <c>CacheableInt16</c> class for wide-characters
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableBoolean">
            <summary>
ClassId of <c>CacheableBoolean</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableObjectArray">
            <summary>
ClassId of <c>CacheableVector</c> class for object arrays
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableDoubleArray">
            <summary>
ClassId of <c>CacheableDoubleArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableFloatArray">
            <summary>
ClassId of <c>CacheableFloatArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableInt64Array">
            <summary>
ClassId of <c>CacheableInt64Array</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableInt32Array">
            <summary>
ClassId of <c>CacheableInt32Array</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableInt16Array">
            <summary>
ClassId of <c>CacheableInt16Array</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableBytes">
            <summary>
ClassId of <c>CacheableBytes</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableStringHuge">
            <summary>
ClassId of <c>CacheableString</c> class for huge strings
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableString">
            <summary>
ClassId of <c>CacheableString</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.Struct">
            <summary>
ClassId of <c>Struct</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CacheableUndefined">
            <summary>
ClassId of <c>CacheableUndefined</c> class
Implementation note: this has DSFID of FixedIDByte hence a
different increment.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.RegionAttributes">
            <summary>
ClassId of <c>RegionAttributes</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.BooleanArray">
            <summary>
ClassId of <c>BooleanArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.CharArray">
            <summary>        
ClassId of <c>CharArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireClassIds.Properties">
            <summary>
ClassId of <c>Properties</c> class
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.GemFireClassIds">
            <summary>
Static class containing the classIds of the built-in cacheable types.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.#ctor(gemfire.Serializable*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.String)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a string
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.Int64)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a 64-bit integer
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.Int32)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a 32-bit integer
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.Char)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a character
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.Int16)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a 16-bit integer
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.Single)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a float
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.Double)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a double
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.Byte)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a byte
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.op_Implicit(System.Boolean)~GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
Implicit conversion operator from a boolean
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.Equals(System.Object)">
            <summary>
Return true if this key matches other object.
It invokes the '==' operator if the underlying object is a
<c>gemfire::CacheableKey</c>, else returns
<c>System.Object.Equals()</c></summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.Equals(GemStone.GemFire.Cache.Generic.ICacheableKey)">
            <summary>
Return true if this key matches other object. It invokes the '=='
operator of the underlying <c>gemfire::CacheableKey</c> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.CacheableKey.GetHashCode">
            <summary>
Return the hashcode for this key.
It gets the hash code by calling the <c>hashcode()</c> function
of the underlying <c>gemfire::CacheableKey</c> object.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheableKey">
            <summary>
This class wraps the native C++ <c>gemfire::Serializable</c> objects
as managed <see cref="!:../../IGFSerializable" /> objects.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheableKey.Equals(GemStone.GemFire.Cache.Generic.ICacheableKey)">
            <summary>
Returns true if this <c>ICacheableKey</c> matches the other.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ICacheableKey.GetHashCode">
            <summary>
Get the hash code for this object. This is used in the internal
hash tables and so must have a nice distribution pattern.
</summary>
            <returns>
The hashcode for this object.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ICacheableKey">
            <summary>
This interface class is the superclass of all user objects 
in the cache that can be used as a key.
</summary>
            <remarks>
If an implementation is required to act as a key in the cache, then
it must implement this interface and preferably override
<c>System.Object.ToString</c> to obtain proper string representation.
Note that this interface requires that the class overrides
<c>Object.GetHashCode</c>. Though this is not enforced, the default
implementation in <c>System.Object</c> is almost certainly incorrect
and will not work correctly.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.GetWrapperGeneric(System.Byte)">
            <summary>
Static method to lookup the wrapper delegate for a given typeId.
</summary>
            <param name="typeId">
The typeId of the native <c>gemfire::Serializable</c> type.
</param>
            <returns>
If a managed wrapper is registered for the given typeId then the
wrapper delegate is returned, else this returns null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.UnregisterNativesGeneric">
            <summary>
Internal static method to remove managed artifacts created by
RegisterType and RegisterWrapper methods when
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Disconnect" /> is called.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.RegisterWrapperGeneric(GemStone.GemFire.Cache.Generic.WrapperDelegateGeneric,System.Byte,System.Type)">
            <summary>
Static method to register a managed wrapper for a native
<c>gemfire::Serializable</c> type.
</summary>
            <param name="wrapperMethod">
A factory delegate of the managed wrapper class that returns the
managed object given the native object.
</param>
            <param name="typeId">The typeId of the native type.</param>
            <seealso cref="!:NativeWrappers" />
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.Serializable.NativeWrappersGeneric">
            <summary>
Static array of managed <c>WrapperDelegate</c> delegates that
maintains a mapping of built-in native typeIds to their corresponding
wrapper type delegates.
</summary>
            <remarks>
This is as an array to make lookup as fast as possible, taking
advantage of the fact that the range of wrapped built-in typeIds is
small. <b>IMPORTANT:</b> If the built-in native typeIds encompass a
greater range then change <c>WrapperEnd</c> in this accordingly
or move to using a Dictionary instead.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.GetManagedDelegateGeneric(System.Int64)">
            <summary>
This is to get manged delegates.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.Serializable.ManagedDelegatesGeneric">
            <summary>
Static map of <c>TypeFactoryMethod</c> delegates created
for managed <c>TypeFactoryMethod</c> delegates.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.Serializable.BuiltInDelegatesGeneric">
            <summary>
Static map of <c>TypeFactoryNativeMethod</c> delegates created
for builtin managed <c>TypeFactoryMethod</c> delegates.
This is so that the underlying managed objects do not get GCed.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.Serializable.DelegateMapGeneric">
            <summary>
Static map of <c>TypeFactoryMethod</c> delegates created
from registered managed <c>TypeFactoryMethod</c> delegates.
This is for cross AppDomain object creations.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.Serializable.NativeDelegatesGeneric">
            <summary>
Static list of <c>TypeFactoryNativeMethod</c> delegates created
from registered managed <c>TypeFactoryMethod</c> delegates.
This is so that the underlying managed objects do not get GCed.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.SetSP(gemfire.Serializable*)">
            <summary>
Used to assign the native Serializable pointer to a new object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.AssignSP(gemfire.Serializable*)">
            <summary>
Used to assign the native Serializable pointer to a new object.
</summary>
            <remarks>
Note the order of preserveSB() and releaseSB(). This handles the
corner case when <c>m_nativeptr</c> is same as <c>nativeptr</c>.
</remarks>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.Serializable.ManagedTypeMappingGeneric">
            <summary>
Static map of <c>TypeFactoryMethod</c> delegates created
for managed <c>TypeFactoryMethod</c> delegates.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.UnregisterTypeGeneric(System.Byte)">
            <summary>
Unregister the type with the given typeId
</summary>
            <param name="typeId">typeId of the type to unregister.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.RegisterTypeGeneric(System.Byte,GemStone.GemFire.Cache.Generic.TypeFactoryMethodGeneric,System.Type)">
            <summary>
Register an instance factory method for a given type and typeId.
This should be used when registering types that implement
IGFSerializable.
</summary>
            <param name="typeId">typeId of the type being registered.</param>
            <param name="creationMethod">
the creation function to register
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the method is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.#ctor(gemfire.Serializable*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.RegisterPdxType(GemStone.GemFire.Cache.Generic.PdxTypeFactoryMethod)">
            <summary>
Register an instance factory method for a given type.
This should be used when registering types that implement
IPdxSerializable.
</summary>
            <param name="creationMethod">
the creation function to register
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the method is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.RegisterPdxSerializer(GemStone.GemFire.Cache.Generic.IPdxSerializer)">
            <summary>
Set the PDX serializer for the cache. If this serializer is set,
it will be consulted to see if it can serialize any domain classes which are 
added to the cache in portable data exchange format. 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.RegisterTypeGeneric(GemStone.GemFire.Cache.Generic.TypeFactoryMethodGeneric)">
            <summary>
Register an instance factory method for a given type.
This should be used when registering types that implement
IGFSerializable.
</summary>
            <param name="creationMethod">
the creation function to register
</param>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
if the method is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
if the typeId has already been registered, or there is an error
in registering the type; check <c>Utils::LastError</c> for more
information in the latter case.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.String[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a string array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.String)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a string
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Int64[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a 64-bit integer array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Int64)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a 64-bit integer
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Int32[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a 32-bit integer array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Int32)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a 32-bit integer
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Int16[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a 16-bit integer array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Char[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a character array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Char)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a character
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Int16)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a 16-bit integer
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Single[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a float array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Single)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a float
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Double[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a double array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Double)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a double
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Boolean[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from an boolean array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Byte[])~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from an array of bytes
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Byte)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a byte
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.op_Implicit(System.Boolean)~GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
Implicit conversion operator from a boolean
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.ToString">
            <summary>
Return a string representation of the object.
It simply returns the string representation of the underlying
native object by calling its <c>toString()</c> function.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Serializable.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.Serializable.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserializes the native (C++) object -- returns an instance of the
<c>Serializable</c> class with the native object wrapped inside.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Serializable.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this native (C++) object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Serializable">
            <summary>
This class wraps the native C++ <c>gemfire::Serializable</c> objects
as managed <see cref="T:GemStone.GemFire.Cache.Generic.IGFSerializable" /> objects.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.PdxTypeFactoryMethod">
            <summary>
Signature of function delegates passed to
<see cref="!:Serializable.RegisterPdxType" />. Such functions should
return an empty instance of the type they represent.
New instance will be created during de-serialization of Pdx Types
<see cref="T:GemStone.GemFire.Cache.Generic.IPdxSerializable" />.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.WrapperDelegateGeneric">
            <summary>
Delegate to wrap a native <c>gemfire::Serializable</c> type.
</summary>
            <remarks>
This delegate should return an object of type <c>IGFSerializable</c>
given a native object.
</remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.TypeFactoryMethodGeneric">
            <summary>
Signature of function delegates passed to
<see cref="M:GemStone.GemFire.Cache.Serializable.RegisterType(GemStone.GemFire.Cache.TypeFactoryMethod)" />. Such functions should
return an empty instance of the type they represent.
The delegate shall be stored in the internal <c>DelegateWrapper</c>
class and an instance will be initialized in the
<c>DelegateWrapper.NativeDelegate</c> method by a call to
<see cref="M:GemStone.GemFire.Cache.IGFSerializable.FromData(GemStone.GemFire.Cache.DataInput)" />.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.TypeFactoryNativeMethodGeneric">
            <summary>
Signature of native function delegates passed to native
<c>gemfire::Serializable::registerType</c>.
Such functions should return an empty instance of the type they
represent. The instance will typically be initialized immediately
after creation by a call to native
<c>gemfire::Serializable::fromData</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IGFDelta.HasDelta">
            <summary>
                <c>HasDelta( )</c> is invoked by GemFire during <c>Region.Put( ICacheableKey, IGFSerializable )</c> to determine if the object contains a delta.
If <c>HasDelta( )</c> returns true, the delta in the object is serialized by invoking <c>ToDelta( DataOutput )</c>.
If <c>HasDelta( )</c> returns false, the object is serialized by invoking <c>IGFSerializable.ToData( DataOutput )</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IGFDelta.FromDelta(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Reads in delta information to this object in a user-defined format. This is
invoked on an existing application object after GemFire determines the
presence of delta in <c>DataInput</c> instance.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.InvalidDeltaException">
if the delta in the <c>DataInput</c> instance cannot be applied
to this instance (possible causes may include mismatch of Delta version or logic error).
</exception>
            <exception cref="T:GemStone.GemFire.Cache.Generic.GemFireIOException" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IGFDelta.ToDelta(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Writes out delta information to out in a user-defined format. This is
invoked on an application object after GemFire determines the presence
of delta in it by calling <c>HasDelta()</c> on the object.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.Generic.GemFireIOException" />
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IGFDelta">
            <summary>
This interface is used for delta propagation.
To use delta propagation, an application class must implement interfaces <c>IGFDelta</c> as well as <c>IGFSerializable</c>.
The <c>IGFDelta</c> interface methods <c>HasDelta( ), ToDelta( )</c> and <c>FromDelta( )</c> must be implemented by the class, as these methods are used by GemFire
to detect the presence of delta in an object, to serialize the delta, and to apply a serialized delta to an existing object
of the class.
If a customized cloning method is required, the class must also implement the interface <c>System.ICloneable</c>.
To use cloning in delta propagation for a region, the region attribute for cloning must be enabled.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IGFSerializable.ToString">
            <summary>
Return a string representation of the object.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IGFSerializable.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <remarks>
The classId must be unique within an application suite
and in the range 0 to ((2^31)-1) both inclusive. An application can
thus define upto 2^31 custom <c>IGFSerializable</c> classes.
Returning a value greater than ((2^31)-1) may result in undefined
behaviour.
</remarks>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IGFSerializable.ObjectSize">
            <summary>
Get the size of this object in bytes.
This is only needed if you use the HeapLRU feature.
</summary>
            <remarks>
Note that you can simply return zero if you are not using the HeapLRU feature.
</remarks>
            <returns>the size of this object in bytes.</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IGFSerializable.FromData(GemStone.GemFire.Cache.Generic.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IGFSerializable.ToData(GemStone.GemFire.Cache.Generic.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IGFSerializable">
            <summary>
This interface class is the superclass of all user objects 
in the cache that can be serialized.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.TransactionDataRebalancedException">
            <summary>
Thrown if commit rebalance happens during a transaction.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.TransactionDataNodeHasDepartedException">
            <summary>
Thrown if transaction delegate went down.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CommitConflictException">
            <summary>
Thrown if commit fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.KeyNotFoundException">
            <summary>
Thrown if a Key is not present in the region.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqExistsException">
            <summary>
Thrown if a Cq by this name already exists on this client
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqQueryException">
            <summary>
Thrown if the Cq Query failed
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqClosedException">
            <summary>
Thrown if the Cq on which the operaion performed is closed
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqException">
            <summary>
Thrown during continuous query execution time.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.FunctionExecutionException">
            <summary>
Thrown when function execution failed
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CqInvalidException">
            <summary>
Thrown when cq is invalid
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.AllConnectionsInUseException">
            <summary>
Thrown when all connections in a pool are in use..
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.NoAvailableLocatorsException">
            <summary>
Thrown when a client is unable to contact any locators.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DuplicateDurableClientException">
            <summary>
Thrown when a duplicate durable client id is provided to the server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.AuthenticationRequiredException">
            <summary>
Thrown when credentials are not provided to a server which expects them.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.AuthenticationFailedException">
            <summary>
Thrown when authentication to the server fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.NotAuthorizedException">
            <summary>
Thrown when a client operation is not authorized on the server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.MessageException">
            <summary>
Thrown when an unknown message is received from the server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.QueryException">
            <summary>
Thrown when query exception occurs at the server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.OutOfRangeException">
            <summary>
Thrown when bound of array/vector etc. is exceeded.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.RedundancyException">
            <summary>
Thrown when redundancy level is not satisfied.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheServerException">
            <summary>
Thrown when an exception occurs on the cache server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ShutdownFailedException">
            <summary>
Thrown when persistence manager fails to close properly.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.InitFailedException">
            <summary>
Thrown when persistence manager fails to initialize.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DiskCorruptException">
            <summary>
Thrown by the persistence manager when the data
to be read from disk is corrupt.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.DiskFailureException">
            <summary>
Thrown by the persistence manager when a write
fails due to disk failure.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.FatalInternalException">
            <summary>
Thrown when there is a fatal internal exception in GemFire.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.RegionCreationFailedException">
            <summary>
Thrown when a region creation operation fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.BufferSizeExceededException">
            <summary>
Thrown when the internal buffer size is exceeded.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.WrongRegionScopeException">
            <summary>
Thrown when a region is created in an incorrect scope.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.NotOwnerException">
            <summary>
Thrown when an attempt is made to release a lock not
owned by the thread.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.OutOfMemoryException">
            <summary>
Thrown when the system cannot allocate any more memory.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheProxyException">
            <summary>
Thrown when there is an error in the cache proxy.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.NotConnectedException">
            <summary>
Thrown when an operation is attempted before connecting
to the distributed system.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.EntryExistsException">
            <summary>
Thrown when attempt is made to create an existing entry.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.NullPointerException">
            <summary>
Thrown when a null argument is provided to a method
where it is expected to be non-null.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.GemFireConfigException">
            <summary>
Thrown when gemfire configuration file is incorrect.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.GemFireIOException">
            <summary>
Thrown when there is an input/output error.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.EntryNotFoundException">
            <summary>
Thrown when an operation is attempted on a non-existent entry.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ClassCastException">
            <summary>
Thrown when a cast operation fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.UnknownException">
            <summary>
An unknown exception occurred.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.ConcurrentModificationException">
            <summary>
Thrown when a concurrent operation fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.StatisticsDisabledException">
            <summary>
Thrown when statistics are invoked for a region where
they are disabled.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.UnsupportedOperationException">
            <summary>
Thrown when an operation unsupported by the
current configuration is attempted.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.InterruptedException">
            <summary>
Thrown when an operation is interrupted.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.FileNotFoundException">
            <summary>
Thrown when a non-existing file is accessed.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.AlreadyConnectedException">
            <summary>
Thrown when an attempt is made to connect to
DistributedSystem second time.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.NoSystemException">
            <summary>
Thrown when the connecting target is not running.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.EntryDestroyedException">
            <summary>
Thrown when an operation is attempted on a destroyed entry.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.RegionDestroyedException">
            <summary>
Thrown when an operation is attempted on a destroyed region.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheLoaderException">
            <summary>
Thrown when the cache loader aborts the operation.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.LeaseExpiredException">
            <summary>
Thrown when lease of cache proxy has expired.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheClosedException">
            <summary>
Thrown when an operation is attempted on a closed cache.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.RegionExistsException">
            <summary>
Thrown when an attempt is made to create an existing region.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheListenerException">
            <summary>
Thrown when the cache listener throws an exception.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheWriterException">
            <summary>
Thrown when the cache writer aborts the operation.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.TimeoutException">
            <summary>
Thrown when a timout occurs.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheXmlException">
            <summary>
Thrown when the cache xml is incorrect.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CacheExistsException">
            <summary>
Thrown when an attempt is made to create an existing cache.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IllegalStateException">
            <summary>
Thrown when the state of cache is manipulated to be illegal.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IllegalArgumentException">
            <summary>
Thrown when an argument to a method is illegal.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.AssertionException">
Handle gemfire exceptions from native layer and convert to managed
exceptions. Also handle fatal exceptions to generate mini dumps if
stack trace dumping is enabled
Creates a class <c>x</c> named for each exception <c>y</c>.
Creates a class named for each exception <c>x</c>.
<summary>
A gemfire assertion exception.
</summary></member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
Initializes a new instance of the <c>GemFireException</c> class with
serialized data.
This allows deserialization of this exception in .NET remoting.
</summary>
            <param name="info">
holds the serialized object data about
the exception being thrown
</param>
            <param name="context">
contains contextual information about
the source or destination
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.GenerateMiniDump(System.Int32,System.IntPtr)">
            <summary>
Generate a minidump of the current process in the directory
specified for log files using "log-file" property.
This is equivalent to the ".dump /ma" command of windbg.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.GenerateMiniDump">
            <summary>
Generate a minidump of the current process in the directory
specified for log files using "log-file" property.
This is equivalent to the ".dump /ma" command of windbg.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.#ctor(System.String,System.Exception)">
            <summary>
Constructor to create an exception object with the given message
and with the given inner exception.
</summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception object.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.#ctor(System.String)">
            <summary>
Constructor to create an exception object with the given message.
</summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.ThrowNative">
            <summary>
Throws the C++ native exception object for this managed
<c>GemFireException</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.ThrowNative(System.Exception)">
            <summary>
Throws the C++ native exception object for the given .NET exception.
</summary>
            <remarks>
This method is to handle conversion of managed exceptions to
C++ exception for those thrown by managed callbacks.
For non-Gemfire .NET exceptions we wrap it inside the generic
<c>GemfireException</c> with a special prefix in message.
While converting the exception back from C++ to .NET if the
prefix is found in the message, then it tries to construct
the original exception by reflection on the name of exception
contained in the message. Note that in this process the
original stacktrace is appended to the message of the exception.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.GetNative">
            <summary>
Gets the C++ native exception object for this managed
<c>GemFireException</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.GetNative(System.Exception)">
            <summary>
Gets the C++ native exception object for a given managed exception.
</summary>
            <remarks>
This method is to handle conversion of managed exceptions to
C++ exception for those thrown by managed callbacks.
For non-Gemfire .NET exceptions we wrap it inside the generic
<c>GemfireException</c> with a special prefix in message.
While converting the exception back from C++ to .NET if the
prefix is found in the message, then it tries to construct
the original exception by reflection on the name of exception
contained in the message. Note that in this process the
original stacktrace is appended to the message of the exception.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.GetStackTrace(gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the stack trace for the given native exception.
</summary>
            <param name="nativeEx">The native GemFire exception object</param>
            <returns>The stack trace of the native exception.</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.Get(gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create the managed GemFire exception for a given native GemFire exception.
As a special case normal system exceptions are also created when the
native exception is a wrapper of a managed system exception.
</summary>
            <remarks>
Wherever the native GemFire C++ code raises a <c>gemfire::Exception</c>,
the CLI wrapper code should have a catch-all for those and use
this function to create the corresponding managed GemFire exception.
If no managed GemFire exception has been defined (or has not been
added using _GF_MG_EXCEPTION_ADD3 in ExceptionTypesMN.cpp) then a
generic <c>GemFireException</c> exception is returned.
</remarks>
            <param name="nativeEx">The native GemFire exception object</param>
            <returns>
The managed GemFire exception object corresponding to the provided
native GemFire exception object.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.GemFireException.Init">
            <summary>
Static method to associate the native exception names with
the corresponding managed exception factory delegates.
</summary>
            <remarks>
This method is not thread-safe and should be called in a single thread.
</remarks>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireException.NameDelegatePair.m_delegate">
            <summary>
The factory delegate of the managed GemFire exception class
corresponding to <c>m_name</c></summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireException.NameDelegatePair.m_name">
            <summary>
The name of the native GemFire exception class.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.GemFireException.NameDelegatePair">
            <summary>
Name and delegate pair class. The Native2ManagedExMap dictionary
is populated from a static array of this class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireException.Native2ManagedExMap">
            <summary>
This contains a mapping of the native GemFire exception class
name to the factory delegate of the corresponding managed GemFire
exception class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.GemFireException.MgSysExPrefix">
            <summary>
Prefix for distiguishing managed system exceptions
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.GemFireException">
            <summary>
The base exception class of all managed GemFire exceptions.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.CreateException2">
            <summary>
Factory delegate to create a managed GemFire exception.
</summary>
            <remarks>
For each managed exception class, its factory delegate is registered
and maintained in a static dictionary mapped to its corresponding
native GemFire C++ exception name.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Debug(System.String,System.Object[])">
            <summary>
Debug level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Finest(System.String,System.Object[])">
            <summary>
Finest level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Finer(System.String,System.Object[])">
            <summary>
Finer level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Fine(System.String,System.Object[])">
            <summary>
Fine level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Config(System.String,System.Object[])">
            <summary>
Config level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Info(System.String,System.Object[])">
            <summary>
Info level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Warning(System.String,System.Object[])">
            <summary>
Warning level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Error(System.String,System.Object[])">
            <summary>
Error level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.LogCatch(GemStone.GemFire.Cache.Generic.LogLevel,System.String,System.Exception)">
            <summary>
Logs both a message and a caught exception.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.LogThrow(GemStone.GemFire.Cache.Generic.LogLevel,System.String,System.Exception)">
            <summary>
Logs both a message and a thrown exception.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Write(GemStone.GemFire.Cache.Generic.LogLevel,System.String)">
            <summary>
Logs a message at the given level.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Enabled(GemStone.GemFire.Cache.Generic.LogLevel)">
            <summary>
True if log messages at the given level are enabled.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.LogFileName">
            <summary>
Returns the name of the current log file.
NOTE: This function is for debugging only, as it is not completely
thread-safe!
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.SetLevel(GemStone.GemFire.Cache.Generic.LogLevel)">
            <summary>
Sets the current log level.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Level">
            <summary>
Returns the current log level.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Close">
            <summary>
Closes logging facility (until next init).
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Init(GemStone.GemFire.Cache.Generic.LogLevel,System.String,System.Int32)">
            <summary>
Initializes logging facility with given level, filename, and file size limit.
</summary>
            <param name="level">the logging level</param>
            <param name="logFileName">the log file name</param>
            <param name="logFileLimit">maximum allowable size of the log file, in bytes, 
       or 0 for the default (1 Gbyte)</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.Log.Init(GemStone.GemFire.Cache.Generic.LogLevel,System.String)">
            <summary>
Initializes the logging facility with the given level and filename.
</summary>
            <param name="level">the logging level</param>
            <param name="logFileName">the log file name</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.Log">
            <summary>
Defines methods available to clients that want to write a log message
to their GemFire system's shared log file.
</summary>
            <remarks>
Any attempt to use an instance after its connection is disconnected
will throw a <c>NotConnectedException</c>.
<para>
For any logged message the log file will contain:
<ul><li> The message's log level.</li><li> The time the message was logged.</li><li> The ID of the connection and thread that logged the message.</li><li> The message itself, perhaps with
an exception including the exception's stack trace.</li></ul></para><para>
A message always has a level.
Logging levels are ordered. Enabling logging at a given level also
enables logging at higher levels. The higher the level the more
important and urgent the message.
</para><para>
The levels, in descending order of severity, are:
<ul><li><c>Error</c> (highest severity) is a message level
indicating a serious failure.  In general <c>error</c>
messages should describe events that are of considerable
importance and which will prevent normal program execution. They
should be reasonably intelligible to end users and to system
administrators.</li><li><c>Warning</c> is a message level indicating a
potential problem.  In general <c>warning</c> messages
should describe events that will be of interest to end users or
system managers, or which indicate potential problems.</li><li><c>Info</c> is a message level for informational
messages.  Typically <c>info</c> messages should be
reasonably significant and should make sense to end users and
system administrators.</li><li><c>Config</c> is a message level for static
configuration messages.  <c>config</c> messages are intended
to provide a variety of static configuration information, to
assist in debugging problems that may be associated with
particular configurations.</li><li><c>Fine</c> is a message level providing tracing
information.  In general the <c>fine</c> level should be
used for information that will be broadly interesting to
developers. This level is for the lowest volume, and most
important, tracing messages.</li><li><c>Finer</c> indicates a moderately detailed tracing
message.  This is an intermediate level between <c>fine</c>
and <c>finest</c>.</li><li><c>Finest</c> indicates a very detailed tracing
message.  Logging calls for entering, returning, or throwing an
exception are traced at the <c>finest</c> level.</li><li><c>Debug</c> (lowest severity) indicates a highly
detailed tracing message.  In general the <c>debug</c> level
should be used for the most voluminous detailed tracing messages.</li></ul></para></remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.LogLevel">
            <summary>
Logging levels.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.All">
            <summary>
All the log messages.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Debug">
            <summary>
For highly detailed tracing information.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Finest">
            <summary>
For very detailed tracing information.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Finer">
            <summary>
For moderately detailed tracing information.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Fine">
            <summary>
For tracing information.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Config">
            <summary>
For Static configuration messages.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Default">
            <summary>
The default logging level.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Info">
            <summary>
For informational purpose.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Warning">
            <summary>
Indicates potential problem.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Error">
            <summary>
Indicates serious failure.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Generic.LogLevel.Null">
            <summary>
No log.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadField(System.String,System.Type)">
            <summary>
Reads the named field  of Type "type" and returns its value.
</summary>
            <param name="fieldName">The name of a member field.</param>
            <param name="type">The type of a member field, which value needs to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadUnreadFields">
            <summary>
To preserve unread data, which get added in new version of type.
</summary>
            <return>Unread data.</return>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.IsIdentityField(System.String)">
            <summary>
Whether field is used as identity field or not.
</summary>
            <param name="fieldName">The name of a member field.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.HasField(System.String)">
            <summary>
Whether field is available or not.
</summary>
            <param name="fieldName">The name of a member field.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadArrayOfByteArrays(System.String)">
            <summary>
Read a two-dimenesional signed byte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadObjectArray(System.String)">
            <summary>
Read a object array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadStringArray(System.String)">
            <summary>
Read a string array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadDoubleArray(System.String)">
            <summary>
Read a double array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadFloatArray(System.String)">
            <summary>
Read a float from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadLongArray(System.String)">
            <summary>
Read a long array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadIntArray(System.String)">
            <summary>
Read a int array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadShortArray(System.String)">
            <summary>
Read a short from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadByteArray(System.String)">
            <summary>
Read a signed byte array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadCharArray(System.String)">
            <summary>
Read a char array from the data.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadBooleanArray(System.String)">
            <summary>
Read a boolean array from the data. 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadDate(System.String)">
            <summary>
Read a Date from the data. 
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadObject(System.String)">
            <summary>
Read a serializable object from the data. Null objects are handled.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadString(System.String)">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadDouble(System.String)">
            <summary>
Read a double precision number from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadFloat(System.String)">
            <summary>
Read a floating point number from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadLong(System.String)">
            <summary>
Read a 64-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadInt(System.String)">
            <summary>
Read a 32-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadShort(System.String)">
            <summary>
Read a 16-bit integer from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadChar(System.String)">
            <summary>
Read a char value from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadBoolean(System.String)">
            <summary>
Read a boolean value from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IPdxReader.ReadByte(System.String)">
            <summary>
Read a signed byte from the stream.
</summary>
            <param name="fieldName">The name of a member field whose value to read.</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IPdxReader">
            <summary>
A IPdxReader will be passed to IPdxSerializable.fromData or 
during deserialization of a PDX. The domain class needs to deserialize field members 
using this interface. This interface is implemented by Native Client.
Each readXXX call will return the field's value. If the serialized 
PDX does not contain the named field then a default value will 
be returned. Standard Java defaults are used. For Objects this is 
null and for primitives it is 0 or 0.0.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Generic.IPdxUnreadFields">
            <summary>
Serialize the data in gemfire Portable Data eXchange(Pdx) Format.
This format provides class versioning(forward and backward compability of types) in cache.
This provides ability to query .NET domian objects.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear(System.Object)">
            <summary>
remove all entries in the region.	
For local region instance - remove all entries in the local region.
For distributed region instance - remove all entries in the local region, 
and propagate the operation to server.
</summary>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.IsDestroyed">
            <summary>
True if this region has been destroyed.
</summary>
            <returns>true if destroyed</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.RegionService">
            <summary>
Gets the RegionService for this region.
</summary>
            <returns>RegionService</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.Cache">
            <summary>
Gets the cache for this region.
</summary>
            <returns>region's cache</returns>
            <deprecated>as of NativeClient 3.5 </deprecated>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.SubRegions(System.Boolean)">
            <summary>
Returns the subregions of this region.
</summary>
            <param name="recursive">if true, also return all nested subregions</param>
            <returns>collection of regions</returns>
            <exception cref="!:RegionDestroyedException">
this region has already been destroyed
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.CreateSubRegion(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{`0,`1})">
            <summary>
Creates a subregion with the given name and attributes.
</summary>
            <param name="subRegionName">new subregion name</param>
            <param name="attributes">subregion attributes</param>
            <returns>new subregion</returns>
            <seealso cref="!:CreateServerSubRegion" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubRegion(System.String)">
            <summary>
Returns the subregion identified by the path, null if no such subregion.
</summary>
            <param name="path">path</param>
            <returns>subregion, or null if none</returns>
            <seealso cref="P:GemStone.GemFire.Cache.Generic.IRegion`2.FullPath" />
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.SubRegions(System.Boolean)" />
            <seealso cref="P:GemStone.GemFire.Cache.Generic.IRegion`2.ParentRegion" />
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.Statistics">
            <summary>
Returns the statistics for this region.
</summary>
            <returns>the <c>CacheStatistics</c> for this region</returns>
            <exception cref="!:StatisticsDisabledException">
if statistics have been disabled for this region
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.AttributesMutator">
            <summary>
Return a mutator object for changing a subset of the
region attributes.
</summary>
            <returns>
attribute mutator
</returns>
            <exception cref="!:RegionDestroyedException">
if the region has been destroyed
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.Attributes">
            <summary>
Returns the attributes for this region, which can be used to create a new
region with <see cref="!:Cache.CreateRegion" />.
</summary>
            <returns>
region's attributes
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.ParentRegion">
            <summary>
Gets the parent region.
</summary>
            <returns>
region's parent, if any, or null if this is a root region
</returns>
            <exception cref="!:RegionDestroyedException">
if the region has been destroyed
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.FullPath">
            <summary>
Gets the region's full path, which can be used to get this region object
with <see cref="M:GemStone.GemFire.Cache.Cache.GetRegion(System.String)" />.
</summary>
            <returns>
region's pathname
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.Name">
            <summary>
Gets the region name.
</summary>
            <returns>
region's name
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.GetAll(System.Collections.Generic.ICollection`1{`0},System.Collections.Generic.IDictionary`2{`0,`1},System.Collections.Generic.IDictionary`2{`0,System.Exception^},System.Boolean)">
            <summary>
Gets values for collection of keys from the local cache or server.
If value for a key is not present locally then it is requested from the
java server. The value returned is not copied, so multi-threaded
applications should not modify the value directly,
but should use the update methods.
For local region instance - this method is not applicable.
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" />
and <see cref="!:CacheStatistics.HitCount" /> and
<see cref="!:CacheStatistics.MissCount" /> for this region and the entry.
</summary>
            <param name="keys">the collection of keys</param>
            <param name="values">
output parameter that provides the map of keys to
respective values; ignored if NULL; when this is NULL then at least
the <c>addToLocalCache</c> parameter should be true and caching
should be enabled for the region to get values into the region
otherwise an <c>IllegalArgumentException</c> is thrown.
</param>
            <param name="exceptions">
output parameter that provides the map of keys
to any exceptions while obtaining the key; ignored if this is NULL
</param>
            <param name="addToLocalCache">
true if the obtained values have also to be added to the local cache
</param>
            <exception cref="!:IllegalArgumentException">
If the collection of keys is null or empty. Other invalid case is when
the <c>values</c> parameter is NULL, and either
<c>addToLocalCache</c> is false or caching is disabled
for this region.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server while
processing the request.
</exception>
            <exception cref="!:NotConnectedException">
if region is not connected to the cache because the client
cannot establish usable connections to any of the given servers
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:System.TimeoutException">
if operation timed out.
</exception>
            <exception cref="!:UnknownException">
For other exceptions.
</exception>
            <exception cref="T:System.NotSupportedException">
if it is called by local region instance <see cref="!:Region.GetLocalView" /></exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Get(`0,System.Object)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.GetAll(System.Collections.Generic.ICollection`1{`0},System.Collections.Generic.IDictionary`2{`0,`1},System.Collections.Generic.IDictionary`2{`0,System.Exception^})">
            <summary>
Gets values for collection of keys from the local cache or server.
If value for a key is not present locally then it is requested from the
java server. The value returned is not copied, so multi-threaded
applications should not modify the value directly,
but should use the update methods.
For local region instance - this method is not applicable.
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" />
and <see cref="!:CacheStatistics.HitCount" /> and
<see cref="!:CacheStatistics.MissCount" /> for this region and the entry.
</summary>
            <param name="keys">the collection of keys</param>
            <param name="values">
output parameter that provides the map of keys to
respective values; when this is NULL then an
<c>IllegalArgumentException</c> is thrown.
</param>
            <param name="exceptions">
output parameter that provides the map of keys
to any exceptions while obtaining the key; ignored if this is NULL
</param>
            <exception cref="!:IllegalArgumentException">
If the collection of keys is null or empty,
or <c>values</c> argument is null.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server while
processing the request.
</exception>
            <exception cref="!:NotConnectedException">
if region is not connected to the cache because the client
cannot establish usable connections to any of the given servers
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:System.TimeoutException">
if operation timed out.
</exception>
            <exception cref="!:UnknownException">
For other exceptions.
</exception>
            <exception cref="T:System.NotSupportedException">
if it is called by local region instance <see cref="!:Region.GetLocalView" /></exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Get(`0,System.Object)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.PutAll(System.Collections.Generic.IDictionary`2{`0,`1},System.Int32)">
            <summary>
Puts a (IDictionary) generic collection of key/value pairs in this region.
</summary>
            <remarks>
                <para>
If there is already an entry associated with any key in the map in
this region, the entry's previous value is overwritten.
The new values are propogated to the java server to which it is connected with.
PutAll is intended for speed up large amount of put operation into
the same region.
For local region instance - this method is not applicable.
</para>
            </remarks>
            <param name="map">
A map contains entries, i.e. (key, value) pairs. It is generic collection of key/value pairs.
Value should not be null in any of the entries.
</param>
            <param name="timeout">The time (in seconds) to wait for the PutAll
response. It should be less than or equal to 2^31/1000 i.e. 2147483.
Optional.
</param>
            <exception cref="!:IllegalArgumentException">
If timeout is more than 2^31/1000 i.e. 2147483.
</exception>
            <exception cref="!:NullPointerException">
if any value in the map is null
</exception>
            <exception cref="!:RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:System.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <exception cref="T:System.NotSupportedException">
if it is called by local region instance <see cref="!:Region.GetLocalView" /></exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Put(`0,`1,System.Object)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.PutAll(System.Collections.Generic.IDictionary`2{`0,`1})">
            <summary>
Puts a (IDictionary) generic collection of key/value pairs in this region.
</summary>
            <remarks>
                <para>
If there is already an entry associated with any key in the map in
this region, the entry's previous value is overwritten.
The new values are propogated to the java server to which it is connected with.
PutAll is intended for speed up large amount of put operation into
the same region.
For local region instance - this method is not applicable.
</para>
            </remarks>
            <param name="map">
A map contains entries, i.e. (key, value) pairs. It is generic collection of key/value pairs.
Value should not be null in any of the entries.
</param>
            <exception cref="!:NullPointerException">
if any value in the map is null
</exception>
            <exception cref="!:RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:System.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <exception cref="T:System.NotSupportedException">
if it is called by local region instance <see cref="!:Region.GetLocalView" /></exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Put(`0,`1,System.Object)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.DestroyRegion(System.Object)">
            <summary>
Destroys the whole distributed region and provides a user-defined parameter
object to any <c>ICacheWriter</c> invoked in the process.
</summary>
            <remarks>
                <para>
Destroy cascades to all entries and subregions. After the destroy,
this region object can not be used any more. Any attempt to use
this region object will get a <c>RegionDestroyedException</c>
The region destroy not only destroys the local region but also destroys the
server region.
For local region instance - destroys the whole local region only
For distributed region instance - destroys the whole local region and this
operation is also propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="callbackArg">
a user-defined parameter to pass to callback events triggered by this call
</param>
            <exception cref="!:CacheWriterException">
if a CacheWriter aborts the operation; if this occurs some
subregions may have already been successfully destroyed.
</exception>
            <exception cref="!:CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.InvalidateRegion" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.DestroyRegion">
            <summary>
Destroys the whole distributed region and provides a user-defined parameter
object to any <c>ICacheWriter</c> invoked in the process.
</summary>
            <remarks>
                <para>
Destroy cascades to all entries and subregions. After the destroy,
this region object can not be used any more. Any attempt to use
this region object will get a <c>RegionDestroyedException</c>
The region destroy not only destroys the local region but also destroys the
server region.
For local region instance - destroys the whole local region only
For distributed region instance - destroys the whole local region and this
operation is also propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <exception cref="!:CacheWriterException">
if a CacheWriter aborts the operation; if this occurs some
subregions may have already been successfully destroyed.
</exception>
            <exception cref="!:CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.InvalidateRegion" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.InvalidateRegion(System.Object)">
            <summary>
Invalidates this region.
</summary>
            <remarks>
                <para>
The invalidation will cascade to all the subregions and cached
entries. The region
and the entries in it will still exist.
For local region instance - invalidates this region without distributing to other caches.
For distributed region instance - Invalidates this region and this 
operation is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
To remove all the
entries and the region, use <see cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.DestroyRegion" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="callbackArg">
user-defined parameter to pass to callback events triggered by this method
</param>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception>
            <exception cref="!:CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.DestroyRegion" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionInvalidate(GemStone.GemFire.Cache.RegionEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.InvalidateRegion">
            <summary>
Invalidates this region.
</summary>
            <remarks>
                <para>
The invalidation will cascade to all the subregions and cached
entries. The region
and the entries in it will still exist.
For local region instance - invalidates this region without distributing to other caches.
For distributed region instance - Invalidates this region and this 
operation is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
To remove all the
entries and the region, use <see cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.DestroyRegion" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <exception cref="!:CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.DestroyRegion" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionInvalidate(GemStone.GemFire.Cache.RegionEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Get(`0,System.Object)">
            <summary>
Returns the value for the given key, passing the callback argument
to any cache loaders or that are invoked in the operation.
</summary>
            <remarks>
                <para>          
For local region instance - returns the value with the specified key from the local cache only.
For distributed region instance - If the value is not present locally then it is requested from
the java server. If even that is unsuccessful then a local CacheLoader will be invoked
if there is one.
</para>
                <para>
The value returned by get is not copied, so multi-threaded applications
should not modify the value directly, but should use the update methods.
</para>
                <para>
Updates the <see cref="!:CacheStatistics.LastAccessedTime" /><see cref="!:CacheStatistics.HitCount" />, <see cref="!:CacheStatistics.MissCount" />,
and <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> (if a new value is loaded)
for this region and the entry.
</para>
            </remarks>
            <param name="key">
key whose associated value is to be returned -- the key
object must implement the Equals and GetHashCode methods.
</param>
            <param name="callbackArg">
An argument passed into the CacheLoader if loader is used.
Has to be Serializable (i.e. implement <c>IGFSerializable</c>);
can be null.
</param>
            <returns>
value, or null if the value is not found and can't be loaded
</returns>
            <exception cref="!:IllegalArgumentException">
if key is null
</exception>
            <exception cref="!:CacheLoaderException">
if CacheLoader throws an exception
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Put(`0,`1,System.Object)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Put(`0,`1,System.Object)">
            <summary>
Puts a new value into an entry in this region with the specified key,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
For local region instance - Puts a new value into an entry in this region in the local cache only.
For distributed region instance - Puts a new value into an entry in this region
and this operation is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="!:IllegalArgumentException">
if key is null
</exception>
            <exception cref="!:CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="!:CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="!:RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:System.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Get(`0,System.Object)" />
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(`0,`1)" />
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.Keys">
            <summary>
Gets an ICollection containing the keys of the IDictionary
Returns all the keys for this region. This includes
keys for which the entry is invalid.
For local region instance - gets collection of keys from local cache only.
For distributed region instance - gets collection of keys from the Gemfire cache server.
</summary>
            <returns>collection of keys</returns>
            <remark>
The order of the keys in the returned ICollection is unspecified, 
but it is guaranteed to be the same order as the corresponding values in the ICollection
returned by the Values property.
</remark>
            <exception cref="!:UnsupportedOperationException">
if the member type is not <c>Client</c>
or region is not a Native Client region.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:System.TimeoutException">
if there is a timeout getting the keys
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.IsReadOnly">
            <summary>
This property throws NotImplementedException when called by 
both local and distributed region instances.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Remove(`0,`1,System.Object)">
            <summary>
Removes the entry with the specified key and value, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Remove removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The Remove is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to Remove</param>
            <param name="value">the value of the entry to Remove</param>
            <param name="callbackArg"> the callback for user to pass in, It can also be null</param>.
<exception cref="!:IllegalArgumentException">if key is null</exception><exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception><exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception><exception cref="T:System.TimeoutException">
if the operation timed out
</exception><exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception><returns>true if entry with key and its value are removed otherwise false.</returns><seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)" /><seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" /><seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" /></member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Remove(System.Collections.Generic.KeyValuePair`2{`0,`1})">
            <summary>
Removes a key and value from the dictionary.          
</summary>
            <remarks>
                <para>
Remove removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The Remove is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
                <para>
The comparison of the value of the key value pair depends on the Equals function of the TValue class.
If the Equals function is not overriden in the TValue class the behavior of this function is undefined. Hence, this 
function won't work properly for the .NET types that uses the default implementation of the Equals method, for 
e.g. arrays.
</para>
            </remarks>
            <param name="keyValuePair">The KeyValuePair structure representing 
the key and value to remove from the Dictionary.</param>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception>
            <returns>true if the key and value represented by keyValuePair is successfully found and removed;
otherwise, false. This method returns false if keyValuePair is not found in the ICollection.</returns>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.CopyTo(System.Collections.Generic.KeyValuePair`2{`0,`1}[],System.Int32)">
            <summary>
Copies the elements of the ICollection to an Array, starting at a particular Array index.
This operation copies entries from local region only.
</summary>
            <param name="toArray">
The one-dimensional Array that is the destination of the elements copied from ICollection. 
The Array must have zero-based indexing.
</param>
            <param name="startIdx">
The zero-based index in array at which copying begins.
</param>
            <exception cref="T:System.ArgumentNullException">
if toArray is a null reference
</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
if startIdx is less than 0.
</exception>
            <exception cref="T:System.ArgumentException">
if toArray is multidimensional or The number of elements in the source ICollection is greater than 
the available space from startIdx to the end of the destination array or startIdx is equal to 
or greater than the length of array.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Contains(System.Collections.Generic.KeyValuePair`2{`0,`1})">
            <summary>
Determines whether the ICollection contains a specific value.
</summary>
            <remarks>
                <para>          
For local region instance - returns the value with the specified key from the local cache only.
For distributed region instance - If the value is not present locally then it is requested from
the java server. If even that is unsuccessful then a local CacheLoader will be invoked
if there is one.
</para>
                <para>
The comparison of the value of the key value pair depends on the Equals function of the TValue class.
If the Equals function is not overriden in the TValue class the behavior of this function is undefined. Hence, this 
function won't work properly for the .NET types that uses the default implementation of the Equals method, for 
e.g. arrays.
</para>
            </remarks>
            <param name="keyValuePair">
The KeyValuePair structure to locate in the ICollection.
</param>
            <exception cref="!:IllegalArgumentException">
if key is null
</exception>
            <exception cref="!:CacheLoaderException">
if CacheLoader throws an exception
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception>
            <returns>
true if keyValuePair is found in the ICollection; otherwise, false.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.TryGetValue(`0,`1@)">
            <summary>
Gets the value associated with the specified key.
</summary>
            <remark>
This method combines the functionality of the ContainsKey method and the Item property.
If the key is not found, then the value parameter gets the appropriate default value for the value
type V; for example, zero (0) for integer types, false for Boolean types, and a null reference for
reference types.
For local region instance - returns the value with the specified key from the local cache only.
For distributed region instance - If the value is not present locally then it is requested from
the java server. If even that is unsuccessful then a local CacheLoader will be invoked
if there is one.
</remark>
            <param name="key">
The key whose value to get.
</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is
found; otherwise, the default value for the type of the value parameter. 
This parameter is passed uninitialized.</param>
            <exception cref="!:IllegalArgumentException">
if key is null
</exception>
            <exception cref="!:CacheLoaderException">
if CacheLoader throws an exception
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception>
            <returns>
true if the object that implements IDictionary contains an element with the specified key; otherwise, false.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Remove(`0,System.Object)">
            <summary>
Removes the entry with the specified key, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Removes not only the value, but also the key and entry
from this region.
</para>
                <para>
For local region instance - removes the value with the specified key in the local cache only.
For distributed region instance - destroy is propogated to the Gemfire cache server
to which it is connected with.          
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <param name="callbackArg">
a user-defined parameter to pass to cache writers triggered by this method
</param>
            <exception cref="!:IllegalArgumentException">if key is null</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <returns>
true if the element is successfully removed; otherwise, false. 
This method also returns false if key was not found in the original IDictionary. 
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Remove(`0)">
            <summary>
Removes the element with the specified key from the IDictionary.
</summary>
            <remarks>
For local region instance - removes the entry with the specified key from the local cache only.
For distributed region instance - remove is propogated to the Gemfire cache server.
</remarks>
            <param name="key">
The key of the element to remove.
</param>
            <exception cref="!:IllegalArgumentException">if key is null</exception>
            <exception cref="!:EntryNotFoundException">
if the entry does not exist in this region locally, applicable only for local region instance.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:RegionDestroyedException">
if this region has been destroyed
</exception>
            <returns>
true if the element is successfully removed; otherwise, false. 
This method also returns false if key was not found in the original IDictionary. 
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(`0,`1,System.Object)">
            <summary>
Creates a new entry in this region with the specified key and value,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
For local region instance - creates a new entry in this region with the specified key and value
in the local cache only.
For distributed region instance - The new entry is propogated to the java server to which it is 
connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <param name="callbackArg">
a custome parameter to pass to the cache writer or cache listener
</param>
            <exception cref="!:IllegalArgumentException">
if key is null
</exception>
            <exception cref="!:EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="!:CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="!:CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:System.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Put(`0,`1,System.Object)" />
            <seealso cref="M:GemStone.GemFire.Cache.Generic.IRegion`2.Get(`0,System.Object)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(`0,`1)">
            <summary>
Adds an element with the provided key and value to the IDictionary. 
</summary>
            <remark>
You can also use the Item property to add new elements by setting the value of a key 
that does not exist in the dictionary; for example, myCollection["myNonexistentKey"] = myValue
However, if the specified key already exists in the dictionary, setting the Item property 
overwrites the old value. In contrast, the Add method does not modify existing elements.
</remark>
            <remarks>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
                <para>
For local region instance - creates a new entry in this region with the specified keyvaluepair
in the local cache only.
For distributed region instance - The new entry is propogated to the java server to which it is 
connected with.
</para>
            </remarks>
            <param name="key">
The object to use as the key of the element to add.
</param>
            <param name="value">
The object to use as the value of the element to add.
</param>
            <exception cref="!:IllegalArgumentException">
if key is null
</exception>
            <exception cref="!:EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="!:CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="!:CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:System.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsKey(`0)">
            <summary>
Determines whether the IDictionary contains an element with the specified key. 
</summary>
            <remarks>
For local region instance - This only searches in the local cache.
For distributed region instance - checks to see if the key is present on the server.
</remarks>
            <param name="key">
The key to locate in the IDictionary.
</param>
            <exception cref="T:System.ArgumentNullException">
key is a null reference
</exception>
            <returns>
true if the IDictionary contains an element with the key; otherwise, false. 
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Generic.IRegion`2.Item(`0)">
            <summary>
Gets or sets the element with the specified key. 
</summary>
            <remarks>
This property provides the ability to access a specific element in the collection
by using the following syntax: myCollection[key].
You can also use the Item property to add new elements by setting the value of a key 
that does not exist in the dictionary; for example, myCollection["myNonexistentKey"] = myValue
However, if the specified key already exists in the dictionary, 
setting the Item property overwrites the old value. In contrast, 
the Add method does not modify existing elements.
This property is applicable to local as well as distributed region.
For local region instance - Puts/Gets a new value into an entry in this region in the local cache only.
For distributed region instance - Puts/Gets a new value into an entry in this region
and this operation is propogated to the Gemfire cache server to which it is connected with.
</remarks>
            <param name="key">
The key of the element to get or set.
</param>
            <param name="Property Value">
The element with the specified key.
</param>
            <exception cref="!:IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
If given key was not present in the region and if region is not in secure mode, or if Pool
attached with Region is not in multiusersecure mode.
</exception>
            <exception cref="!:EntryNotFoundException">
if given key's value is null.
</exception>
            <exception cref="!:CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="!:CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="!:RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:System.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <exception cref="!:CacheLoaderException">
if CacheLoader throws an exception
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.UnregisterRegex(System.String)">
            <summary>
Unregister interest for the keys of the region that match the
given regular expression to stop getting updates for them.
The regular expression must have been registered previously using
a <c>RegisterRegex</c> call.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <exception cref="!:IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="!:IllegalStateException">
If this regular expression has not been registered by a previous
call to <c>RegisterRegex</c>.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterRegex(System.String,System.Boolean,System.Collections.Generic.ICollection`1{`0},System.Boolean,System.Boolean)">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="regex">the regular expression to register</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then the keys that match the regular expression
on the server are returned
</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <param name="receiveValues">
whether to act like notify-by-subscription is true
</param>
            <exception cref="!:IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterRegex(System.String,System.Boolean,System.Collections.Generic.ICollection`1{`0},System.Boolean)">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="regex">the regular expression to register</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then the keys that match the regular expression
on the server are returned
</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <exception cref="!:IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterRegex(System.String,System.Boolean,System.Collections.Generic.ICollection`1{`0})">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="regex">the regular expression to register</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then the keys that match the regular expression
on the server are returned
</param>
            <exception cref="!:IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterRegex(System.String,System.Boolean)">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="regex">the regular expression to register</param>
            <param name="isDurable">whether the registration should be durable</param>
            <exception cref="!:IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterRegex(System.String)">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <exception cref="!:IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.UnregisterAllKeys">
            <summary>
Unregister interest for all the keys of the region to stop
getting updates for them.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <exception cref="!:IllegalStateException">
If not previously registered all keys.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.GetInterestListRegex">
            <summary>
get the list of interest regular expressions on this client
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.GetInterestList">
            <summary>
get the interest list on this client
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterAllKeys(System.Boolean,System.Collections.Generic.ICollection`1{`0},System.Boolean,System.Boolean)">
            <summary>
Register interest for all the keys of the region to get
updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then all keys on the server are returned
</param>
            <param name="getInitialValues">
true to populate the cache with values of all the keys
from the server
</param>
            <param name="receiveValues">
whether to act like notify-by-subscription is true
</param>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterAllKeys(System.Boolean,System.Collections.Generic.ICollection`1{`0},System.Boolean)">
            <summary>
Register interest for all the keys of the region to get
updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then all keys on the server are returned
</param>
            <param name="getInitialValues">
true to populate the cache with values of all the keys
from the server
</param>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterAllKeys(System.Boolean)">
            <summary>
Register interest for all the keys of the region to get
updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="isDurable">whether the registration should be durable</param>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterAllKeys">
            <summary>
Register interest for all the keys of the region to get
updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.UnregisterKeys(System.Collections.Generic.ICollection`1{`0})">
            <summary>
Unregisters a collection of keys to stop getting updates for them.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <param name="keys">the collection of keys</param>
            <exception cref="!:IllegalArgumentException">
If the collection of keys is empty.
</exception>
            <exception cref="!:IllegalStateException">
If no keys were previously registered.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterKeys(System.Collections.Generic.ICollection`1{`0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Registers a collection of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="keys">a collection of keys</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <param name="receiveValues">
whether to act like notify-by-subscription is true
</param>
            <exception cref="!:IllegalArgumentException">
If the collection of keys is empty.
</exception>
            <exception cref="!:IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterKeys(System.Collections.Generic.ICollection`1{`0},System.Boolean,System.Boolean)">
            <summary>
Registers a collection of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="keys">a collection of keys</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <exception cref="!:IllegalArgumentException">
If the collection of keys is empty.
</exception>
            <exception cref="!:IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Generic.ISubscriptionService`1.RegisterKeys(System.Collections.Generic.ICollection`1{`0})">
            <summary>
Registers a collection of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <param name="keys">a collection of keys</param>
            <exception cref="!:IllegalArgumentException">
If the collection of keys is empty.
</exception>
            <exception cref="!:IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="!:CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="!:NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="!:RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="!:UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:System.TimeoutException">
if the operation timed out
</exception>
            <exception cref="!:UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.IFixedPartitionResolver.GetPartitionName(GemStone.GemFire.Cache.EntryEvent,GemStone.GemFire.Cache.CacheableHashSet)">
            <summary>
This method is used to get the name of the partition for the given entry
operation.
</summary>
            <param name="opDetails"> 
the details of the entry event e.g. {@link Region#get(Object)}
</param>
            <param name="targetPartitions">
represents all the available primary partitions on the nodes
</param>
            <return> partition-name associated with node which allows mapping of given
data to user defined partition
</return>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableLinkedHashSet">
            <summary>
A mutable <c>ICacheableKey</c> hash set wrapper that can serve as
a distributable object for caching. This is provided for compability
with java side though is functionally identical to
<c>CacheableHashSet</c> i.e. does not provide the linked semantics of
java <c>LinkedHashSet</c>.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableHashSet">
            <summary>
A mutable <c>ICacheableKey</c> hash set wrapper that can serve as
a distributable object for caching.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.#ctor(gemfire.Serializable*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Create(gemfire.Serializable*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.CreateDeserializable(gemfire.Serializable*)">
            <summary>
Factory function to register wrapper
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.CreateFromVoidPtr(System.Void*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="ptr">The native IntPtr pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Properties.NativeIntPtr">
            <summary>
Get the underlying native unmanaged pointer.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Properties.ClassId">
            <summary>
Returns the classId of this class for serialization.
</summary>
            <returns>classId of the Properties class</returns>
            <seealso cref="P:GemStone.GemFire.Cache.IGFSerializable.ClassId" />
        </member>
        <member name="P:GemStone.GemFire.Cache.Properties.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserializes this Properties object.
</summary>
            <param name="input">
the DataInput stream to use for reading data
</param>
            <returns>the deserialized Properties object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this Properties object.
</summary>
            <param name="output">
the DataOutput stream to use for serialization
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.ToString">
            <summary>
Returns a string representation of the current
<c>Properties</c> object.
</summary>
            <returns>
A comma separated list of property name,value pairs.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Load(System.String)">
            <summary>
Reads property values from a file, overriding what is currently
in the properties object. 
</summary>
            <param name="fileName">the name of the file</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.AddAll(GemStone.GemFire.Cache.Properties)">
            <summary>
Adds the contents of <c>other</c> to this instance, replacing
any existing values with those from other.
</summary>
            <param name="other">new set of properties</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.Properties.Size">
            <summary>
Return the number of entries in the collection.
</summary>
            <returns>the number of entries</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.ForEach(GemStone.GemFire.Cache.PropertyVisitor)">
            <summary>
Execute the Visitor delegate for each entry in the collection.
</summary>
            <param name="visitor">visitor delegate</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Remove(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
Remove the given <c>CacheableKey</c> from the collection. 
</summary>
            <param name="key">the key to remove</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Remove(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Remove the given <c>ICacheableKey</c> from the collection. 
</summary>
            <param name="key">the key to remove</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Remove(System.String)">
            <summary>
Remove the key from the collection. 
</summary>
            <param name="key">the key to remove</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Insert(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Add or update <c>Serializable</c> value for <c>CacheableKey</c>.
</summary>
            <param name="key">the key to insert</param>
            <param name="value">the <c>Serializable</c> value to insert</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Insert(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Add or update <c>Serializable</c> value for <c>ICacheableKey</c>.
</summary>
            <param name="key">the key to insert</param>
            <param name="value">the <c>Serializable</c> value to insert</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Insert(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Add or update <c>IGFSerializable</c> value for <c>CacheableKey</c>.
</summary>
            <param name="key">the key to insert</param>
            <param name="value">the <c>IGFSerializable</c> value to insert</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Insert(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Add or update <c>IGFSerializable</c> value for <c>ICacheableKey</c>.
</summary>
            <param name="key">the key to insert</param>
            <param name="value">the <c>IGFSerializable</c> value to insert</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Insert(System.String,System.Int32)">
            <summary>
Add or update the int value for key.
</summary>
            <param name="key">the key to insert</param>
            <param name="value">the integer value to insert</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Insert(System.String,System.String)">
            <summary>
Add or update the string value for key.
</summary>
            <param name="key">the key to insert</param>
            <param name="value">the string value to insert</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Find(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
Return the value for the given <c>CacheableKey</c>,
or NULL if not found. 
</summary>
            <param name="key">the key to find</param>
            <returns>the serializable value for the key</returns>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Find(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Return the value for the given <c>ICacheableKey</c>,
or NULL if not found. 
</summary>
            <param name="key">the key to find</param>
            <returns>the serializable value for the key</returns>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Find(System.String)">
            <summary>
Return the value for the given key, or NULL if not found. 
</summary>
            <param name="key">the key to find</param>
            <returns>the value for the key</returns>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if the key is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.Create">
            <summary>
Factory method to create an empty collection of properties.
</summary>
            <returns>empty collection of properties</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Properties.#ctor">
            <summary>
Default constructor: returns an empty collection.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.Properties">
            <summary>
Provides a collection of properties, each of which is a key/value
pair. Each key is a string, and the value may be a string
or an integer.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.PropertyVisitor">
            <summary>
Delegate that represents visitor for the <c>Properties</c> class.
</summary>
            <remarks>
This delegate is passed to the <c>Properties.ForEach</c> function
that invokes this delegate for each property having a key
and a value.
</remarks>
            <param name="key">The key of the property.</param>
            <param name="value">The value of the property.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionAttributes.#ctor(gemfire.RegionAttributes*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionAttributes.Create(gemfire.RegionAttributes*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.ClassId">
            <summary>
Returns the classId of this class for serialization.
</summary>
            <returns>classId of the Properties class</returns>
            <seealso cref="P:GemStone.GemFire.Cache.IGFSerializable.ClassId" />
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionAttributes.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserializes this Properties object.
</summary>
            <param name="input">the DataInput stream to use for reading data</param>
            <returns>the deserialized Properties object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionAttributes.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this Properties object.
</summary>
            <param name="output">the DataOutput stream to use for serialization</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.PersistenceProperties">
            <summary>
Returns the properties set for persistence.
</summary>
            <returns>properties for the PersistenceManager</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.PersistenceFactory">
            <summary>
Returns the symbol name of the factory function from which
the persistence manager will be created on a cache server.
</summary>
            <returns>the PersistenceManager factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.PersistenceLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the PersistenceManager library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CloningEnabled">
            <summary>
True if cloning is enabled for in case of delta.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.ClientNotificationEnabled">
            <summary>
True if client notification is enabled.
</summary>
            <returns>true if enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.PoolName">
            <summary>
This method returns the name of the attached pool.
</summary>
            <returns>pool name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.Endpoints">
            <summary>
This method returns the list of endpoints (servername:portnumber) separated by commas.
</summary>
            <returns>list of endpoints</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionAttributes.ValidateSerializableAttributes">
            <summary>
Throws IllegalStateException if the attributes are not suited for serialization
such as those that have a cache callback (listener, loader, or writer) set
directly instead of providing the library path and factory function.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">if the attributes cannot be serialized</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionAttributes.Equals(System.Object)">
            <summary>
True if all the attributes are equal to those of <c>other</c>.
</summary>
            <param name="other">attribute object to compare</param>
            <returns>true if equal</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionAttributes.Equals(GemStone.GemFire.Cache.RegionAttributes)">
            <summary>
True if all the attributes are equal to those of <c>other</c>.
</summary>
            <param name="other">attribute object to compare</param>
            <returns>true if equal</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheWriterFactory">
            <summary>
Returns the symbol name of the factory function from which
the loader will be created on a cache server.
</summary>
            <returns>the CacheWriter factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheWriterLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the CacheWriter library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.PartitionResolverFactory">
            <summary>
Returns the symbol name of the factory function from which
the loader will be created on a cache server.
</summary>
            <returns>the PartitionResolver factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheListenerFactory">
            <summary>
Returns the symbol name of the factory function from which
the loader will be created on a cache server.
</summary>
            <returns>the CacheListener factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.PartitionResolverLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the PartitionResolver library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheListenerLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the CacheListener library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheLoaderFactory">
            <summary>
Rreturns the symbol name of the factory function from which
the loader will be created on a cache server.
</summary>
            <returns>the CacheLoader factory function name</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheLoaderLibrary">
            <summary>
Returns the path of the library from which
the factory function will be invoked on a cache server.
</summary>
            <returns>the CacheLoader library path</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.LruEvictionAction">
            <summary>
Returns the ExpirationAction used for LRU Eviction, default is LOCAL_DESTROY.
</summary>
            <returns>the LRU eviction action</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.DiskPolicy">
            <summary>
Returns the disk policy type of the region.
</summary>
            <returns>the disk policy type, default is null</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.LruEntriesLimit">
            <summary>
Returns the maximum number of entries this cache will hold before
using LRU eviction. 
</summary>
            <returns>the maximum LRU size, or 0 for no limit</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.ConcurrencyLevel">
            <summary>
Returns the concurrency level of the entry's local cache.
</summary>
            <returns>the concurrency level</returns>
            <seealso cref="T:GemStone.GemFire.Cache.AttributesFactory" />
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.LoadFactor">
            <summary>
Returns the load factor of the entry's local cache.
</summary>
            <returns>the load factor</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.InitialCapacity">
            <summary>
Returns the initial capacity of the entry's local cache.
</summary>
            <returns>the initial capacity</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CachingEnabled">
            <summary>
If true, this region will store data in the current process.
</summary>
            <returns>true if caching is enabled</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.Scope">
            <summary>
Returns the scope of the region.
</summary>
            <returns>the region's scope</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.EntryIdleTimeoutAction">
            <summary>
Gets the <c>idleTimeout</c> expiration action for entries in this region.
</summary>
            <returns>the idleTimeout action for entries in this region</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.EntryIdleTimeout">
            <summary>
Gets the <c>idleTimeout</c> value for entries in this region.
</summary>
            <returns>the idleTimeout duration for entries in this region, in seconds</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.EntryTimeToLiveAction">
            <summary>
Gets the <c>timeToLive</c> expiration action for entries in this region.
</summary>
            <returns>the timeToLive action for entries in this region</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.EntryTimeToLive">
            <summary>
Gets the <c>timeToLive</c> value for entries in this region.
</summary>
            <returns>the timeToLive duration for entries in this region, in seconds</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.RegionIdleTimeoutAction">
            <summary>
Gets the <c>idleTimeout</c> expiration action for the region as a whole.
</summary>
            <returns>the idleTimeout action for this region</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.RegionIdleTimeout">
            <summary>
Gets the <c>idleTimeout</c> value for the region as a whole.
</summary>
            <returns>the IdleTimeout duration for this region, in seconds</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.RegionTimeToLiveAction">
            <summary>
Gets the <c>timeToLive</c> expiration action for the region as a whole.
</summary>
            <returns>the timeToLive action for this region</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.RegionTimeToLive">
            <summary>
Gets the <c>timeToLive</c> value for the region as a whole.
</summary>
            <returns>the timeToLive duration for this region, in seconds</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.PartitionResolver">
            <summary>
Gets the partition resolver for the region.
</summary>
            <returns>
region's <c>IPartitionResolver</c> or null if none
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener">
            <summary>
Gets the cache listener for the region.
</summary>
            <returns>
region's <c>ICacheListener</c> or null if none
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheWriter">
            <summary>
Gets the cache writer for the region.
</summary>
            <returns>
region's <c>ICacheWriter</c> or null if none
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionAttributes.CacheLoader">
            <summary>
Gets the cache loader for the region.
</summary>
            <returns>
region's <c>ICacheLoader</c> or null if none
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.RegionAttributes">
            <summary>
Defines attributes for configuring a region.
</summary>
            <remarks>
These are
<c>ICacheListener</c>, <c>ICacheLoader</c>, <c>ICacheWriter</c>,
scope, mirroring, and expiration attributes
for the region itself; expiration attributes for the region entries;
and whether statistics are enabled for the region and its entries.

To create an instance of this interface, use
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.CreateRegionAttributes" />.

For compatibility rules and default values, see <see cref="T:GemStone.GemFire.Cache.AttributesFactory" />.
<para>
Note that the <c>RegionAttributes</c> are not distributed with the region.
</para></remarks>
            <seealso cref="T:GemStone.GemFire.Cache.AttributesFactory" />
            <seealso cref="T:GemStone.GemFire.Cache.AttributesMutator" />
            <seealso cref="P:GemStone.GemFire.Cache.Region.Attributes" />
        </member>
        <member name="F:gemfire.ManagedFixedPartitionResolver.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IFixedPartitionResolver
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolver.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolver.getName">
            <summary>
Returns the name of the FixedPartitionResolver.
</summary>
            <remarks>
                <para>
This function does not throw any exception.
</para>
                <returns>
the name of the FixedPartitionResolver
</returns>
            </remarks>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolver.getRoutingObject(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return object associated with entry event which allows the Partitioned Region to store associated data together.
</summary>
            <remarks>
throws RuntimeException - any exception thrown will terminate the operation and the exception will be passed to the
calling thread.
</remarks>
            <param name="key">
key the detail of the entry event.
</param>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolver.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedFixedPartitionResolver.#ctor(GemStone.GemFire.Cache.IFixedPartitionResolver)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedFixedPartitionResolver">
            <summary>
Wraps the managed <see cref="!:GemStone.GemFire.Cache.IFixedPartitionResolver" />
object and implements the native <c>gemfire::FixedPartitionResolver</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedPartitionResolver.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IPartitionResolver
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedPartitionResolver.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedPartitionResolver.getName">
            <summary>
Returns the name of the PartitionResolver.
</summary>
            <remarks>
                <para>
This function does not throw any exception.
</para>
                <returns>
the name of the PartitionResolver
</returns>
            </remarks>
        </member>
        <member name="M:gemfire.ManagedPartitionResolver.getRoutingObject(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return object associated with entry event which allows the Partitioned Region to store associated data together.
</summary>
            <remarks>
throws RuntimeException - any exception thrown will terminate the operation and the exception will be passed to the
calling thread.
</remarks>
            <param name="key">
key the detail of the entry event.
</param>
        </member>
        <member name="M:gemfire.ManagedPartitionResolver.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedPartitionResolver.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedPartitionResolver</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>IPartitionResolver</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>IPartitionResolver</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedPartitionResolver.#ctor(GemStone.GemFire.Cache.IPartitionResolver)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedPartitionResolver">
            <summary>
Wraps the managed <see cref="!:GemStone.GemFire.Cache.IPartitionResolver" />
object and implements the native <c>gemfire::PartitionResolver</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheListener.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheListener
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheListener.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheListener.close(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources,
such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListener.afterRegionLive(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a region being live.
</summary>
            <remarks>
Each subregion gets its own <c>afterRegionLive</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region going live.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.ReadyForEvents" />
        </member>
        <member name="M:gemfire.ManagedCacheListener.afterRegionDestroy(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a region being destroyed.
</summary>
            <remarks>
Events are not invoked for each individual entry that is destroyed
as a result of the region being destroyed. Each subregion, however,
gets its own <c>afterRegionDestroyed</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region destruction.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListener.afterRegionInvalidate(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a region being invalidated.
</summary>
            <remarks>
Events are not invoked for each individual value that is invalidated
as a result of the region being invalidated. Each subregion, however,
gets its own <c>regionInvalidated</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region invalidation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListener.afterRegionClear(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a region being cleared.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheListener.afterDestroy(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of an entry being destroyed.
</summary>
            <param name="ev">
EntryEvent denotes the event object associated with the entry destruction.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListener.afterInvalidate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of an entry's value being invalidated.
</summary>
            <param name="ev">
EntryEvent denotes the event object associated with the entry invalidation.
</param>
        </member>
        <member name="M:gemfire.ManagedCacheListener.afterUpdate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListener.afterCreate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <param name="ev">
Denotes the event object associated with the entry creation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheListener.Dispose">
            <summary>
Destructor -- does nothing.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheListener.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedCacheListener</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheListener</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>ICacheListener</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedCacheListener.#ctor(GemStone.GemFire.Cache.ICacheListener)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheListener">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.ICacheListener" />
object and implements the native <c>gemfire::CacheListener</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheWriter.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheWriter
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheWriter.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheWriter.close(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external
resources, such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriter.beforeRegionDestroy(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
called before this region is destroyed
</summary>
            <param name="ev">
RegionEvent denotes the event object associated with destroying the region
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriter.beforeRegionClear(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
called before this region is cleared
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheWriter.beforeDestroy(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called before an entry is destroyed.
</summary>
            <remarks>
The entry being destroyed may or may
not exist in the local cache where the CacheWriter is installed. This method
is <em>not</em> called as a result of expiration or
<see cref="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with destroying the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriter.beforeCreate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called before an entry is created. Entry creation is initiated by a
<c>create</c>, a <c>put</c>, or a <c>get</c>.
</summary>
            <remarks>
The <c>CacheWriter</c> can determine whether this value comes from a
<c>get</c> or not from <c>load</c>. The entry being created may already
exist in the local cache where this <c>CacheWriter</c> is installed,
but it does not yet exist in the cache where the operation was initiated.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with creating the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriter.beforeUpdate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called before an entry is updated. The entry update is initiated by a
<c>put</c> or a <c>get</c> that causes the loader to update an existing entry.
</summary>
            <remarks>
The entry previously existed in the cache where the operation was
initiated, although the old value may have been null. The entry being
updated may or may not exist in the local cache where the CacheWriter is
installed.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheWriter.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedCacheWriter</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheWriter</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>ICacheWriter</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedCacheWriter.#ctor(GemStone.GemFire.Cache.ICacheWriter)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheWriter">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.ICacheWriter" />
object and implements the native <c>gemfire::CacheWriter</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheLoader.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the ICacheLoader
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheLoader.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheLoader.close(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external
resources, such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <param name="region">the region pointer</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheLoader.load(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Loads a value. Application writers should implement this
method to customize the loading of a value.
</summary>
            <remarks>
This method is called by the caching service when the requested
value is not in the cache. Any exception thrown by this method
is propagated back to and thrown by the invocation of
<see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" /> that triggered this load.
</remarks>
            <param name="region">a Region Pointer for which this is called.</param>
            <param name="key">the key for the cacheable</param>
            <param name="aCallbackArgument">any related user data, or null</param>
            <returns>
the value supplied for this key, or null if no value can be
supplied. 
If every available loader returns
a null value, <see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
will return null.
</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:gemfire.ManagedCacheLoader.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Static function to create a <c>ManagedCacheLoader</c> using given
managed assembly path and given factory function.
</summary>
            <param name="assemblyPath">
The path of the managed assembly that contains the <c>ICacheLoader</c>
factory function.
</param>
            <param name="factoryFunctionName">
The name of the factory function of the managed class for creating
an object that implements <c>ICacheLoader</c>.
This should be a static function of the format
{Namespace}.{Class Name}.{Method Name}.
</param>
            <exception cref="T:gemfire.IllegalArgumentException">
If the managed library cannot be loaded or the factory function fails.
</exception>
        </member>
        <member name="M:gemfire.ManagedCacheLoader.#ctor(GemStone.GemFire.Cache.ICacheLoader)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheLoader">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.ICacheLoader" />
object and implements the native <c>gemfire::CacheLoader</c> interface.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.CreateRegionAttributes">
            <summary>
Creates a <c>RegionAttributes</c> with the current settings.
</summary>
            <returns>the newly created <c>RegionAttributes</c></returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the current settings violate the <a href="compability.html">
compatibility</a> rules.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetCloningEnabled(System.Boolean)">
            <summary>
Set cloning enabled flag for this region.
</summary>
            <remarks>
                <para>
If set to false, then there is no cloning will take place in case of delta.
Delta will be applied on the old value which will change old value in-place.
</para>
                <para>
The default if not set is 'false'
of <c>ScopeType.Local</c> scope. 
</para>
            </remarks>
            <param name="cloningEnabled">
if true, clone old value before applying delta so that in-place change would not occour..
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetCachingEnabled(System.Boolean)">
            <summary>
Set caching enabled flag for this region.
</summary>
            <remarks>
                <para>
If set to false, then no data is stored in the local process,
but events and distributions will still occur, and the region
can still be used to put and remove, etc...
</para>
                <para>
The default if not set is 'true', 'false' is illegal for regions
of <c>ScopeType.Local</c> scope. 
</para>
            </remarks>
            <param name="cachingEnabled">
if true, cache data for this region in this process.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetDiskPolicy(GemStone.GemFire.Cache.DiskPolicyType)">
            <summary>
Sets the disk policy type for the next <c>RegionAttributes</c> created.
</summary>
            <param name="diskPolicy">
the disk policy to use for the region
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetLruEntriesLimit(System.UInt32)">
            <summary>
Sets a limit on the number of entries that will be held in the cache.
If a new entry is added while at the limit, the cache will evict the
least recently used entry.
</summary>
            <param name="entriesLimit">
The limit of the number of entries before eviction starts.
Defaults to 0, meaning no LRU actions will used.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetConcurrencyLevel(System.Int32)">
            <summary>
Sets the concurrency level of the next <c>RegionAttributes</c>
created. This value is used in initializing the map that holds the entries.
</summary>
            <param name="concurrencyLevel">
the concurrency level of the entry map
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if concurrencyLevel is nonpositive
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetLoadFactor(System.Single)">
            <summary>
Sets the entry load factor for the next <c>RegionAttributes</c>
created. This value is
used in initializing the map that holds the entries.
</summary>
            <param name="loadFactor">the load factor of the entry map</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if loadFactor is nonpositive
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetInitialCapacity(System.Int32)">
            <summary>
Sets the entry initial capacity for the <c>RegionAttributes</c>
being created. This value is used in initializing the map that
holds the entries.
</summary>
            <param name="initialCapacity">the initial capacity of the entry map</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if initialCapacity is nonpositive
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetPoolName(System.String)">
            <summary>
Set the pool name for a Thin Client region.
</summary>
            <remarks>
The pool with the name specified must be already created.
</remarks>
            <param name="poolName">
The name of the pool to attach to this region.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetEndpoints(System.String)">
            <summary>
Set the endpoints for a Thin Client region.
</summary>
            <remarks>
If the endpoints are set then the region is taken to be a Thin-client
region that interacts with the GemFire Java cacheserver.
</remarks>
            <param name="endpoints">
The list of host:port pairs separated by commas.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)">
            <summary>
Enables/disables client noficiations for a Thin client region.
</summary>
            <param name="clientNotificationEnabled">
true if client notifications have to be enabled; false otherwise
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetScope(GemStone.GemFire.Cache.ScopeType)">
            <summary>
Sets the scope for the next <c>RegionAttributes</c> created.
</summary>
            <param name="scopeType">
the type of scope to use for the region
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetPersistenceManager(System.String,System.String,GemStone.GemFire.Cache.Properties)">
            <summary>
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
This must be used to set the PersistenceManager.
</summary>
            <param name="libPath">The path of the PersistenceManager shared library.</param>
            <param name="factoryFunctionName">
The name of the factory function to create an instance of PersistenceManager object.
</param>
            <param name="config">
The configuration properties to use for the PersistenceManager.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetPersistenceManager(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
This must be used to set the PersistenceManager.
</summary>
            <param name="libPath">The path of the PersistenceManager shared library.</param>
            <param name="factoryFunctionName">
The name of the factory function to create an instance of PersistenceManager object.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetRegionTimeToLive(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)">
            <summary>
Sets the timeToLive expiration attributes for the region itself for the
next <c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="timeToLive">
the timeToLive in seconds for the region as a whole.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetRegionIdleTimeout(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)">
            <summary>
Sets the idleTimeout expiration attributes for the region itself for the
next <c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="idleTimeout">
the idleTimeout in seconds for the region as a whole.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetEntryTimeToLive(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)">
            <summary>
Sets the timeToLive expiration attributes for region entries for the next
<c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="timeToLive">
the timeToLive in seconds for entries in this region.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetEntryIdleTimeout(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)">
            <summary>
Sets the idleTimeout expiration attributes for region entries for the next
<c>RegionAttributes</c> created.
</summary>
            <param name="action">
The expiration action for which to set the timeout.
</param>
            <param name="idleTimeout">
the idleTimeout in seconds for entries in this region.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetPartitionResolver(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the partition resolver of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>PartitionResolver</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>IPartitionResolver</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the listener of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheListener</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheListener</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheWriter(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the writer of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheWriter</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheWriter</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheLoader(System.String,System.String)">
            <summary>
Sets the library path for the library that will be invoked for the loader of the region.
</summary>
            <param name="libPath">
library pathname containing the factory function.
</param>
            <param name="factoryFunctionName">
Name of factory function that creates a <c>CacheLoader</c>
for a native library, or the name of the method in the form
{Namespace}.{Class Name}.{Method Name} that creates an
<c>ICacheLoader</c> for a managed library.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetPartitionResolver(GemStone.GemFire.Cache.IPartitionResolver)">
            <summary>
Sets the PartitionResolver for the <c>RegionAttributes</c> being created.
</summary>
            <param name="partitionresolver">
user-defined partition resolver, or null for no partition resolver
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)">
            <summary>
Sets the CacheListener for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheListener">
user-defined cache listener, or null for no cache listener
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheWriter(GemStone.GemFire.Cache.ICacheWriter)">
            <summary>
Sets the cache writer for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheWriter">
user-defined cache writer, or null for no cache writer
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheLoader(GemStone.GemFire.Cache.ICacheLoader)">
            <summary>
Sets the cache loader for the <c>RegionAttributes</c> being created.
</summary>
            <param name="cacheLoader">
a user-defined cache loader, or null for no cache loader
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.#ctor(GemStone.GemFire.Cache.RegionAttributes)">
            <summary>
Creates a new instance of <c>AttributesFactory</c> ready to create
a <c>RegionAttributes</c> with the same settings as those in the
specified <c>RegionAttributes</c>.
</summary>
            <param name="regionAttributes">
attributes used to initialize this AttributesFactory
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.AttributesFactory.#ctor">
            <summary>
Creates a new <c>AttributesFactory</c> ready to create
a <c>RegionAttributes</c> with default settings.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.AttributesFactory">
            <summary>
Factory class to create instances of <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />.
</summary>
            <remarks>
An <see cref="T:GemStone.GemFire.Cache.AttributesFactory" />
instance maintains state for creating <see cref="T:GemStone.GemFire.Cache.RegionAttributes" /> instances.
The setter methods are used to change the settings that will be used for
creating the next attributes instance with the <see cref="M:GemStone.GemFire.Cache.AttributesFactory.CreateRegionAttributes" />
method. If you create a factory with the default constructor, then the
factory is set up to create attributes with all default settings. You can
also create a factory by providing a preset <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />.
<para>
Once a <see cref="T:GemStone.GemFire.Cache.RegionAttributes" /> is created, it can only be modified
after it has been used to create a <see cref="T:GemStone.GemFire.Cache.Region" />, and then only by
using an <see cref="T:GemStone.GemFire.Cache.AttributesMutator" /> obtained from the region.
</para><para><h3>Attributes</h3><h4>Callbacks</h4><dl><dt><see cref="T:GemStone.GemFire.Cache.ICacheLoader" /> [<em>default:</em> null]</dt><dd>User-implemented plug-in for loading data on cache misses.<br />
       see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheLoader(GemStone.GemFire.Cache.ICacheLoader)" />,
           <see cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheLoader" /></dd><dt><see cref="T:GemStone.GemFire.Cache.ICacheWriter" /> [<em>default:</em> null]</dt><dd>User-implemented plug-in for intercepting cache modifications, e.g.
        for writing to an external data source.<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheWriter(GemStone.GemFire.Cache.ICacheWriter)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheWriter" /></dd><dt><see cref="T:GemStone.GemFire.Cache.ICacheListener" /> [<em>default:</em> null]</dt><dd>User-implemented plug-in for receiving and handling cache-related events.<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener" /></dd><dt><see cref="T:GemStone.GemFire.Cache.IPartitionResolver" /> [<em>default:</em> null]</dt><dd>User-implemented plug-in for custom partitioning.<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetPartitionResolver(GemStone.GemFire.Cache.IPartitionResolver)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.PartitionResolver" /></dd></dl><h4>Expiration</h4><dl><dt>RegionTimeToLive [<em>default:</em> no expiration]</dt><dd>Expiration configuration for the entire region based on the
    lastModifiedTime ( <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> ).<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetRegionTimeToLive(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.RegionTimeToLive" />,
            <see cref="M:GemStone.GemFire.Cache.AttributesMutator.SetRegionTimeToLive(System.Int32)" /></dd><dt>RegionIdleTimeout [<em>default:</em> no expiration]</dt><dd>Expiration configuration for the entire region based on the
        lastAccessedTime ( <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> ).<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetRegionIdleTimeout(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.RegionIdleTimeout" />,
            <see cref="M:GemStone.GemFire.Cache.AttributesMutator.SetRegionIdleTimeout(System.Int32)" /></dd><dt>EntryTimeToLive [<em>default:</em> no expiration]</dt><dd>Expiration configuration for individual entries based on the
    lastModifiedTime ( <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> ).<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetEntryTimeToLive(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.EntryTimeToLive" />,
            <see cref="M:GemStone.GemFire.Cache.AttributesMutator.SetEntryTimeToLive(System.Int32)" /></dd><dt>EntryIdleTimeout [<em>default:</em> no expiration]</dt><dd>Expiration configuration for individual entries based on the
        lastAccessedTime ( <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> ).<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetEntryIdleTimeout(GemStone.GemFire.Cache.ExpirationAction,System.UInt32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.EntryIdleTimeout" />,
            <see cref="M:GemStone.GemFire.Cache.AttributesMutator.SetEntryIdleTimeout(System.Int32)" /></dd></dl><h4>Distribution</h4><dl><dt><see cref="T:GemStone.GemFire.Cache.ScopeType" /> [<em>default:</em><tt>ScopeType.DistributedNoAck</tt>]</dt><dd>The C++ cache can contain either local regions or distributed regions. 
        Distributed regions are configured with servers that they distribute 
        their operations to upto. Locally scoped regions do not have any 
        distribution behavior. GFE native client regions scoped as 
        ScopeType.DistributedNoAck and ScopeType.DistributedAck have identical
        distribution behavior.<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetScope(GemStone.GemFire.Cache.ScopeType)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.Scope" /></dd></dl><h4>Storage</h4><dl><dt>InitialCapacity [<em>default:</em><tt>16</tt>]</dt><dd>The initial capacity of the map used for storing the entries.<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetInitialCapacity(System.Int32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.InitialCapacity" /></dd><dt>LoadFactor [<em>default:</em><tt>0.75</tt>]</dt><dd>The load factor of the map used for storing the entries.<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetLoadFactor(System.Single)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.LoadFactor" /></dd><dt>ConcurrencyLevel [<em>default:</em><tt>16</tt>]</dt><dd>The allowed concurrency among updates to values in the region
        is guided by the <tt>concurrencyLevel</tt>, which is used as a hint
        for internal sizing. The actual concurrency will vary.
        Ideally, you should choose a value to accommodate as many
        threads as will ever concurrently modify values in the region. Using a
        significantly higher value than you need can waste space and time,
        and a significantly lower value can lead to thread contention. But
        overestimates and underestimates within an order of magnitude do
        not usually have much noticeable impact. A value of one is
        appropriate when it is known that only one thread will modify
        and all others will only read.<br />
        see <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetConcurrencyLevel(System.Int32)" />,
            <see cref="P:GemStone.GemFire.Cache.RegionAttributes.ConcurrencyLevel" /></dd></dl></para></remarks>
            <seealso cref="T:GemStone.GemFire.Cache.RegionAttributes" />
            <seealso cref="T:GemStone.GemFire.Cache.AttributesMutator" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.CreateSubRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.IPartitionResolver.GetRoutingObject(GemStone.GemFire.Cache.EntryEvent)">
            <summary>
return object associated with entry event which allows the Partitioned Region to store associated data together.
</summary>
            <remarks>
throws RuntimeException - any exception thrown will terminate the operation and the exception will be passed to the
calling thread.
</remarks>
            <param name="key">
key the detail of the entry event.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.IPartitionResolver.GetName">
            <summary>
Returns the name of the PartitionResolver.
</summary>
            <remarks>
                <para>
This function does not throw any exception.
</para>
                <returns>
the name of the PartitionResolver
</returns>
            </remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.Close(GemStone.GemFire.Cache.Region)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources,
such as database connections. Any runtime exceptions this method
throws will be logged.
</remarks>
            <param>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionLive(GemStone.GemFire.Cache.RegionEvent)">
            <summary>
Handles the event of a region going live.
</summary>
            <remarks>
Each subregion gets its own <c>AfterRegionLive</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region going live.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.ReadyForEvents" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDestroy(GemStone.GemFire.Cache.RegionEvent)">
            <summary>
Handles the event of a region being destroyed.
</summary>
            <remarks>
Events are not invoked for each individual entry that is destroyed
as a result of the region being destroyed. Each subregion, however,
gets its own <c>AfterRegionDestroyed</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region destruction.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionInvalidate(GemStone.GemFire.Cache.RegionEvent)">
            <summary>
Handles the event of a region being invalidated.
</summary>
            <remarks>
Events are not invoked for each individual value that is invalidated
as a result of the region being invalidated. Each subregion, however,
gets its own <c>RegionInvalidated</c> event invoked on its listener.
</remarks>
            <param name="ev">
RegionEvent denotes the event object associated with the region invalidation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionClear(GemStone.GemFire.Cache.RegionEvent)">
            <summary>
Handles the event of a region being cleared.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)">
            <summary>
Handles the event of an entry being destroyed.
</summary>
            <param name="ev">
EntryEvent denotes the event object associated with the entry destruction.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)">
            <summary>
Handles the event of an entry's value being invalidated.
</summary>
            <param name="ev">
EntryEvent denotes the event object associated with the entry invalidation.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.AfterUpdate(GemStone.GemFire.Cache.EntryEvent)">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <param name="ev">
EntryEvent denotes the event object associated with updating the entry.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheListener.AfterCreate(GemStone.GemFire.Cache.EntryEvent)">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <param name="ev">
Denotes the event object associated with the entry creation.
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.ICacheListener">
            <summary>
An application plug-in that can be installed on a region.
</summary>
            <remarks>
Listeners are change notifications that are invoked
AFTER the change has occured for region update operations on a client.
Listeners also receive notifications when entries in a region are modified.
Multiple events can cause concurrent invocation
of <c>ICacheListener</c> methods.  If event A occurs before event B,
there is no guarantee that their corresponding <c>ICacheListener</c>
method invocations will occur in the same order. Any exceptions thrown by
the listener are caught by GemFire and logged. If the exception is due to
listener invocation on the same thread where a region operation has been
performed, then a <c>CacheListenerException</c> is thrown back to
the application. If the exception is for a notification received from
server then that is logged and the notification thread moves on to
receiving other notifications.
<para>
A cache listener is defined in the <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />.
</para>

There are two cases in which listeners are invoked. The first is when a
region modification operation (e.g. put, create, destroy, invalidate)
is performed. For this case it is important to ensure that minimal work is
done in the listener before returning control back to Gemfire since the
operation will block till the listener has not completed. For example,
a listener implementation may choose to hand off the event to a thread pool
that then processes the event on its thread rather than the listener thread.
The second is when notifications are received from java server as a result
of region register interest calls (<c>Region.RegisterKeys</c> etc),
or invalidate notifications when notify-by-subscription is false on the
server. In this case the methods of <c>ICacheListener</c> are invoked
asynchronously (i.e. does not block the thread that receives notification
messages). Additionally for the latter case of notifications from server,
listener is always invoked whether or not local operation is successful
e.g. if a destroy notification is received and key does not exist in the
region, the listener will still be invoked. This is different from the
first case where listeners are invoked only when the region update
operation succeeds.
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheLoader" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheWriter" />
            <seealso cref="T:GemStone.GemFire.Cache.CacheListenerException" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheWriter.Close(GemStone.GemFire.Cache.Region)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
                <para>
Implementations should clean up any external
resources, such as database connections. Any runtime exceptions this method
throws will be logged.
</para>
                <para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para>
            </remarks>
            <param name="region">region to close</param>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheWriter.BeforeRegionDestroy(GemStone.GemFire.Cache.RegionEvent)">
            <summary>
Called before this region is destroyed.
</summary>
            <param name="ev">
event object associated with destroying the region
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheWriter.BeforeRegionClear(GemStone.GemFire.Cache.RegionEvent)">
            <summary>
Called before this region is cleared.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)">
            <summary>
Called before an entry is destroyed.
</summary>
            <remarks>
The entry being destroyed may or may
not exist in the local cache where the CacheWriter is installed. This method
is <em>not</em> called as a result of expiration or
<see cref="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />.
</remarks>
            <param name="ev">
event object associated with destroying the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheWriter.BeforeCreate(GemStone.GemFire.Cache.EntryEvent)">
            <summary>
Called before an entry is created. Entry creation is initiated by a
<c>Create</c>, a <c>Put</c>, or a <c>Get</c>.
</summary>
            <remarks>
The <c>CacheWriter</c> can determine whether this value comes from a
<c>Get</c> or not from <c>Load</c>. The entry being
created may already exist in the local cache where this <c>CacheWriter</c>
is installed, but it does not yet exist in the cache where the operation was initiated.
</remarks>
            <param name="ev">
event object associated with creating the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheWriter.BeforeUpdate(GemStone.GemFire.Cache.EntryEvent)">
            <summary>
Called before an entry is updated. The entry update is initiated by a
<c>Put</c> or a <c>Get</c> that causes the loader to update an existing entry.
</summary>
            <remarks>
The entry previously existed in the cache where the operation was
initiated, although the old value may have been null. The entry being
updated may or may not exist in the local cache where the CacheWriter is
installed.
</remarks>
            <param name="ev">
event object associated with updating the entry
</param>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.ICacheWriter">
            <summary>
An application plug-in that can be installed on a region.
Defines methods that are called <b>before</b> entry modification,
such as writing the value to a database.
</summary>
            <remarks>
                <para>
A distributed region will typically have a single cache writer.
If the application is designed such that all or most updates to
a region occur on a node, the cache writer for the region should
be installed at that node. 
</para>
                <para>
A cache writer is defined in the <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />.
</para>
                <para>
Cache writer invocations are initiated by the node where the entry or
region modification occurs. 
</para>
                <para>
Before a region is updated via a put, create, or destroy operation,
GemFire will call an <c>ICacheWriter</c> that is installed anywhere in any
participating cache for that region, preferring a local <c>ICacheWriter</c>
if there is one. Usually there will be only one <c>ICacheWriter</c> in
the distributed system. If there are multiple <c>ICacheWriter</c>s
available in the distributed system, the GemFire
implementation always prefers one that is stored locally, or else picks one
arbitrarily. In any case, only one <c>ICacheWriter</c> will be invoked.
</para>
                <para>
The typical use for a <c>ICacheWriter</c> is to update a database.
Application writers should implement these methods to execute
application-specific behavior before the cache is modified.
</para>
                <para>
Note that cache writer callbacks are synchronous callbacks and have the ability
to veto the cache update. Since cache writer invocations require communications
over the network, (especially if they are not co-located on the nodes where the
change occurs) the use of cache writers presents a performance penalty.
</para>
                <para>
The <c>ICacheWriter</c> is capable of aborting the update to the cache by throwing
a <c>CacheWriterException</c>. This exception or any runtime exception
thrown by the <c>ICacheWriter</c> will abort the operation, and the
exception will be propagated to the initiator of the operation, regardless
of whether the initiator is in the same process as the <c>ICacheWriter</c>.
</para>
            </remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheWriter(GemStone.GemFire.Cache.ICacheWriter)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheWriter" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheLoader" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheListener" />
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionEvent.#ctor(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionEvent.RemoteOrigin">
            <summary>
Returns true if the event originated in a remote process.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionEvent.CallbackArgument">
            <summary>
Returns the callbackArgument passed to the method that generated
this event. See the <see cref="P:GemStone.GemFire.Cache.RegionEvent.Region" /> interface methods
that take a callbackArgument parameter.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.RegionEvent.Region">
            <summary>
Return the region this event occurred in.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.RegionEvent.#ctor(GemStone.GemFire.Cache.Region,GemStone.GemFire.Cache.IGFSerializable,System.Boolean)">
            <summary>
Constructor to create a <c>RegionEvent</c> for a given region.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if region is null
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.RegionEvent">
            <summary>
This class encapsulates events that occur for a region.
</summary>
        </member>
        <member name="M:gemfire.RegionEvent.remoteOrigin">
If the event originated in a remote process, returns true. 
</member>
        <member name="M:gemfire.RegionEvent.getCallbackArgument">
Returns the callbackArgument passed to the method that generated
this event. See the {@link Region} interface methods that take
a callbackArgument parameter.

</member>
        <member name="M:gemfire.RegionEvent.getRegion">
Return the region this event occurred in. 
</member>
        <member name="M:gemfire.RegionEvent.Dispose">
Destructor. 
</member>
        <member name="M:gemfire.RegionEvent.#ctor(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Constructor, given the values. 
</member>
        <member name="M:gemfire.RegionEvent.#ctor">
Constructor. 
</member>
        <member name="T:gemfire.RegionEvent">
Declares region events.

</member>
        <member name="M:GemStone.GemFire.Cache.EntryEvent.#ctor(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.EntryEvent.RemoteOrigin">
            <summary>
If the event originated in a remote process, returns true.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.EntryEvent.CallbackArgument">
            <summary>
Returns the callbackArgument passed to the method that generated
this event. See the <see cref="P:GemStone.GemFire.Cache.EntryEvent.Region" /> interface methods
that take a callbackArgument parameter.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.EntryEvent.NewValue">
            <summary>
Return the updated value from this event. If the event is a destroy
or invalidate operation, then the new value will be NULL.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.EntryEvent.OldValue">
            <summary>
Returns 'null' if there was no value in the cache. If the prior state
 of the entry was invalid, or non-existent/destroyed, then the old
value will be 'null'.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.EntryEvent.Key">
            <summary>
Returns the key this event describes.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.EntryEvent.Region">
            <summary>
Return the region this event occurred in.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.EntryEvent.#ctor(GemStone.GemFire.Cache.Region,GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable,System.Boolean)">
            <summary>
Constructor to create an <c>EntryEvent</c> for the given region.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.EntryEvent">
            <summary>
This class encapsulates events that occur for an entry in a region.
</summary>
        </member>
        <member name="M:gemfire.EntryEvent.remoteOrigin">
If the event originated in a remote process, returns true. 
</member>
        <member name="M:gemfire.EntryEvent.getCallbackArgument">
Returns the callbackArgument passed to the method that generated
this event. See the {@link Region} interface methods that take
a callbackArgument parameter.

</member>
        <member name="M:gemfire.EntryEvent.getNewValue">
If the event is a destroy or invalidate operation, then the new value
   * will be NULLPTR.
   * @return the updated value from this event

</member>
        <member name="M:gemfire.EntryEvent.getOldValue">
If the prior state of the entry was invalid, or non-existent/destroyed,
   * then the old value will be NULLPTR.
   * @return the old value in the cache.

</member>
        <member name="M:gemfire.EntryEvent.getKey">
@return the key this event describes. 
</member>
        <member name="M:gemfire.EntryEvent.getRegion">
@return the region this event occurred in. 
</member>
        <member name="M:gemfire.EntryEvent.#ctor">
Constructor. 
</member>
        <member name="M:gemfire.EntryEvent.Dispose">
Destructor. 
</member>
        <member name="M:gemfire.EntryEvent.#ctor(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Constructor, given all values. 
</member>
        <member name="T:gemfire.EntryEvent">
Represents an entry event affecting an entry, including its identity and the the circumstances of the event. 
</member>
        <member name="M:GemStone.GemFire.Cache.Region.#ctor(gemfire.Region*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(gemfire.Region*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalRemove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Removes the value with the specified key in the local cache only.
Remove removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to remove</param>
            <param name="value"> the value of the key to remove</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalRemove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Removes the value with the specified key in the local cache only.
Remove removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to remove</param>
            <param name="value"> the value of the key to remove</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalRemove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Removes the value with the specified key in the local cache only.
Remove removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to remove</param>
            <param name="value"> the value of the key to remove</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalRemove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Removes the value with the specified key in the local cache only.
Remove removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to remove</param>
            <param name="value"> the value of the key to remove</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalRemove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Removes the value with the specified key in the local cache only.
Remove removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to remove</param>
            <param name="value"> the value of the key to remove</param>
            <param name="callbackArg">
a user-defined parameter to pass to cache listeners and writers triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalRemove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Removes the value with the specified key in the local cache only.
Remove removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to remove</param>
            <param name="value"> the value of the key to remove</param>
            <param name="callbackArg">
a user-defined parameter to pass to cache listeners and writers triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalRemove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Removes the value with the specified key in the local cache only.
Remove removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to remove</param>
            <param name="value"> the value of the key to remove</param>
            <param name="callbackArg">
a user-defined parameter to pass to cache listeners and writers triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalRemove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Removes the value with the specified key in the local cache only.
Remove removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to remove</param>
            <param name="value"> the value of the key to remove</param>
            <param name="callbackArg">
a user-defined parameter to pass to cache listeners and writers triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Removes the entry with the specified key and value, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Remove removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The Remove is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to Remove</param>
            <param name="value">the value of the entry to Remove</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Removes the entry with the specified key and value, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Remove removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The Remove is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to Remove</param>
            <param name="value">the value of the entry to Remove</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Removes the entry with the specified key and value, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Remove removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The Remove is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to Remove</param>
            <param name="value">the value of the entry to Remove</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Removes the entry with the specified key and value, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Remove removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The Remove is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to Remove</param>
            <param name="value">the value of the entry to Remove</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <returns>true if entry with key and its value are removed otherwise false.</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.SelectValue(System.String)">
            <summary>
Executes the query on the server based on the predicate
and returns a single result value.
Valid only for a Native Client region.
</summary>
            <param name="predicate">
The query predicate (just the WHERE clause)
or the entire query to execute
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the predicate is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If some error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
If some query error occurred at the server,
or more than one result items are available.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache has been closed
</exception>
            <returns>
The single ResultSet or StructSet item,
or NULL of no results are available.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.SelectValue(System.String,System.UInt32)">
            <summary>
Executes the query on the server based on the predicate
and returns a single result value.
Valid only for a Native Client region.
</summary>
            <param name="predicate">
The query predicate (just the WHERE clause)
or the entire query to execute
</param>
            <param name="timeout">
The time (in seconds) to wait for the query response
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the predicate is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If some error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
If some query error occurred at the server,
or more than one result items are available.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache has been closed
</exception>
            <returns>
The single ResultSet or StructSet item,
or NULL of no results are available.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.ExistsValue(System.String)">
            <summary>
Executes the query on the server based on the predicate
and returns whether any result exists.
Valid only for a Native Client region.
</summary>
            <param name="predicate">
The query predicate (just the WHERE clause)
or the entire query to execute
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the predicate is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If some error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
If some query error occurred at the server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache has been closed
</exception>
            <returns>
true if the result size is non-zero, false otherwise.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.ExistsValue(System.String,System.UInt32)">
            <summary>
Executes the query on the server based on the predicate
and returns whether any result exists.
Valid only for a  Native Client region.
</summary>
            <param name="predicate">
The query predicate (just the WHERE clause)
or the entire query to execute
</param>
            <param name="timeout">
The time (in seconds) to wait for the query response
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the predicate is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If some error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
If some query error occurred at the server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache has been closed
</exception>
            <returns>
true if the result size is non-zero, false otherwise.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Query(System.String)">
            <summary>
Executes the query on the server based on the predicate.
Valid only for a Native Client region.
</summary>
            <param name="predicate">The query predicate (just the WHERE clause) or the entire query to execute</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the predicate is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If some error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
If some query error occurred at the server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache has been closed
</exception>
            <returns>
The SelectResults which can either be a ResultSet or a StructSet.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Query(System.String,System.UInt32)">
            <summary>
Executes the query on the server based on the predicate.
Valid only for a Native Client region.
</summary>
            <param name="predicate">The query predicate (just the WHERE clause) or the entire query to execute</param>
            <param name="timeout">The time (in seconds) to wait for the query response, optional</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the predicate is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If some error occurred.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.QueryException">
If some query error occurred at the server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheClosedException">
if the cache has been closed
</exception>
            <returns>
The SelectResults which can either be a ResultSet or a StructSet.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetAll(GemStone.GemFire.Cache.CacheableKey[],System.Collections.Generic.Dictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^},System.Collections.Generic.Dictionary`2{GemStone.GemFire.Cache.ICacheableKey^,System.Exception^})">
            <summary>
Gets values for an array of keys from the local cache or server.
If value for a key is not present locally then it is requested from the
java server. The value returned is not copied, so multi-threaded
applications should not modify the value directly,
but should use the update methods.

Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" />
and <see cref="!:CacheStatistics.HitCount" /> and
<see cref="!:CacheStatistics.MissCount" /> for this region and the entry.
</summary>
            <param name="keys">the array of keys</param>
            <param name="values">
output parameter that provides the map of keys to
respective values; when this is NULL then an
<c>IllegalArgumentException</c> is thrown.
</param>
            <param name="exceptions">
output parameter that provides the map of keys
to any exceptions while obtaining the key; ignored if this is NULL
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is null or empty,
or <c>values</c> argument is null.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server while
processing the request.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if region is not connected to the cache because the client
cannot establish usable connections to any of the given servers
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if operation timed out.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">
For other exceptions.
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetAll(GemStone.GemFire.Cache.ICacheableKey[],System.Collections.Generic.Dictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^},System.Collections.Generic.Dictionary`2{GemStone.GemFire.Cache.ICacheableKey^,System.Exception^})">
            <summary>
Gets values for an array of keys from the local cache or server.
If value for a key is not present locally then it is requested from the
java server. The value returned is not copied, so multi-threaded
applications should not modify the value directly,
but should use the update methods.

Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" />
and <see cref="!:CacheStatistics.HitCount" /> and
<see cref="!:CacheStatistics.MissCount" /> for this region and the entry.
</summary>
            <param name="keys">the array of keys</param>
            <param name="values">
output parameter that provides the map of keys to
respective values; when this is NULL then an
<c>IllegalArgumentException</c> is thrown.
</param>
            <param name="exceptions">
output parameter that provides the map of keys
to any exceptions while obtaining the key; ignored if this is NULL
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is null or empty,
or <c>values</c> argument is null.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server while
processing the request.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if region is not connected to the cache because the client
cannot establish usable connections to any of the given servers
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if operation timed out.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">
For other exceptions.
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetAll(GemStone.GemFire.Cache.CacheableKey[],System.Collections.Generic.Dictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^},System.Collections.Generic.Dictionary`2{GemStone.GemFire.Cache.ICacheableKey^,System.Exception^},System.Boolean)">
            <summary>
Gets values for an array of keys from the local cache or server.
If value for a key is not present locally then it is requested from the
java server. The value returned is not copied, so multi-threaded
applications should not modify the value directly,
but should use the update methods.

Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" />
and <see cref="!:CacheStatistics.HitCount" /> and
<see cref="!:CacheStatistics.MissCount" /> for this region and the entry.
</summary>
            <param name="keys">the array of keys</param>
            <param name="values">
output parameter that provides the map of keys to
respective values; ignored if NULL; when this is NULL then at least
the <c>addToLocalCache</c> parameter should be true and caching
should be enabled for the region to get values into the region
otherwise an <c>IllegalArgumentException</c> is thrown.
</param>
            <param name="exceptions">
output parameter that provides the map of keys
to any exceptions while obtaining the key; ignored if this is NULL
</param>
            <param name="addToLocalCache">
true if the obtained values have also to be added to the local cache
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is null or empty. Other invalid case is when
the <c>values</c> parameter is NULL, and either
<c>addToLocalCache</c> is false or caching is disabled
for this region.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server while
processing the request.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if region is not connected to the cache because the client
cannot establish usable connections to any of the given servers
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if operation timed out.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">
For other exceptions.
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetAll(GemStone.GemFire.Cache.ICacheableKey[],System.Collections.Generic.Dictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^},System.Collections.Generic.Dictionary`2{GemStone.GemFire.Cache.ICacheableKey^,System.Exception^},System.Boolean)">
            <summary>
Gets values for an array of keys from the local cache or server.
If value for a key is not present locally then it is requested from the
java server. The value returned is not copied, so multi-threaded
applications should not modify the value directly,
but should use the update methods.

Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" />
and <see cref="!:CacheStatistics.HitCount" /> and
<see cref="!:CacheStatistics.MissCount" /> for this region and the entry.
</summary>
            <param name="keys">the array of keys</param>
            <param name="values">
output parameter that provides the map of keys to
respective values; ignored if NULL; when this is NULL then at least
the <c>addToLocalCache</c> parameter should be true and caching
should be enabled for the region to get values into the region
otherwise an <c>IllegalArgumentException</c> is thrown.
</param>
            <param name="exceptions">
output parameter that provides the map of keys
to any exceptions while obtaining the key; ignored if this is NULL
</param>
            <param name="addToLocalCache">
true if the obtained values have also to be added to the local cache
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is null or empty. Other invalid case is when
the <c>values</c> parameter is NULL, and either
<c>addToLocalCache</c> is false or caching is disabled
for this region.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server while
processing the request.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if region is not connected to the cache because the client
cannot establish usable connections to any of the given servers
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if operation timed out.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">
For other exceptions.
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.UnregisterRegex(System.String)">
            <summary>
Unregister interest for the keys of the region that match the
given regular expression to stop getting updates for them.
The regular expression must have been registered previously using
a <c>RegisterRegex</c> call.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If this regular expression has not been registered by a previous
call to <c>RegisterRegex</c>.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterRegex(System.String,System.Boolean,System.Collections.Generic.List`1{GemStone.GemFire.Cache.ICacheableKey^},System.Boolean,System.Boolean)">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="regex">the regular expression to register</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then the keys that match the regular expression
on the server are returned
</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <param name="receiveValues">
whether to act like notify-by-subscription is true
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterRegex(System.String,System.Boolean,System.Collections.Generic.List`1{GemStone.GemFire.Cache.ICacheableKey^},System.Boolean)">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="regex">the regular expression to register</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then the keys that match the regular expression
on the server are returned
</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterRegex(System.String,System.Boolean,System.Collections.Generic.List`1{GemStone.GemFire.Cache.ICacheableKey^})">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="regex">the regular expression to register</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then the keys that match the regular expression
on the server are returned
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterRegex(System.String,System.Boolean)">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="regex">the regular expression to register</param>
            <param name="isDurable">whether the registration should be durable</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterRegex(System.String)">
            <summary>
Register interest for the keys of the region that match the
given regular expression to get updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the regular expression string is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.UnregisterAllKeys">
            <summary>
Unregister interest for all the keys of the region to stop
getting updates for them.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If not previously registered all keys.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterAllKeys(System.Boolean,System.Collections.Generic.List`1{GemStone.GemFire.Cache.ICacheableKey^},System.Boolean,System.Boolean)">
            <summary>
Register interest for all the keys of the region to get
updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then all keys on the server are returned
</param>
            <param name="getInitialValues">
true to populate the cache with values of all the keys
from the server
</param>
            <param name="receiveValues">
whether to act like notify-by-subscription is true
</param>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterAllKeys(System.Boolean,System.Collections.Generic.List`1{GemStone.GemFire.Cache.ICacheableKey^},System.Boolean)">
            <summary>
Register interest for all the keys of the region to get
updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="resultKeys">
if non-null then all keys on the server are returned
</param>
            <param name="getInitialValues">
true to populate the cache with values of all the keys
from the server
</param>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterAllKeys(System.Boolean)">
            <summary>
Register interest for all the keys of the region to get
updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="isDurable">whether the registration should be durable</param>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalClear">
            <summary>
remove all entries in the local region
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Clear">
            <summary>
remove all entries in the local region
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalClear(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
remove all entries in the local region
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Clear(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
remove all entries in the local region
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetInterestListRegex">
            <summary>
get the list of interest regular expressions on this client
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetInterestList">
            <summary>
get the interest list on this client
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterAllKeys">
            <summary>
Register interest for all the keys of the region to get
updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.UnregisterKeys(GemStone.GemFire.Cache.CacheableKey[])">
            <summary>
Unregisters an array of keys to stop getting updates for them.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <param name="keys">the array of keys</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If no keys were previously registered.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.UnregisterKeys(GemStone.GemFire.Cache.ICacheableKey[])">
            <summary>
Unregisters an array of keys to stop getting updates for them.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <param name="keys">the array of keys</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If no keys were previously registered.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterKeys(GemStone.GemFire.Cache.CacheableKey[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Registers an array of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="keys">the array of keys</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <param name="receiveValues">
whether to act like notify-by-subscription is true
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterKeys(GemStone.GemFire.Cache.CacheableKey[],System.Boolean,System.Boolean)">
            <summary>
Registers an array of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="keys">the array of keys</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterKeys(GemStone.GemFire.Cache.CacheableKey[])">
            <summary>
Registers an array of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <param name="keys">the array of keys</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterKeys(GemStone.GemFire.Cache.ICacheableKey[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Registers an array of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="keys">the array of keys</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <param name="receiveValues">
whether to act like notify-by-subscription is true
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterKeys(GemStone.GemFire.Cache.ICacheableKey[],System.Boolean,System.Boolean)">
            <summary>
Registers an array of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
Should only be called for durable clients and with cache server version 5.5 onwards.
</summary>
            <param name="keys">the array of keys</param>
            <param name="isDurable">whether the registration should be durable</param>
            <param name="getInitialValues">
true to populate the cache with values of the keys
that were registered on the server
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.RegisterKeys(GemStone.GemFire.Cache.ICacheableKey[])">
            <summary>
Registers an array of keys for getting updates from the server.
Valid only for a Native Client region when client notification
( <see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> ) is true.
</summary>
            <param name="keys">the array of keys</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If the array of keys is empty.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
If already registered interest for all keys.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
If region destroy is pending.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
If the region is not a Native Client region or
<see cref="M:GemStone.GemFire.Cache.AttributesFactory.SetClientNotificationEnabled(System.Boolean)" /> is false.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.UnknownException">For other exceptions.</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.ContainsKey(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
True if the region contains the given key.
This only searches in the local cache.
</summary>
            <param name="key">key to search for</param>
            <returns>true if contained</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.ContainsKey(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
True if the region contains the given key.
This only searches in the local cache.
</summary>
            <param name="key">key to search for</param>
            <returns>true if contained</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.ContainsValueForKey(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
True if the region contains a value for the given key.
This only searches in the local cache.
</summary>
            <param name="key">key to search for</param>
            <returns>true if value is not null</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.ContainsValueForKey(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
True if the region contains a value for the given key.
This only searches in the local cache.
</summary>
            <param name="key">key to search for</param>
            <returns>true if value is not null</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.IsDestroyed">
            <summary>
True if this region has been destroyed.
</summary>
            <returns>true if destroyed</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.RegionService">
            <summary>
Gets the RegionService for this region.
</summary>
            <returns>RegionService</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.Cache">
            <summary>
Gets the cache for this region.
</summary>
            <returns>region's cache</returns>
            <deprecated>as of NativeClient 3.5 </deprecated>
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.Size">
            <summary>
Get the size of region. For native client regions, this will give
the number of entries in the local cache and not on the servers.
</summary>
            <returns>number of entries in the region</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetEntries(System.Boolean)">
            <summary>
Gets the entries in this region.
</summary>
            <param name="recursive">
if true, also return all nested subregion entries
</param>
            <returns>array of entries</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetValues">
            <summary>
Returns all values in the local process for this region. No value is included
for entries that are invalidated.
</summary>
            <returns>array of values</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetServerKeys">
            <summary>
Returns the set of keys defined in the server process associated with this
client and region. If a server has the region defined as a mirror, then
this will be the entire keyset for the region across all server
<c>Peer</c>s in the distributed system.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.UnsupportedOperationException">
if the member type is not <c>Client</c>
or region is not a Native Client region.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if there is a timeout getting the keys
</exception>
            <returns>array of keys</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetKeys">
            <summary>
Returns all the keys in the local process for this region. This includes
keys for which the entry is invalid.
</summary>
            <returns>array of keys</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalDestroy(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
Destroys the value with the specified key in the local cache only.
Destroy removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if the entry does not exist in this region locally
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalDestroy(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Destroys the value with the specified key in the local cache only.
Destroy removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if the entry does not exist in this region locally
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalDestroy(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Destroys the value with the specified key in the local cache only.
Destroy removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <param name="cacheListenerArg">
a user-defined parameter to pass to cache listeners triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if the entry does not exist in this region locally
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalDestroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Destroys the value with the specified key in the local cache only.
Destroy removes not only the value but also the key and entry
from this region.
</summary>
            <remarks>
                <para>
No <c>ICacheWriter</c> is invoked.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <param name="cacheListenerArg">
a user-defined parameter to pass to cache listeners triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if this region has mirroring enabled
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if the entry does not exist in this region locally
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
Destroys the entry with the specified key, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Destroy removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The destroy is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalDestroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Destroys the entry with the specified key, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Destroy removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The destroy is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalDestroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Destroys the entry with the specified key, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Destroy removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The destroy is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <param name="cacheWriterArg">
a user-defined parameter to pass to cache writers triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalDestroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Destroys the entry with the specified key, passing the callback
argument to any cache writers that are invoked in the operation.
</summary>
            <remarks>
                <para>
Destroy removes not only the value, but also the key and entry
from this region.
</para>
                <para>
The destroy is propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">the key of the entry to destroy</param>
            <param name="cacheWriterArg">
a user-defined parameter to pass to cache writers triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalDestroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterDestroy(GemStone.GemFire.Cache.EntryEvent)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheWriter.BeforeDestroy(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
Locally invalidates the entry with the specified key, passing the
callback argument to any cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
Invalidate only removes the value from the entry -- the key is kept intact.
To completely remove the entry, call <see cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">key of the value to be invalidated</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if this entry does not exist in this region locally
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Locally invalidates the entry with the specified key, passing the
callback argument to any cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
Invalidate only removes the value from the entry -- the key is kept intact.
To completely remove the entry, call <see cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">key of the value to be invalidated</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if this entry does not exist in this region locally
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Locally invalidates the entry with the specified key, passing the
callback argument to any cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
Invalidate only removes the value from the entry -- the key is kept intact.
To completely remove the entry, call <see cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">key of the value to be invalidated</param>
            <param name="callback">
a user-defined parameter to pass to callback events triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if this entry does not exist in this region locally
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Locally invalidates the entry with the specified key, passing the
callback argument to any cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
Invalidate only removes the value from the entry -- the key is kept intact.
To completely remove the entry, call <see cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">key of the value to be invalidated</param>
            <param name="callback">
a user-defined parameter to pass to callback events triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if this entry does not exist in this region locally
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
Invalidates the entry with the specified key, passing the callback
argument to any cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
Invalidate only removes the value from the entry -- the key is kept intact.
To completely remove the entry, call <see cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
The invalidate is not propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">key of the value to be invalidated</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if this entry does not exist in this region locally
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Invalidates the entry with the specified key, passing the callback
argument to any cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
Invalidate only removes the value from the entry -- the key is kept intact.
To completely remove the entry, call <see cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
The invalidate is not propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">key of the value to be invalidated</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if this entry does not exist in this region locally
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Invalidates the entry with the specified key,
passing the callback argument
to any cache
listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
Invalidate only removes the value from the entry -- the key is kept intact.
To completely remove the entry, call <see cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
The invalidate is not propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">key of the value to be invalidated</param>
            <param name="callback">
a user-defined parameter to pass to callback events triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if this entry does not exist in this region locally
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Invalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Invalidates the entry with the specified key,
passing the callback argument
to any cache
listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
Invalidate only removes the value from the entry -- the key is kept intact.
To completely remove the entry, call <see cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
The invalidate is not propogated to the Gemfire cache server to which it is connected with.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="key">key of the value to be invalidated</param>
            <param name="callback">
a user-defined parameter to pass to callback events triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">if key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryNotFoundException">
if this entry does not exist in this region locally
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Destroy(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterInvalidate(GemStone.GemFire.Cache.EntryEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalCreate(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Creates a new entry in this region with the specified key and value
in the local cache only.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, then an <c>EntryExistsException</c> is thrown.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
the key object for which to create the entry in this region.
</param>
            <param name="value">the value to be created in this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalCreate(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value
in the local cache only.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, then an <c>EntryExistsException</c> is thrown.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
the key object for which to create the entry in this region.
</param>
            <param name="value">the value to be created in this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalCreate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Creates a new entry in this region with the specified key and value
in the local cache only.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, then an <c>EntryExistsException</c> is thrown.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
the key object for which to create the entry in this region.
</param>
            <param name="value">the value to be created in this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalCreate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value
in the local cache only.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, then an <c>EntryExistsException</c> is thrown.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
the key object for which to create the entry in this region.
</param>
            <param name="value">the value to be created in this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalCreate(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value
in the local cache only, passing the callback argument to any
cache writers and cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, then an <c>EntryExistsException</c> is thrown.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
the key object for which to create the entry in this region.
</param>
            <param name="value">the value to be created in this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalCreate(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value
in the local cache only, passing the callback argument to any
cache writers and cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, then an <c>EntryExistsException</c> is thrown.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
the key object for which to create the entry in this region.
</param>
            <param name="value">the value to be created in this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalCreate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value
in the local cache only, passing the callback argument to any
cache writers and cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, then an <c>EntryExistsException</c> is thrown.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
the key object for which to create the entry in this region.
</param>
            <param name="value">the value to be created in this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalCreate(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value
in the local cache only, passing the callback argument to any
cache writers and cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, then an <c>EntryExistsException</c> is thrown.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
the key object for which to create the entry in this region.
</param>
            <param name="value">the value to be created in this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Creates a new entry in this region with the specified key and value.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
The new entry is propogated to the java server to which it is connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Creates a new entry in this region with the specified key and value.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
The new entry is propogated to the java server to which it is connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
The new entry is propogated to the java server to which it is connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
The new entry is propogated to the java server to which it is connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
The new entry is propogated to the java server to which it is connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <param name="callbackArg">
a custome parameter to pass to the cache writer or cache listener
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
The new entry is propogated to the java server to which it is connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <param name="callbackArg">
a custome parameter to pass to the cache writer or cache listener
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
The new entry is propogated to the java server to which it is connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <param name="callbackArg">
a custome parameter to pass to the cache writer or cache listener
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Creates a new entry in this region with the specified key and value,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region
and the entry.
</para>
                <para>
The new entry is propogated to the java server to which it is connected with.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
The key for which to create the entry in this region. The object is
created before the call, and the caller should not deallocate the object.
</param>
            <param name="value">
The value for the new entry, which may be null to indicate that the new
entry starts as if it had been locally invalidated.
</param>
            <param name="callbackArg">
a custome parameter to pass to the cache writer or cache listener
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to a GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if there is not enough memory for the new entry
</exception>
            <exception cref="T:GemStone.GemFire.Cache.EntryExistsException">
if an entry with this key already exists
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalPut(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Puts a new value into an entry in this region with the specified key
in the local cache only.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalPut(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Puts a new value into an entry in this region with the specified key
in the local cache only.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalPut(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified key
in the local cache only.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalPut(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified key
in the local cache only.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalPut(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified
key in the local cache only, passing the callback argument to any
cache writers and cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalPut(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified
key in the local cache only, passing the callback argument to any
cache writers and cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalPut(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified
key in the local cache only, passing the callback argument to any
cache writers and cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalPut(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified
key in the local cache only, passing the callback argument to any
cache writers and cache listeners that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callbackArg">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.PutAll(GemStone.GemFire.Cache.CacheableHashMap)">
            <summary>
Puts a map of entries in this region.
</summary>
            <remarks>
                <para>
If there is already an entry associated with any key in the map in
this region, the entry's previous value is overwritten.
The new values are propogated to the java server to which it is connected with.
PutAll is intended for speed up large amount of put operation into
the same region.
</para>
            </remarks>
            <param name="map">
A hashmap contains entries, i.e. (key, value) pairs. Value should
not be null in any of the enties.
</param>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if any value in the map is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.PutAll(GemStone.GemFire.Cache.CacheableHashMap,System.UInt32)">
            <summary>
Puts a map of entries in this region.
</summary>
            <remarks>
                <para>
If there is already an entry associated with any key in the map in
this region, the entry's previous value is overwritten.
The new values are propogated to the java server to which it is connected with.
PutAll is intended for speed up large amount of put operation into
the same region.
</para>
            </remarks>
            <param name="map">
A hashmap contains entries, i.e. (key, value) pairs. Value should
not be null in any of the enties.
</param>
            <param name="timeout">The time (in seconds) to wait for the PutAll
response. It should be less than or equal to 2^31/1000 i.e. 2147483.
Optional.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
If timeout is more than 2^31/1000 i.e. 2147483.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NullPointerException">
if any value in the map is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Puts a new value into an entry in this region with the specified key.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable)">
            <summary>
Puts a new value into an entry in this region with the specified key.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified key.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified key.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified key,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callback">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified key,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callback">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified key,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callback">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Puts a new value into an entry in this region with the specified key,
passing the callback argument to any cache writers and cache listeners
that are invoked in the operation.
</summary>
            <remarks>
                <para>
If there is already an entry associated with the specified key in
this region, the entry's previous value is overwritten.
The new put value is propogated to the java server to which it is connected with.
Put is intended for very simple caching situations. In general
it is better to create a <c>ICacheLoader</c> object and allow the
cache to manage the creation and loading of objects.
</para>
                <para>
Updates the <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastAccessedTime" /> and
<see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> for this region and the entry.
</para>
                <para>
If remote server put fails throwing back a <c>CacheServerException</c>
or security exception, then local put is tried to rollback. However,
if the entry has overflowed/evicted/expired then the rollback is
aborted since it may be due to a more recent notification or update
by another thread.
</para>
            </remarks>
            <param name="key">
a key object associated with the value to be put into this region.
</param>
            <param name="value">the value to be put into this region</param>
            <param name="callback">
argument that is passed to the callback functions
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if CacheWriter aborts the operation
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if region has been destroyed
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.OutOfMemoryException">
if  there is not enough memory for the value
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
Returns the value for the given key, passing the callback argument
to any cache loaders or that are invoked in the operation.
</summary>
            <remarks>
                <para>
If the value is not present locally then it is requested from the java server.
If even that is unsuccessful then a local CacheLoader will be invoked if there is one.
</para>
                <para>
The value returned by get is not copied, so multi-threaded applications
should not modify the value directly, but should use the update methods.
</para>
                <para>
Updates the <see cref="!:CacheStatistics.LastAccessedTime" /><see cref="!:CacheStatistics.HitCount" />, <see cref="!:CacheStatistics.MissCount" />,
and <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> (if a new value is loaded)
for this region and the entry.
</para>
            </remarks>
            <param name="key">
key whose associated value is to be returned -- the key
object must implement the Equals and GetHashCode methods.
</param>
            <returns>
value, or null if the value is not found and can't be loaded
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheLoaderException">
if CacheLoader throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.ContainsKeyOnServer(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
check to see if the key is present on the server
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Returns the value for the given key, passing the callback argument
to any cache loaders or that are invoked in the operation.
</summary>
            <remarks>
                <para>
If the value is not present locally then it is requested from the java server.
If even that is unsuccessful then a local CacheLoader will be invoked if there is one.
</para>
                <para>
The value returned by get is not copied, so multi-threaded applications
should not modify the value directly, but should use the update methods.
</para>
                <para>
Updates the <see cref="!:CacheStatistics.LastAccessedTime" /><see cref="!:CacheStatistics.HitCount" />, <see cref="!:CacheStatistics.MissCount" />,
and <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> (if a new value is loaded)
for this region and the entry.
</para>
            </remarks>
            <param name="key">
key whose associated value is to be returned -- the key
object must implement the Equals and GetHashCode methods.
</param>
            <returns>
value, or null if the value is not found and can't be loaded
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheLoaderException">
if CacheLoader throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Returns the value for the given key, passing the callback argument
to any cache loaders or that are invoked in the operation.
</summary>
            <remarks>
                <para>
If the value is not present locally then it is requested from the java server.
If even that is unsuccessful then a local CacheLoader will be invoked if there is one.
</para>
                <para>
The value returned by get is not copied, so multi-threaded applications
should not modify the value directly, but should use the update methods.
</para>
                <para>
Updates the <see cref="!:CacheStatistics.LastAccessedTime" /><see cref="!:CacheStatistics.HitCount" />, <see cref="!:CacheStatistics.MissCount" />,
and <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> (if a new value is loaded)
for this region and the entry.
</para>
            </remarks>
            <param name="key">
key whose associated value is to be returned -- the key
object must implement the Equals and GetHashCode methods.
</param>
            <param name="callback">
An argument passed into the CacheLoader if loader is used.
Has to be Serializable (i.e. implement <c>IGFSerializable</c>);
can be null.
</param>
            <returns>
value, or null if the value is not found and can't be loaded
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheLoaderException">
if CacheLoader throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Returns the value for the given key, passing the callback argument
to any cache loaders or that are invoked in the operation.
</summary>
            <remarks>
                <para>
If the value is not present locally then it is requested from the java server.
If even that is unsuccessful then a local CacheLoader will be invoked if there is one.
</para>
                <para>
The value returned by get is not copied, so multi-threaded applications
should not modify the value directly, but should use the update methods.
</para>
                <para>
Updates the <see cref="!:CacheStatistics.LastAccessedTime" /><see cref="!:CacheStatistics.HitCount" />, <see cref="!:CacheStatistics.MissCount" />,
and <see cref="P:GemStone.GemFire.Cache.CacheStatistics.LastModifiedTime" /> (if a new value is loaded)
for this region and the entry.
</para>
            </remarks>
            <param name="key">
key whose associated value is to be returned -- the key
object must implement the Equals and GetHashCode methods.
</param>
            <param name="callback">
An argument passed into the CacheLoader if loader is used.
Has to be Serializable (i.e. implement <c>IGFSerializable</c>);
can be null.
</param>
            <returns>
value, or null if the value is not found and can't be loaded
</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if key is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheLoaderException">
if CacheLoader throws an exception
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.MessageException">
If the message received from server could not be handled. This will
be the case when an unregistered typeId is received in the reply or
reply is not well formed. More information can be found in the log.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetEntry(GemStone.GemFire.Cache.CacheableKey)">
            <summary>
Return the meta-object RegionEntry for the given key.
</summary>
            <param name="key">key to use</param>
            <returns>region entry object</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
region has been destroyed
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetEntry(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Return the meta-object RegionEntry for the given key.
</summary>
            <param name="key">key to use</param>
            <returns>region entry object</returns>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">key is null</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
region has been destroyed
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.SubRegions(System.Boolean)">
            <summary>
Returns the subregions of this region.
</summary>
            <param name="recursive">if true, also return all nested subregions</param>
            <returns>array of regions</returns>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
this region has already been destroyed
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.CreateSubRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)">
            <summary>
Creates a subregion with the given name and attributes.
</summary>
            <param name="subRegionName">new subregion name</param>
            <param name="attributes">subregion attributes</param>
            <returns>new subregion</returns>
            <seealso cref="!:CreateServerSubRegion" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetSubRegion(System.String)">
            <summary>
Returns the subregion identified by the path, null if no such subregion.
</summary>
            <param name="path">path</param>
            <returns>subregion, or null if none</returns>
            <seealso cref="P:GemStone.GemFire.Cache.Region.FullPath" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.SubRegions(System.Boolean)" />
            <seealso cref="P:GemStone.GemFire.Cache.Region.ParentRegion" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion">
            <summary>
Destroys the whole local region and provides a user-defined parameter
object to any <c>ICacheWriter</c> invoked in the process.
The region destroy is not distributed to other caches.
</summary>
            <remarks>
                <para>
Destroy cascades to all entries and subregions. After the destroy,
any attempt to use
this region object will get a <c>RegionDestroyedException</c>.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if a CacheWriter aborts the operation; if this occurs some
subregions may have already been successfully destroyed.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Destroys the whole local region and provides a user-defined parameter
object to any <c>ICacheWriter</c> invoked in the process.
The region destroy is not distributed to other caches.
</summary>
            <remarks>
                <para>
Destroy cascades to all entries and subregions. After the destroy,
any attempt to use
this region object will get a <c>RegionDestroyedException</c>.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="callback">
a user-defined parameter to pass to callback events triggered by this call
</param>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if a CacheWriter aborts the operation; if this occurs some
subregions may have already been successfully destroyed.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.DestroyRegion">
            <summary>
Destroys the whole distributed region and provides a user-defined parameter
object to any <c>ICacheWriter</c> invoked in the process.
</summary>
            <remarks>
                <para>
Destroy cascades to all entries and subregions. After the destroy,
this region object can not be used any more. Any attempt to use
this region object will get a <c>RegionDestroyedException</c>
The region destroy not only destroys the local region but also destroys the
server region.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if a CacheWriter aborts the operation; if this occurs some
subregions may have already been successfully destroyed.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Destroys the whole distributed region and provides a user-defined parameter
object to any <c>ICacheWriter</c> invoked in the process.
</summary>
            <remarks>
                <para>
Destroy cascades to all entries and subregions. After the destroy,
this region object can not be used any more. Any attempt to use
this region object will get a <c>RegionDestroyedException</c>
The region destroy not only destroys the local region but also destroys the
server region.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="callback">
a user-defined parameter to pass to callback events triggered by this call
</param>
            <exception cref="T:GemStone.GemFire.Cache.CacheWriterException">
if a CacheWriter aborts the operation; if this occurs some
subregions may have already been successfully destroyed.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <exception cref="T:GemStone.GemFire.Cache.CacheServerException">
If an exception is received from the Java cache server.
Only for Native Client regions.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.TimeoutException">
if the operation timed out
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalInvalidateRegion">
            <summary>
Invalidates this region without distributing to other caches.
</summary>
            <remarks>
                <para>
The invalidation will cascade to all the local subregions and cached
entries. The region
and the entries in it will still exist.
</para>
                <para>
To remove all the
entries and the region, use <see cref="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is no longer valid
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionInvalidate(GemStone.GemFire.Cache.RegionEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.LocalInvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Invalidates this region without distributing to other caches.
</summary>
            <remarks>
                <para>
The invalidation will cascade to all the local subregions and cached
entries. The region
and the entries in it will still exist.
</para>
                <para>
To remove all the
entries and the region, use <see cref="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="callback">
a user-defined parameter to pass to callback events triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region is no longer valid
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalDestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionInvalidate(GemStone.GemFire.Cache.RegionEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.InvalidateRegion">
            <summary>
Invalidates this region.
</summary>
            <remarks>
                <para>
The invalidation will cascade to all the subregions and cached
entries. The region
and the entries in it will still exist.
</para>
                <para>
This operation is not distributed for native clients
</para>
                <para>
To remove all the
entries and the region, use <see cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <exception cref="T:GemStone.GemFire.Cache.CacheListenerException">
if CacheListener throws an exception; if this occurs some
subregions may have already been successfully invalidated
</exception>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionInvalidate(GemStone.GemFire.Cache.RegionEvent)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.InvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Invalidates this region.
</summary>
            <remarks>
                <para>
The invalidation will cascade to all the subregions and cached
entries. The region
and the entries in it will still exist.
</para>
                <para>
This operation is not distributed for native clients
</para>
                <para>
To remove all the
entries and the region, use <see cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />.
</para>
                <para>
Does not update any <c>CacheStatistics</c>.
</para>
            </remarks>
            <param name="callback">
user-defined parameter to pass to callback events triggered by this method
</param>
            <exception cref="T:GemStone.GemFire.Cache.NotConnectedException">
if not connected to the GemFire system because the client cannot
establish usable connections to any of the servers given to it.
For pools configured with locators, if no locators are available, innerException
of NotConnectedException is set to NoAvailableLocatorsException.
</exception>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if this region has been destroyed
</exception>
            <seealso cref="M:GemStone.GemFire.Cache.Region.LocalInvalidateRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.ICacheListener.AfterRegionInvalidate(GemStone.GemFire.Cache.RegionEvent)" />
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.Statistics">
            <summary>
Returns the statistics for this region.
</summary>
            <returns>the <c>CacheStatistics</c> for this region</returns>
            <exception cref="T:GemStone.GemFire.Cache.StatisticsDisabledException">
if statistics have been disabled for this region
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Region.GetAttributesMutator">
            <summary>
Return a mutator object for changing a subset of the
region attributes.
</summary>
            <returns>
attribute mutator
</returns>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region has been destroyed
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.Attributes">
            <summary>
Returns the attributes for this region, which can be used to create a new
region with <see cref="!:Cache.CreateRegion" />.
</summary>
            <returns>
region's attributes
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.ParentRegion">
            <summary>
Gets the parent region.
</summary>
            <returns>
region's parent, if any, or null if this is a root region
</returns>
            <exception cref="T:GemStone.GemFire.Cache.RegionDestroyedException">
if the region has been destroyed
</exception>
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.FullPath">
            <summary>
Gets the region's full path, which can be used to get this region object
with <see cref="M:GemStone.GemFire.Cache.Cache.GetRegion(System.String)" />.
</summary>
            <returns>
region's pathname
</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Region.Name">
            <summary>
Gets the region name.
</summary>
            <returns>
region's name
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Region">
            <summary>
Encapsulates a concrete region of cached data.
</summary>
            <remarks>
This class manages subregions and cached data. Each region
can contain multiple subregions and entries for data.
Regions provide a hierachical name space
within the cache. Also, a region can be used to group cached
objects for management purposes.

Entries managed by the region are key-value pairs. A set of region attributes
is associated with the region when it is created.

The Region interface basically contains two set of APIs: Region management
APIs and (potentially) distributed operations on entries. Non-distributed
operations on entries  are provided by <c>RegionEntry</c>.

Each <c>Cache</c> defines regions called the root regions.
User applications can use the root regions to create subregions
for isolated name spaces and object grouping.

A region's name can be any string, except that it must not contain
the region name separator, a forward slash (/).

<c>Regions</c>  can be referenced by a relative path name from any region
higher in the hierarchy in <see cref="M:GemStone.GemFire.Cache.Region.GetSubRegion(System.String)" />. You can get the relative
path from the root region with <see cref="P:GemStone.GemFire.Cache.Region.FullPath" />. The name separator
is used to concatenate all the region names together from the root, starting
with the root's subregions.
</remarks>
            <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableHashMap.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableHashMap.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.Create(System.Int32)">
            <summary>
Static function to create a new instance with given initial size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.Create(System.Collections.Generic.IDictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Static function to create a new instance copying from the
given dictionary.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the HashMap.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.#ctor(System.Collections.Generic.IDictionary`2{GemStone.GemFire.Cache.ICacheableKey^,GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Allocates a new instance copying from the given dictionary.
</summary>
            <param name="dictionary">
The dictionary whose elements are copied to this HashMap.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableHashMap.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableHashMap">
            <summary>
A mutable <c>ICacheableKey</c> to <c>IGFSerializable</c> hash map
that can serve as a distributable object for caching. This class
extends .NET generic <c>Dictionary</c> class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheLoader.Close(GemStone.GemFire.Cache.Region)">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources, such as
database connections. Any runtime exceptions this method throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheLoader.Load(GemStone.GemFire.Cache.Region,GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Loads a value. Application writers should implement this
method to customize the loading of a value.
</summary>
            <remarks>
This method is called
by the caching service when the requested value is not in the cache.
Any exception thrown by this method is propagated back to and thrown
by the invocation of <see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" /> that triggered this load.
</remarks>
            <param name="region">a Region for which this is called.</param>
            <param name="key">the key for the cacheable</param>
            <param name="helper" />
            <returns>
the value supplied for this key, or null if no value can be
supplied. 
If every available loader returns
a null value, <see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" /> will return null.
</returns>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.ICacheLoader">
            <summary>
A data-loading application plug-in that can be installed on a region.
</summary>
            <remarks>
Loaders facilitate loading of data into the cache from a third-party data source. 
When an application does a
lookup for a key in a region and it does not exist, GemFire checks to
see if any loaders are available for the region in the system and
invokes them to get the value for the key into the cache.
<para>
A cache loader is defined in the <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />.
</para>
When <see cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" /> is called for a region
entry that has a null value, the <see cref="M:GemStone.GemFire.Cache.ICacheLoader.Load(GemStone.GemFire.Cache.Region,GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
method of the region's cache loader is invoked.  The <c>Load</c> method
creates the value for the desired key by performing an operation such
as a database query. 
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheLoader(GemStone.GemFire.Cache.ICacheLoader)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheLoader" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheListener" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheWriter" />
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheLoader">
            <summary>
CacheLoader
</summary>
            <remarks>
CacheLoader
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Scope.IsAck(GemStone.GemFire.Cache.ScopeType)">
            <summary>
True if acknowledgements are required for the given scope.
</summary>
            <param name="type">scope</param>
            <returns>
true if <c>DistributedAck</c>, false otherwise
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Scope.IsDistributedAck(GemStone.GemFire.Cache.ScopeType)">
            <summary>
True if the given scope is distributed-ack.
</summary>
            <param name="type">scope</param>
            <returns>true if <c>DistributedAck</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Scope.IsDistributedNoAck(GemStone.GemFire.Cache.ScopeType)">
            <summary>
True if the given scope is distributed-no-ack.
</summary>
            <param name="type">scope</param>
            <returns>true if <c>DistributedNoAck</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Scope.IsDistributed(GemStone.GemFire.Cache.ScopeType)">
            <summary>
True if the given scope is one of the distributed scopes.
</summary>
            <param name="type">scope</param>
            <returns>
true if other than <c>Local</c>; could be <c>Invalid</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Scope.IsLocal(GemStone.GemFire.Cache.ScopeType)">
            <summary>
True if the given scope is local.
</summary>
            <param name="type">scope</param>
            <returns>true if <c>Local</c></returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Scope">
            <summary>
Static class containing convenience methods for <c>ScopeType</c>.
</summary>
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.Scope" />
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetScope(GemStone.GemFire.Cache.ScopeType)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.ScopeType">
            <summary>
Enumerated type for region distribution scope.
Contains values for setting <c>Scope</c>.
Local scope is invalid (it is a non-native client local region), and
DistributedAck and DistributedNoAck have the same behavior.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ScopeType.Invalid">
            <summary>Invalid scope.</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ScopeType.Global">
            <summary>
Distribute with full interprocess synchronization
-- NOT IMPLEMENTED.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ScopeType.DistributedAck">
            <summary>
Distribute and wait for all peers to acknowledge.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ScopeType.DistributedNoAck">
            <summary>
Distribute without waiting for acknowledgement.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ScopeType.Local">
            <summary>No distribution.</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DiskPolicy.IsNone(GemStone.GemFire.Cache.DiskPolicyType)">
            <summary>
True if the current policy is <c>None</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DiskPolicy.IsOverflow(GemStone.GemFire.Cache.DiskPolicyType)">
            <summary>
True if the current policy is <c>Overflows</c>.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.DiskPolicy">
            <summary>
Static class containing convenience methods for <c>DiskPolicyType</c>.
</summary>
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.DiskPolicy" />
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetDiskPolicy(GemStone.GemFire.Cache.DiskPolicyType)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.DiskPolicyType">
            <summary>
Enumerated type for disk policy.
Contains values for setting the disk policy type.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.DiskPolicyType.Overflows">
            <summary>Overflow to disk.</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.DiskPolicyType.None">
            <summary>No policy.</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Expiration.IsDistributed(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Returns true if this action is distributed.
</summary>
            <returns>true if this is an <c>Invalidate</c> or
a <c>Destroy</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Expiration.IsLocal(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Returns true if this action is local.
</summary>
            <returns>true if this is <c>LocalInvalidate</c> or
<c>LocalDestroy</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Expiration.IsLocalDestroy(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Returns true if this action is local destroy.
</summary>
            <returns>true if this is <c>LocalDestroy</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Expiration.IsDestroy(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Returns true if this action is distributed destroy.
</summary>
            <returns>true if this is <c>Destroy</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Expiration.IsLocalInvalidate(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Returns true if this action is local invalidate.
</summary>
            <returns>true if this is a <c>LocalInvalidate</c></returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Expiration.IsInvalidate(GemStone.GemFire.Cache.ExpirationAction)">
            <summary>
Returns true if this action is distributed invalidate.
</summary>
            <returns>true if this an <c>Invalidate</c></returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.Expiration">
            <summary>
Static class containing convenience methods for <c>ExpirationAction</c>.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.ExpirationAction">
            <summary>
Enumerated type for expiration (LRU) actions.
Contains values for setting an action type.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ExpirationAction.InvalidAction">
            <summary>Invalid action type.</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ExpirationAction.LocalDestroy">
            <summary>
When expired, destroyed locally only.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ExpirationAction.Destroy">
            <summary>
When the region or cached object expires, it is destroyed.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ExpirationAction.LocalInvalidate">
            <summary>
When expired, invalidated locally only.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.ExpirationAction.Invalidate">
            <summary>
When the region or cached object expires, it is invalidated.
</summary>
        </member>
        <member name="M:gemfire.AttributesFactory.createRegionAttributes">
Creates a <code>RegionAttributes</code> with the current settings.
   * @return the newly created <code>RegionAttributes</code>
   * @throws IllegalStateException if the current settings violate the
   * <a href="compatibility.html">compatibility rules</a></member>
        <member name="M:gemfire.AttributesFactory.setEndpoints(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the endpoints for a thin client's connections to a Java server.
If this attribute is set, this is a thin client region.
@param endpoints the list of endpoints in the format
<code>java_servername1:java_port1,java_servername2:java_port2</code>
@endnativeclient
@deprecated since 3.5, use {@link PoolFactory#addServer} or {@link PoolFactory#addLocator}instead.

</member>
        <member name="M:gemfire.AttributesFactory.setCachingEnabled(System.Boolean)">
Set caching enabled flag for this region. If set to false, then no data is stored
in the local process, but events and distributions will still occur, and
the region can still be used to put and remove, etc...
The default if not set is 'true', 'false' is illegal for regions of 'local' scope.
This also requires that interestLists are turned off for the region.
@param cachingEnabled if true, cache data for this region in this process.

</member>
        <member name="M:gemfire.AttributesFactory.setDiskPolicy(gemfire.DiskPolicyType.PolicyType!System.Runtime.CompilerServices.IsConst)">
Sets the Disk policy type for the next <code>RegionAttributes</code> created.
   * @param diskPolicy the type of disk policy to use for the region
   * @throws IllegalArgumentException if diskPolicyType is Invalid

</member>
        <member name="M:gemfire.AttributesFactory.setLruEntriesLimit(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Sets a limit on the number of entries that will be held in the cache.
If a new entry is added while at the limit, the cache will evict the
least recently used entry. Defaults to 0, meaning no LRU actions will
used.

</member>
        <member name="M:gemfire.AttributesFactory.setConcurrencyLevel(System.Byte)">
Sets the concurrency level tof the next <code>RegionAttributes</code>
   * created. This value is used in initializing the map that holds the entries.
   * @param concurrencyLevel the concurrency level of the entry map
   * @throws IllegalArgumentException if concurrencyLevel is nonpositive

</member>
        <member name="M:gemfire.AttributesFactory.setLoadFactor(System.Single)">
Sets the entry load factor for the next <code>RegionAttributes</code>
   * created. This value is
   * used in initializing the map that holds the entries.
   * @param loadFactor the load factor of the entry map
   * @throws IllegalArgumentException if loadFactor is nonpositive

</member>
        <member name="M:gemfire.AttributesFactory.setInitialCapacity(System.Int32)">
Sets the entry initial capacity for the next <code>RegionAttributes</code>
   * created. This value
   * is used in initializing the map that holds the entries.
   * @param initialCapacity the initial capacity of the entry map
   * @throws IllegalArgumentException if initialCapacity is negative.

</member>
        <member name="M:gemfire.AttributesFactory.setClientNotificationEnabled(System.Boolean)">
Sets whether client notification is enabled for the next <code>RegionAttributes</code> created.
@param clientNotificationEnabled whether to use client notification for the region
@deprecated since 3.5, use {@link PoolFactory#setSubscriptionEnabled} instead.

</member>
        <member name="M:gemfire.AttributesFactory.setScope(gemfire.ScopeType.Scope!System.Runtime.CompilerServices.IsConst)">
Sets the scope for the next <code>RegionAttributes</code> created.
   * @param scopeType the type of Scope to use for the region
   * @throws IllegalArgumentException if scopeType is Invalid
   * @deprecated since 3.5

</member>
        <member name="M:gemfire.AttributesFactory.setPersistenceManager(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.Properties&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
this must be used to set the PersistenceManager.

</member>
        <member name="M:gemfire.AttributesFactory.setRegionTimeToLive(gemfire.ExpirationAction.Action,System.Int32)">
Sets the timeToLive expiration attributes for the region itself for the
   * next <code>RegionAttributes</code> created.
   * @param action the expiration action for entries in this region.
   * @param timeToLive the timeToLive in seconds for the region as a whole.

</member>
        <member name="M:gemfire.AttributesFactory.setRegionIdleTimeout(gemfire.ExpirationAction.Action,System.Int32)">
Sets the idleTimeout expiration attributes for the region itself for the
   * next <code>RegionAttributes</code> created.
   * @param action the expiration action for entries in this region.
   * @param idleTimeout the idleTimeout in seconds for the region as a whole.

</member>
        <member name="M:gemfire.AttributesFactory.setEntryTimeToLive(gemfire.ExpirationAction.Action,System.Int32)">
Sets the timeToLive expiration attributes for region entries for the next
   * <code>RegionAttributes</code> created.
   * @param action the expiration action for entries in this region.
   * @param timeToLive the timeToLive in seconds for entries in this region.

</member>
        <member name="M:gemfire.AttributesFactory.setEntryIdleTimeout(gemfire.ExpirationAction.Action,System.Int32)">
Sets the idleTimeout expiration attributes for region entries for the next
   * <code>RegionAttributes</code> created.
   * @param action the expiration action for entries in this region.
   * @param idleTimeout the idleTimeout in seconds for entries in this region.

</member>
        <member name="M:gemfire.AttributesFactory.setPartitionResolver(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the library path for the library that will be invoked for the partition resolver of the region.

</member>
        <member name="M:gemfire.AttributesFactory.setCacheListener(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the library path for the library that will be invoked for the listener of the region.

</member>
        <member name="M:gemfire.AttributesFactory.setCacheWriter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the library path for the library that will be invoked for the writer of the region.

</member>
        <member name="M:gemfire.AttributesFactory.setCacheLoader(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the library path for the library that will be invoked for the loader of the region.

</member>
        <member name="M:gemfire.AttributesFactory.setPartitionResolver(gemfire.SharedPtr&lt;gemfire.PartitionResolver&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the PartitionResolver for the next <code>RegionAttributes</code> created.
   * @param aResolver a user defined PartitionResolver, NULLPTR if no resolver

</member>
        <member name="M:gemfire.AttributesFactory.setCacheListener(gemfire.SharedPtr&lt;gemfire.CacheListener&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the CacheListener for the next <code>RegionAttributes</code> created.
   * @param aListener a user defined CacheListener, NULLPTR if no listener

</member>
        <member name="M:gemfire.AttributesFactory.setCacheWriter(gemfire.SharedPtr&lt;gemfire.CacheWriter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the cache writer for the next <code>RegionAttributes</code> created.
   * @param cacheWriter the cache writer or NULLPTR if no cache writer

</member>
        <member name="M:gemfire.AttributesFactory.setCacheLoader(gemfire.SharedPtr&lt;gemfire.CacheLoader&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the cache loader for the next <code>RegionAttributes</code> created.
   * @param cacheLoader the cache loader or NULLPTR if no loader

</member>
        <member name="M:gemfire.AttributesFactory.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.AttributesFactory.#ctor(gemfire.SharedPtr&lt;gemfire.RegionAttributes&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a new instance of AttributesFactory ready to create a
   *  <code>RegionAttributes</code> with the same settings as those in the
   *  specified <code>RegionAttributes</code>.
   * @param regionAttributes the <code>RegionAttributes</code> used to initialize this AttributesFactory

</member>
        <member name="M:gemfire.AttributesFactory.#ctor">
@brief public methods

@brief constructor

Creates a new instance of AttributesFactory ready to create a
   *       <code>RegionAttributes</code> with default settings.

</member>
        <member name="M:gemfire.Pool.createSecureUserCache(gemfire.SharedPtr&lt;gemfire.Properties&gt;)">
Returns the logical instance of cache from pool.
Each operation on this cache will use this "credentials"

@throws IllegalStateException if cache has not been created or it has been closed.
       Or if Pool is not in multiusersecure mode.
@returns Logical instance of cache to do operations on behalf of one particular user.

</member>
        <member name="M:gemfire.Pool.getQueryService">
 Returns the QueryService for this Pool.
 The query operations performed using this QueryService will be executed
 on the servers that are associated with this pool.
 To perform Query operation on the local cache obtain the QueryService
 instance from the Cache.
 @throws unSupported Exception when Pool is in multi user mode. 

 @see Cache#getQueryService
 @return the QueryService

</member>
        <member name="M:gemfire.Pool.isDestroyed">
 Indicates whether this Pool has been
 destroyed.

 @return true if the pool has been destroyed.

</member>
        <member name="M:gemfire.Pool.destroy(System.Boolean)">
Destroys this pool closing any connections it produced.
@param keepAlive defines 
               whether the server should keep the durable client's
               subscriptions alive for the timeout period.
@throws IllegalStateException
                if the pool is still in use.

</member>
        <member name="M:gemfire.Pool.getServers">
Returns an unmodifiable list of
servers this pool is using. These servers where either
{@link PoolFactory#addServer added explicitly}
when the pool was created or were discovered using this pools {@link #getLocators locators}.

</member>
        <member name="M:gemfire.Pool.releaseThreadLocalConnection">
If this pool was configured to use <code>threadlocalconnections</code>,
then this method will release the connection cached for the calling thread.
The connection will then be available for use by other threads.

If this pool is not using <code>threadlocalconnections</code>, this method
will have no effect.

</member>
        <member name="M:gemfire.Pool.getPRSingleHopEnabled">
Returns true if single-hop optimisation is enabled on this pool.
@see PoolFactory#setPRSingleHopEnabled

</member>
        <member name="M:gemfire.Pool.getMultiuserAuthentication">
Returns <code>true</code> if multiuser authentication is enabled on this pool.
@see PoolFactory#setMultiuserAuthentication

</member>
        <member name="M:gemfire.Pool.getThreadLocalConnections">
Returns <code>true</code> if thread local connections are enabled on this pool.
@see PoolFactory#setThreadLocalConnections

</member>
        <member name="M:gemfire.Pool.getServerGroup">
Returns the server group of this pool.
@see PoolFactory#setServerGroup

</member>
        <member name="M:gemfire.Pool.getSubscriptionAckInterval">
Returns the subscription ack interval of this pool.
@see PoolFactory#setSubscriptionAckInterval(int)

</member>
        <member name="M:gemfire.Pool.getSubscriptionMessageTrackingTimeout">
Returns the subscription message tracking timeout of this pool.
@see PoolFactory#setSubscriptionMessageTrackingTimeout

</member>
        <member name="M:gemfire.Pool.getSubscriptionRedundancy">
Returns the subscription redundancy level of this pool.
@see PoolFactory#setSubscriptionRedundancy

</member>
        <member name="M:gemfire.Pool.getSubscriptionEnabled">
Returns the true if a server-to-client subscriptions are enabled on this pool.
@see PoolFactory#setSubscriptionEnabled

</member>
        <member name="M:gemfire.Pool.getRetryAttempts">
Gets the retry attempts for this pool.
@see PoolFactory#setRetryAttempts(int)

</member>
        <member name="M:gemfire.Pool.getStatisticInterval">
Gets the statistic interval for this pool.
@see PoolFactory#setStatisticInterval(int)

</member>
        <member name="M:gemfire.Pool.getPingInterval">
Gets the ping interval for this pool.
@see PoolFactory#setPingInterval(long)

</member>
        <member name="M:gemfire.Pool.getIdleTimeout">
Gets the idle connection timeout for this pool.
@see PoolFactory#setIdleTimeout(long)

</member>
        <member name="M:gemfire.Pool.getMaxConnections">
Gets the maximum connections for this pool.
@see PoolFactory#setMaxConnections(int)

</member>
        <member name="M:gemfire.Pool.getMinConnections">
Gets the minimum connections for this pool.
@see PoolFactory#setMinConnections(int)

</member>
        <member name="M:gemfire.Pool.getReadTimeout">
Returns the read timeout of this pool.
@see PoolFactory#setReadTimeout

</member>
        <member name="M:gemfire.Pool.getSocketBufferSize">
Returns the socket buffer size of this pool.
@see PoolFactory#setSocketBufferSize

</member>
        <member name="M:gemfire.Pool.getLoadConditioningInterval">
Returns the load conditioning interval of this pool.
@see PoolFactory#setLoadConditioningInterval

</member>
        <member name="M:gemfire.Pool.getFreeConnectionTimeout">
Returns the connection timeout of this pool.
@see PoolFactory#setFreeConnectionTimeout

</member>
        <member name="M:gemfire.Pool.getName">
 Gets the name of the connection pool

 @return the name of the pool
 @see PoolFactory#create

</member>
        <member name="M:gemfire.CacheFactory.set(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets a gemfire property that will be used when creating the {link @Cache}.
@param name the name of the gemfire property
@param value the value of the gemfire property
@return a reference to <code>this</code>
@since 3.5

</member>
        <member name="M:gemfire.CacheFactory.setMultiuserAuthentication(System.Boolean)">
Sets whether Pool is in multi user secure mode.
If its in multiuser mode then app needs to get RegionService instance of Cache, to do the operations on cache.
Deafult value is false.
@param multiuserAuthentication
       to set the pool in multiuser mode.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.CacheFactory.setSubscriptionAckInterval(System.Int32)">
 Sets the is the interval in milliseconds
 to wait before sending acknowledgements to the bridge server for
 events received from the server subscriptions.

 @param ackInterval is the number of milliseconds to wait before sending event
 acknowledgements.
 @return a reference to <code>this</code>
 @throws IllegalArgumentException if <code>ackInterval</code>
 is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.setSubscriptionMessageTrackingTimeout(System.Int32)">
Sets the messageTrackingTimeout attribute which is the time-to-live period, in
milliseconds, for subscription events the client has received from the server. It is used
to minimize duplicate events.
Entries that have not been modified for this amount of time
are expired from the list.
@param messageTrackingTimeout is the number of milliseconds to set the timeout to.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>messageTrackingTimeout</code>
is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.setSubscriptionRedundancy(System.Int32)">
Sets the redundancy level for this pools server-to-client subscriptions.
If <code>0</code> then no redundant copies are kept on the servers.
Otherwise an effort is made to maintain the requested number of
copies of the server-to-client subscriptions. At most, one copy per server is
 made up to the requested level.
@param redundancy is the number of redundant servers for this client's subscriptions.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>redundancyLevel</code>
is less than <code>-1</code>.

</member>
        <member name="M:gemfire.CacheFactory.setSubscriptionEnabled(System.Boolean)">
If set to <code>true</code> then the created pool will have server-to-client
subscriptions enabled.
If set to <code>false</code> then all <code>Subscription*</code> attributes
are ignored at the time of creation.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.CacheFactory.addServer(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Adds a server, given its host and port, to this factory.
The server must be a bridge server and this client will
directly connect to the server without consulting a server locator.
@param host is the host name or ip address that the server is listening on.
@param port is the port that the server is listening on.
@return a reference to <code>this</code>
@throws IllegalArgumentException if the <code>host</code> is an unknown host
according to {@link java.net.InetAddress#getByName} or if the port is outside
the valid range of [1..65535] inclusive.
@throws IllegalStateException if the server has already been {@link #addLocator added} to this factory.

</member>
        <member name="M:gemfire.CacheFactory.addLocator(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Adds a locator, given its host and port, to this factory.
The locator must be a server locator and will be used to discover other running
bridge servers and locators.
@param host is the host name or ip address that the locator is listening on.
@param port is the port that the locator is listening on.
@return a reference to <code>this</code>
@throws IllegalArgumentException if the <code>host</code> is an unknown host
according to {@link java.net.InetAddress#getByName} or if the port is outside
the valid range of [1..65535] inclusive.
@throws IllegalStateException if the locator has already been {@link #addServer added} to this factory.

</member>
        <member name="M:gemfire.CacheFactory.setServerGroup(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Configures the group which contains all the servers that this pool connects to.
@param group is the server group that this pool will connect to.
If the value is <code>null</code> or <code>""</code> then the pool connects to all servers.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.CacheFactory.setPingInterval(System.Int32!System.Runtime.CompilerServices.IsLong)">
 The frequency with which servers must be pinged to verify that they are still alive.
 Each server will be sent a ping every <code>pingInterval</code> if there has not
 been any other communication with the server.

 These pings are used by the server to monitor the health of
 the client. Make sure that the <code>pingInterval</code> is less than the
 maximum time between pings allowed by the bridge server.
 @param pingInterval is the amount of time in milliseconds between
 pings.
 @return a reference to <code>this</code>
 @throws IllegalArgumentException if <code>pingInterval</code>
 is less than <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.setRetryAttempts(System.Int32)">
Set the number of times to retry a request after timeout/exception.
@param retryAttempts is the number of times to retry a request
after timeout/exception. -1 indicates that a request should be
tried against every available server before failing
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>idleTimout</code>
is less than <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.setIdleTimeout(System.Int32!System.Runtime.CompilerServices.IsLong)">
Sets the amount of time a connection can be idle before expiring the connection.
If the pool size is greater than the minimum specified by
{@link PoolFactory#setMinConnections(int)}, connections which have been idle
for longer than the idleTimeout will be closed.
@param idleTimeout is the amount of time in milliseconds that an idle connection
should live before expiring. -1 indicates that connections should never expire.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>idleTimout</code>
is less than <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.setMaxConnections(System.Int32)">
Sets the max number of client to server connections that the pool will create. If all of
the connections are in use, an operation requiring a client to server connection
will block until a connection is available.
@see #setFreeConnectionTimeout(int)
@param maxConnections is the maximum number of connections in the pool.
<code>-1</code> indicates that there is no maximum number of connections
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>maxConnections</code>
is less than <code>minConnections</code>.

</member>
        <member name="M:gemfire.CacheFactory.setMinConnections(System.Int32)">
Sets the minimum number of connections to keep available at all times.
When the pool is created, it will create this many connections.
If <code>0</code> then connections will not be made until an actual operation
is done that requires client-to-server communication.
@param minConnections is the initial number of connections
this pool will create.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>minConnections</code>
is less than <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.setReadTimeout(System.Int32)">
Sets the number of milliseconds to wait for a response from a server before
timing out the operation and trying another server (if any are available).
@param timeout is the number of milliseconds to wait for a response from a server
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>timeout</code>
is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.setSocketBufferSize(System.Int32)">
Sets the socket buffer size for each connection made in this pool.
Large messages can be received and sent faster when this buffer is larger.
Larger buffers also optimize the rate at which servers can send events
for client subscriptions.
@param bufferSize is the size of the socket buffers used for reading and
writing on each connection in this pool.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>bufferSize</code>
is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.setFreeConnectionTimeout(System.Int32)">
Sets the free connection timeout for this pool.
If the pool has a max connections setting, operations will block
if all of the connections are in use. The free connection timeout
specifies how long those operations will block waiting for
a free connection before receiving
an {@link AllConnectionsInUseException}. If max connections
is not set this setting has no effect.
@see #setMaxConnections(int)
@param connectionTimeout is the connection timeout in milliseconds
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>connectionTimeout</code>
is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.CacheFactory.getProductDescription">
Returns the product description string including product name and version. 
</member>
        <member name="M:gemfire.CacheFactory.getVersion">
Returns the version of the cache implementation.
   * For the 1.0 release of GemFire, the string returned is <code>1.0</code>.
   * @return the version of the cache implementation as a <code>String</code></member>
        <member name="M:gemfire.CacheFactory.getAnyInstance">
Gets an arbitrary open instance of {@link Cache} produced by an
earlier call to {@link CacheFactory::create}.
@throws CacheClosedException if a cache has not been created
or the only created one is {@link Cache::isClosed closed}

</member>
        <member name="M:gemfire.CacheFactory.getInstanceCloseOk(gemfire.SharedPtr&lt;gemfire.DistributedSystem&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the instance of {@link Cache} produced by an
earlier call to {@link CacheFactory::create}, even if it has been closed.
@param system the <code>DistributedSystem</code> the cache was created with.
@return the {@link Cache} associated with the specified system.
@throws CacheClosedException if a cache has not been created
@throws EntryNotFoundException if a cache with specified system is not found

</member>
        <member name="M:gemfire.CacheFactory.getInstance(gemfire.SharedPtr&lt;gemfire.DistributedSystem&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets the instance of {@link Cache} produced by an
earlier call to {@link CacheFactory::create}.
@param system the <code>DistributedSystem</code> the cache was created with.
@return the {@link Cache} associated with the specified system.
@throws CacheClosedException if a cache has not been created
or the created one is {@link Cache::isClosed closed}
@throws EntryNotFoundException if a cache with specified system not found

</member>
        <member name="M:gemfire.CacheFactory.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.DistributedSystem&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.CacheAttributes&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Creates a new cache that uses the specified <code>system</code>.

 @param name
        name to associate with the new cache; cannot be NULL;
        if empty then "NativeCache" is used as the name
 @param system
        a <code>DistributedSystem</code> obtained by calling
        {@link DistributedSystem::connect}.
 @param attrs
        optional <code>CacheAttributes</code> for this cache

 @return a <code>Cache</code> that uses the specified
         <code>system</code> for distribution.

 @throws IllegalArgumentException
         If <code>system</code> is not {@link
         DistributedSystem::isConnected connected}.
         or name is NULL
 @throws CacheExistsException
         If an open cache already exists.
 @deprecated as of NativeClient 3.5, use {@link CacheFactory#createCacheFactory} instead.

</member>
        <member name="M:gemfire.CacheFactory.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.DistributedSystem&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.CacheAttributes&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
 Creates a new cache that uses the specified <code>system</code>.

 @param name
        name to associate with the new cache; cannot be NULL;
        if empty then "NativeCache" is used as the name
 @param system
        a <code>DistributedSystem</code> obtained by calling
        {@link DistributedSystem::connect}.
 @param cacheXml
        name of the xml file from which cache will be configured.
 @param attrs
        optional <code>CacheAttributes</code> for this cache; these
        override the ones provided in <code>cacheXml</code>.

 @return a <code>Cache</code> that uses the specified
         <code>system</code> for distribution.

 @throws IllegalArgumentException
         If <code>system</code> is not {@link
         DistributedSystem::isConnected connected}.
         or name is NULL
 @throws CacheExistsException
         If an open cache already exists.
 @throws CacheXmlException
         Something went wrong while parsing the XML
 @throws IllegalStateException
         If xml file is well-flrmed but not valid
 @deprecated as of NativeClient 3.5, use {@link CacheFactory#createCacheFactory} instead.

</member>
        <member name="M:gemfire.CacheFactory.create">
To create the instance of {@link Cache}.

</member>
        <member name="M:gemfire.CacheFactory.createCacheFactory(gemfire.SharedPtr&lt;gemfire.Properties&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
To create the instance of {@link CacheFactory} 
@param dsProps 
       Properties which are applicable at client level.

</member>
        <member name="M:gemfire.CacheAttributes.setEndpoints(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
Sets cache level endpoints list.
   *

</member>
        <member name="M:gemfire.CacheAttributes.setRedundancyLevel(System.Int32)">
Sets redundancy level.
   *

</member>
        <member name="M:gemfire.CacheAttributes.getEndpoints">
Gets cache level endpoints list.

</member>
        <member name="M:gemfire.CacheAttributes.getRedundancyLevel">
@brief public static methods

Gets redundancy level for regions in the cache.

</member>
        <member name="M:gemfire.Cache.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.DistributedSystem&gt;,System.Boolean)">
@brief constructors

</member>
        <member name="M:gemfire.Cache.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.Cache.getPdxIgnoreUnreadFields">
Returns whther Cache saves unread fields for Pdx types.
Currently c++ don't support pdx types, thus it is for internal purpose only

</member>
        <member name="M:gemfire.Cache.createAuthenticatedView(gemfire.SharedPtr&lt;gemfire.Properties&gt;,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Creates an authenticated cache using the given user security properties.
 Multiple instances with different user properties can be created with a
 single client cache.
 
 Application must use this instance to do operations, when
 multiuser-authentication is set to true.

 @see RegionService
 @see PoolFactory#setMultiuserAuthentication(boolean)
 @return the {@link RegionService} instance associated with a user and given
         properties.
 @throws UnsupportedOperationException
           when invoked with multiuser-authentication as false.
 
 @param userSecurityProperties
        the security properties of a user.

 @param poolName 
        the pool that the users should be authenticated against. Set if there are more than one Pool in Cache.

</member>
        <member name="M:gemfire.Cache.readyForEvents">
Send the "client ready" message to the server from a durable client.

</member>
        <member name="M:gemfire.Cache.getQueryService(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Gets the QueryService from which a new Query can be obtained.
@param poolName
       Pass poolname if pool is created from cache.xml or {@link PoolManager}
@returns A smart pointer to the QueryService.

</member>
        <member name="M:gemfire.Cache.getQueryService">
Gets the QueryService from which a new Query can be obtained.
@returns A smart pointer to the QueryService.

</member>
        <member name="M:gemfire.Cache.rootRegions(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.Region&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Returns a set of root regions in the cache. This set is a snapshot and
 is not backed by the Cache. The vector passed in is cleared and the
 regions are added to it.

 @param regions the returned set of
 regions

</member>
        <member name="M:gemfire.Cache.getRegion(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Look up a region with the full path from root.
   *
   * If Pool attached with Region is in multiusersecure mode then don't use return instance of region as no credential are attached with this instance.
   * Get region from RegionService instance of Cache.@see Cache#createAuthenticatedView(PropertiesPtr).
   *
   * @param path the region's name, such as <code>AuthRegion</code>.
   * @returns region, or NULLPTR if no such region exists.

</member>
        <member name="M:gemfire.Cache.createRegion(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.RegionAttributes&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Returns a region created using the specified
 RegionAttributes.

 The region is just created locally. It is not created on the server
 to which this client is connected with.

 If Pool attached with Region is in multiusersecure mode then don't use return instance of region as no credential are attached with this instance.
 Get region from AuthenticatedCache to do the operation on Cache. 

 @param name the name of the region to create
 @param aRegionAttributes the attributes of the root region
 @returns pointer to the returned region
 @throws InvalidArgumentException if the attributePtr is NULLPTR.
 @throws RegionExistsException if a region is already in
 this cache
 @throws CacheClosedException if the cache is closed
 @throws OutOfMemoryException if the memory allocation failed
 @throws InitFailedException if the PersistenceManagerImpl object fails to initialize
 @throws UnsupportedOperationException if the region attributes are not consistent with
         cache attributes and distributed system properties.
 @throws UnknownException otherwise
 @deprecated as of NativeClient 3.5, use {@link Cache#createRegionFactory} instead.

</member>
        <member name="M:gemfire.Cache.close(System.Boolean)">
Terminates this object cache and releases all the local resources.
After this cache is closed, any further
method call on this cache or any region object will throw
<code>CacheClosedException</code>, unless otherwise noted.
If Cache instance created from Pool(pool is in multiuser mode), then it reset user related security data.
@param keepalive whether to keep a durable client's queue alive
@throws CacheClosedException,  if the cache is already closed.

</member>
        <member name="M:gemfire.Cache.close">
Terminates this object cache and releases all the local resources.
After this cache is closed, any further
method call on this cache or any region object will throw
<code>CacheClosedException</code>, unless otherwise noted.
If Cache instance created from Pool(pool is in multiuser mode), then it reset user related security data.
@throws CacheClosedException,  if the cache is already closed.

</member>
        <member name="M:gemfire.Cache.getDistributedSystem">
Returns the distributed system that this cache was
{@link CacheFactory::createCacheFactory created} with.

</member>
        <member name="M:gemfire.Cache.isClosed">
 Indicates if this cache has been closed.
 After a new cache object is created, this method returns false;
 After the close is called on this cache object, this method
 returns true.

 @return true, if this cache is closed; false, otherwise

</member>
        <member name="M:gemfire.Cache.getName">
Returns the name of this cache.
   * @return the string name of this cache

</member>
        <member name="M:gemfire.Cache.initializeDeclarativeCache(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Initializes the cache from an xml file

 @param cacheXml
        Valid cache.xml file

</member>
        <member name="M:gemfire.Cache.createRegionFactory(gemfire.RegionShortcut)">
@brief public methods

 Returns the {@link RegionFactory} to create the region. 
 Before creating the Region, one can set region attributes using this instance.

 @param regionShortcut
        To create the region specific type, @see RegionShortcut

</member>
        <member name="M:gemfire.CacheTransactionManager.exists">
Reports the existence of a Transaction for this thread
	 *
	 * @return true if a transaction exists, false otherwise
	 *
	 * @since 4.0

</member>
        <member name="M:gemfire.CacheTransactionManager.rollback">
Roll back the transaction associated with the current thread. When
	 *  this method completes, the thread is no longer associated with a
	 *  transaction and the transaction context is destroyed.
	 *
	 * @since 4.0
	 *
	 * @throws IllegalStateException if the thread is not associated with a transaction

</member>
        <member name="M:gemfire.CacheTransactionManager.commit">
Commit the transaction associated with the current thread. If
	 *  the commit operation fails due to a conflict it will destroy
	 *  the transaction state and throw a {@link
	 *  CommitConflictException}.  If the commit operation succeeds,
	 *  it returns after the transaction state has been merged with
	 *  committed state.  When this method completes, the thread is no
	 *  longer associated with a transaction.
	 *
	 * @throws IllegalStateException if the thread is not associated with a transaction
	 *
	 * @throws CommitConflictException if the commit operation fails due to
	 *   a write conflict.
	 *
	 * @throws TransactionDataNodeHasDepartedException if the node hosting the
	 * transaction data has departed. This is only relevant for transaction that
	 * involve PartitionedRegions.
	 *
	 * @throws TransactionDataNotColocatedException if at commit time, the data
	 * involved in the transaction has moved away from the transaction hosting
	 * node. This can only happen if rebalancing/recovery happens during a
	 * transaction that involves a PartitionedRegion.
	 *
	 * @throws TransactionInDoubtException when GemFire cannot tell which nodes
	 * have applied the transaction and which have not. This only occurs if nodes
	 * fail mid-commit, and only then in very rare circumstances.

</member>
        <member name="M:gemfire.CacheTransactionManager.begin">
Creates a new transaction and associates it with the current thread.
	 *
	 * @throws IllegalStateException if the thread is already associated with a transaction
	 *
	 * @since 4.0

</member>
        <member name="M:gemfire.RegionFactory.setCachingEnabled(System.Boolean)">
Set caching enabled flag for this region. If set to false, then no data is stored
in the local process, but events and distributions will still occur, and
the region can still be used to put and remove, etc...
The default if not set is 'true', 'false' is illegal for regions of 'local' scope.
This also requires that interestLists are turned off for the region.
@param cachingEnabled if true, cache data for this region in this process.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setDiskPolicy(gemfire.DiskPolicyType.PolicyType!System.Runtime.CompilerServices.IsConst)">
Sets the Disk policy type for the next <code>RegionAttributes</code> created.
  * @param diskPolicy the type of disk policy to use for the region
  * @return a reference to <code>this</code>
  * @throws IllegalArgumentException if diskPolicyType is Invalid

</member>
        <member name="M:gemfire.RegionFactory.setLruEntriesLimit(System.UInt32!System.Runtime.CompilerServices.IsConst)">
Sets a limit on the number of entries that will be held in the cache.
If a new entry is added while at the limit, the cache will evict the
least recently used entry. Defaults to 0, meaning no LRU actions will
used.
@param entriesLimit number of enteries to keep in region 
@return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setConcurrencyLevel(System.Byte)">
Sets the concurrency level tof the next <code>RegionAttributes</code>
  * created. This value is used in initializing the map that holds the entries.
  * @param concurrencyLevel the concurrency level of the entry map
  * @return a reference to <code>this</code>
  * @throws IllegalArgumentException if concurrencyLevel is nonpositive

</member>
        <member name="M:gemfire.RegionFactory.setLoadFactor(System.Single)">
Sets the entry load factor for the next <code>RegionAttributes</code>
  * created. This value is
  * used in initializing the map that holds the entries.
  * @param loadFactor the load factor of the entry map
  * @return a reference to <code>this</code>
  * @throws IllegalArgumentException if loadFactor is nonpositive

</member>
        <member name="M:gemfire.RegionFactory.setInitialCapacity(System.Int32)">
Sets the entry initial capacity for the next <code>RegionAttributes</code>
  * created. This value
  * is used in initializing the map that holds the entries.
  * @param initialCapacity the initial capacity of the entry map
  * @return a reference to <code>this</code>
  * @throws IllegalArgumentException if initialCapacity is negative.

</member>
        <member name="M:gemfire.RegionFactory.setPersistenceManager(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.Properties&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the library path for the library that will be invoked for the persistence of the region.
If the region is being created from a client on a server, or on a server directly, then
this must be used to set the PersistenceManager.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setRegionTimeToLive(gemfire.ExpirationAction.Action,System.Int32)">
Sets the timeToLive expiration attributes for the region itself for the
  * next <code>RegionAttributes</code> created.
  * @param action the expiration action for entries in this region.
  * @param timeToLive the timeToLive in seconds for the region as a whole.
  * @return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setRegionIdleTimeout(gemfire.ExpirationAction.Action,System.Int32)">
Sets the idleTimeout expiration attributes for the region itself for the
  * next <code>RegionAttributes</code> created.
  * @param action the expiration action for entries in this region.
  * @param idleTimeout the idleTimeout in seconds for the region as a whole.
  * @return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setEntryTimeToLive(gemfire.ExpirationAction.Action,System.Int32)">
Sets the timeToLive expiration attributes for region entries for the next
  * <code>RegionAttributes</code> created.
  * @param action the expiration action for entries in this region.
  * @param timeToLive the timeToLive in seconds for entries in this region.
  * @return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setEntryIdleTimeout(gemfire.ExpirationAction.Action,System.Int32)">
Sets the idleTimeout expiration attributes for region entries for the next
  * <code>RegionAttributes</code> created.
  * @param action the expiration action for entries in this region.
  * @param idleTimeout the idleTimeout in seconds for entries in this region.
  * @return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setPartitionResolver(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the library path for the library that will be invoked for the partition resolver of the region.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setCacheListener(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the library path for the library that will be invoked for the listener of the region.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setCacheWriter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the library path for the library that will be invoked for the writer of the region.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setCacheLoader(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the library path for the library that will be invoked for the loader of the region.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setPartitionResolver(gemfire.SharedPtr&lt;gemfire.PartitionResolver&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the PartitionResolver for the next <code>RegionAttributes</code> created.
  * @param aResolver a user defined PartitionResolver, NULLPTR if no resolver
  * @return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setCacheListener(gemfire.SharedPtr&lt;gemfire.CacheListener&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the CacheListener for the next <code>RegionAttributes</code> created.
  * @param aListener a user defined CacheListener, NULLPTR if no listener
  * @return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setCacheWriter(gemfire.SharedPtr&lt;gemfire.CacheWriter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the cache writer for the next <code>RegionAttributes</code> created.
  * @param cacheWriter the cache writer or NULLPTR if no cache writer
  * @return a reference to <code>this</code></member>
        <member name="M:gemfire.RegionFactory.setCacheLoader(gemfire.SharedPtr&lt;gemfire.CacheLoader&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets the cache loader for the next <code>RegionAttributes</code> created.
  * @param cacheLoader the cache loader or NULLPTR if no loader
  * @return a reference to <code>this</code></member>
        <member name="F:LOCAL_ENTRY_LRU">
A LOCAL_LRU region only has local state and never sends operations to a server.
It will also destroy entries once it detects that the number of enteries crossing default limit of #100000.

</member>
        <member name="F:LOCAL">
A LOCAL region only has local state and never sends operations to a server.

</member>
        <member name="F:CACHING_PROXY_ENTRY_LRU">
A CACHING_PROXY_LRU region has local state but can also send operations to a server.
If the local state is not found then the operation is sent to the server
and the local state is updated to contain the server result.
It will also destroy entries once it detects that the number of enteries crossing default limit of #100000.

</member>
        <member name="F:CACHING_PROXY">
A CACHING_PROXY region has local state but can also send operations to a server.
If the local state is not found then the operation is sent to the server
and the local state is updated to contain the server result.

</member>
        <member name="F:PROXY">
A PROXY region has no local state and forwards all operations to a server.

</member>
        <member name="M:gemfire.PoolFactory.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Creates a new Pool for connecting a client to a set of GemFire Cache Servers.
 using this factory's settings for attributes.

 @param name is the name of the pool, used when connecting regions to it
 @throws IllegalStateException if a pool with <code>name</code> already exists
 @throws IllegalStateException if a locator or server has not been added.
 @return the newly created pool.

</member>
        <member name="M:gemfire.PoolFactory.reset">
Resets the configuration of this factory to its defaults.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.PoolFactory.setMultiuserAuthentication(System.Boolean)">
Sets whether Pool is in multi user secure mode.
If its in multiuser mode then app needs to get RegionService instance of Cache.
Deafult value is false.

</member>
        <member name="M:gemfire.PoolFactory.setSubscriptionAckInterval(System.Int32)">
 Sets the is the interval in milliseconds
 to wait before sending acknowledgements to the bridge server for
 events received from the server subscriptions.

 @param ackInterval is the number of milliseconds to wait before sending event
 acknowledgements.
 @return a reference to <code>this</code>
 @throws IllegalArgumentException if <code>ackInterval</code>
 is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.PoolFactory.setSubscriptionMessageTrackingTimeout(System.Int32)">
Sets the messageTrackingTimeout attribute which is the time-to-live period, in
milliseconds, for subscription events the client has received from the server. It is used
to minimize duplicate events.
Entries that have not been modified for this amount of time
are expired from the list.
@param messageTrackingTimeout is the number of milliseconds to set the timeout to.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>messageTrackingTimeout</code>
is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.PoolFactory.setSubscriptionRedundancy(System.Int32)">
Sets the redundancy level for this pools server-to-client subscriptions.
If <code>0</code> then no redundant copies are kept on the servers.
Otherwise an effort is made to maintain the requested number of
copies of the server-to-client subscriptions. At most, one copy per server is
 made up to the requested level.
@param redundancy is the number of redundant servers for this client's subscriptions.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>redundancyLevel</code>
is less than <code>-1</code>.

</member>
        <member name="M:gemfire.PoolFactory.setSubscriptionEnabled(System.Boolean)">
If set to <code>true</code> then the created pool will have server-to-client
subscriptions enabled.
If set to <code>false</code> then all <code>Subscription*</code> attributes
are ignored at the time of creation.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.PoolFactory.addServer(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Adds a server, given its host and port, to this factory.
The server must be a bridge server and this client will
directly connect to the server without consulting a server locator.
@param host is the host name or ip address that the server is listening on.
@param port is the port that the server is listening on.
@return a reference to <code>this</code>
@throws IllegalArgumentException if the <code>host</code> is an unknown host
according to {@link java.net.InetAddress#getByName} or if the port is outside
the valid range of [1..65535] inclusive.
@throws IllegalStateException if the server has already been {@link #addLocator added} to this factory.

</member>
        <member name="M:gemfire.PoolFactory.addLocator(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Adds a locator, given its host and port, to this factory.
The locator must be a server locator and will be used to discover other running
bridge servers and locators.
@param host is the host name or ip address that the locator is listening on.
@param port is the port that the locator is listening on.
@return a reference to <code>this</code>
@throws IllegalArgumentException if the <code>host</code> is an unknown host
according to {@link java.net.InetAddress#getByName} or if the port is outside
the valid range of [1..65535] inclusive.
@throws IllegalStateException if the locator has already been {@link #addServer added} to this factory.

</member>
        <member name="M:gemfire.PoolFactory.setServerGroup(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Configures the group which contains all the servers that this pool connects to.
@param group is the server group that this pool will connect to.
If the value is <code>null</code> or <code>""</code> then the pool connects to all servers.
@return a reference to <code>this</code></member>
        <member name="M:gemfire.PoolFactory.setPingInterval(System.Int32!System.Runtime.CompilerServices.IsLong)">
 The frequency with which servers must be pinged to verify that they are still alive.
 Each server will be sent a ping every <code>pingInterval</code> if there has not
 been any other communication with the server.

 These pings are used by the server to monitor the health of
 the client. Make sure that the <code>pingInterval</code> is less than the
 maximum time between pings allowed by the bridge server.
 @param pingInterval is the amount of time in milliseconds between
 pings.
 @return a reference to <code>this</code>
 @throws IllegalArgumentException if <code>pingInterval</code>
 is less than <code>0</code>.
 @see CacheServer#setMaximumTimeBetweenPings(int)

</member>
        <member name="M:gemfire.PoolFactory.setRetryAttempts(System.Int32)">
Set the number of times to retry a request after timeout/exception.
@param retryAttempts is the number of times to retry a request
after timeout/exception. -1 indicates that a request should be
tried against every available server before failing
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>idleTimout</code>
is less than <code>0</code>.

</member>
        <member name="M:gemfire.PoolFactory.setIdleTimeout(System.Int32!System.Runtime.CompilerServices.IsLong)">
Sets the amount of time a connection can be idle before expiring the connection.
If the pool size is greater than the minimum specified by
{@link PoolFactory#setMinConnections(int)}, connections which have been idle
for longer than the idleTimeout will be closed.
@param idleTimeout is the amount of time in milliseconds that an idle connection
should live before expiring. -1 indicates that connections should never expire.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>idleTimout</code>
is less than <code>0</code>.

</member>
        <member name="M:gemfire.PoolFactory.setMaxConnections(System.Int32)">
Sets the max number of client to server connections that the pool will create. If all of
the connections are in use, an operation requiring a client to server connection
will block until a connection is available.
@see #setFreeConnectionTimeout(int)
@param maxConnections is the maximum number of connections in the pool.
<code>-1</code> indicates that there is no maximum number of connections
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>maxConnections</code>
is less than <code>minConnections</code>.

</member>
        <member name="M:gemfire.PoolFactory.setMinConnections(System.Int32)">
Sets the minimum number of connections to keep available at all times.
When the pool is created, it will create this many connections.
If <code>0</code> then connections will not be made until an actual operation
is done that requires client-to-server communication.
@param minConnections is the initial number of connections
this pool will create.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>minConnections</code>
is less than <code>0</code>.

</member>
        <member name="M:gemfire.PoolFactory.setReadTimeout(System.Int32)">
Sets the number of milliseconds to wait for a response from a server before
timing out the operation and trying another server (if any are available).
@param timeout is the number of milliseconds to wait for a response from a server
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>timeout</code>
is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.PoolFactory.setSocketBufferSize(System.Int32)">
Sets the socket buffer size for each connection made in this pool.
Large messages can be received and sent faster when this buffer is larger.
Larger buffers also optimize the rate at which servers can send events
for client subscriptions.
@param bufferSize is the size of the socket buffers used for reading and
writing on each connection in this pool.
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>bufferSize</code>
is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.PoolFactory.setFreeConnectionTimeout(System.Int32)">
Sets the free connection timeout for this pool.
If the pool has a max connections setting, operations will block
if all of the connections are in use. The free connection timeout
specifies how long those operations will block waiting for
a free connection before receiving
an {@link AllConnectionsInUseException}. If max connections
is not set this setting has no effect.
@see #setMaxConnections(int)
@param connectionTimeout is the connection timeout in milliseconds
@return a reference to <code>this</code>
@throws IllegalArgumentException if <code>connectionTimeout</code>
is less than or equal to <code>0</code>.

</member>
        <member name="M:gemfire.QueryService.getCqServiceStatistics">
@nativeclient
Get statistics information for all CQs
@return the CqServiceStatistics
@endnativeclient

</member>
        <member name="M:gemfire.QueryService.stopCqs">
@nativeclient
Stops all the cqs on this client.
@endnativeclient

</member>
        <member name="M:gemfire.QueryService.executeCqs">
@nativeclient
Executes all the cqs on this client.
@endnativeclient

</member>
        <member name="M:gemfire.QueryService.getCq(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@nativeclient
Retrieve a CqQuery by name.
@return the CqQuery or NULLPTR if not found
@endnativeclient

</member>
        <member name="M:gemfire.QueryService.getCqs(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CqQuery&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@nativeclient
Retrieve  all registered CQs
@endnativeclient

</member>
        <member name="M:gemfire.QueryService.closeCqs">
@nativeclient
Close all CQs, and release resources
associated with executing CQs.
@endnativeclient

</member>
        <member name="M:gemfire.QueryService.newCq(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.CqAttributes&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
 @nativeclient
 Constructs a new named continuous query, represented by an instance of
 CqQuery. The CqQuery is not executed, however, until the execute method
 is invoked on the CqQuery. The name of the query will be used
 to identify this query in statistics archival.

 @param queryString the OQL query
 @param cqAttributes the CqAttributes
 @param isDurable true if the CQ is durable 
 @return the newly created CqQuery object
 @throws CqExistsException if a CQ by this name already exists on this
 client
 @throws IllegalArgumentException if queryString is null, or cqAttr is NULLPTR
 @throws IllegalStateException if this method is called from a cache
         server
 @throws QueryInvalidException if there is a syntax error in the query
 @throws CqException if failed to create cq, failure during creating  
         managing cq metadata info.
 @throws CqInvalidException if the query doesnot meet the CQ constraints.
   E.g.: Query string should refer only one region, join not supported.
         The query must be a SELECT statement.
         DISTINCT queries are not supported.
         Projections are not supported.
         Only one iterator in the FROM clause is supported, and it must be a region path. 
         Bind parameters in the query are not supported for the initial release.

 @endnativeclient

</member>
        <member name="M:gemfire.QueryService.newCq(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.CqAttributes&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
 @nativeclient
 Constructs a new named continuous query, represented by an instance of
 CqQuery. The CqQuery is not executed, however, until the execute method
 is invoked on the CqQuery. The name of the query will be used
 to identify this query in statistics archival.

 @param cqName the String name for this query
 @param queryString the OQL query
 @param cqAttributes the CqAttributes
 @param isDurable true if the CQ is durable 
 @return the newly created CqQuery object
 @throws CqExistsException if a CQ by this name already exists on this
 client
 @throws IllegalArgumentException if queryString is null, or cqAttr is NULLPTR
 @throws IllegalStateException if this method is called from a cache
         server
 @throws QueryInvalidException if there is a syntax error in the query
 @throws CqException if failed to create cq, failure during creating  
         managing cq metadata info.
 @throws CqInvalidException if the query doesnot meet the CQ constraints.
   E.g.: Query string should refer only one region, join not supported.
         The query must be a SELECT statement.
         DISTINCT queries are not supported.
         Projections are not supported.
         Only one iterator in the FROM clause is supported, and it must be a region path. 
         Bind parameters in the query are not supported for the initial release.

 @endnativeclient

</member>
        <member name="M:gemfire.QueryService.newQuery(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Get a new Query with the specified query string.

 @param querystr The query string with which to create a new Query.
 @returns A smart pointer to the Query.

</member>
        <member name="T:gemfire.QueryService">
@class QueryService QueryService.hpp
QueryService is the class obtained from a Cache.
A Query is created from a QueryService and executed on the server
returning a SelectResults which can be either a ResultSet or a StructSet.

</member>
        <member name="M:gemfire.CqServiceStatistics.numCqsOnClient">
Get number of CQs that are currently active or stopped. 
The CQs included in this number are either running or stopped (suspended).
Closed CQs are not included.
@return number of CQs on client.

</member>
        <member name="M:gemfire.CqServiceStatistics.numCqsStopped">
Get the number of stopped CQs currently.
@return number of CQs stopped.

</member>
        <member name="M:gemfire.CqServiceStatistics.numCqsClosed">
Get the total number of closed CQs. This is a cumulative number.
@return number of CQs closed.

</member>
        <member name="M:gemfire.CqServiceStatistics.numCqsCreated">
Get the total number of CQs created. This is a cumulative number.
@return number of CQs created.

</member>
        <member name="M:gemfire.CqServiceStatistics.numCqsActive">
Get the number of CQs currently active. 
Active CQs are those which are executing (in running state).
@return number of CQs

</member>
        <member name="T:gemfire.CqServiceStatistics">
 @class CqServiceStatistics CqServiceStatistics.hpp

 This class provides methods to get aggregate statistical information 
 about the CQs of a client.

</member>
        <member name="M:gemfire.Region.size">
Get the size of region. For native client regions, this will give the
number of entries in the local cache and not on the servers.

</member>
        <member name="M:gemfire.Region.selectValue(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Executes the query on the server based on the predicate and returns a single result value.
Valid only for a Native Client region.
@param predicate The query predicate (just the WHERE clause) or the entire query to execute.
@param timeout The time (in seconds) to wait for the response, optional.
       This should be less than or equal to 2^31/1000 i.e. 2147483.
@throws IllegalArgumentException If predicate is empty or timeout
        parameter is greater than 2^31/1000.
@throws QueryException if some query error occurred at the server, or more than one result items are available.
@throws NotConnectedException if a server connection error occurs.
        For pools configured with locators, if no locators are available, the cause
        of NotConnectedException is set to NoAvailableLocatorsException.
@throws MessageExcepton If the message received from server could not be
        handled. This will be the case when an unregistered typeId is
        received in the reply or reply is not well formed.
        More information can be found in the log.
@throws TimeoutException if operation timed out
@throws CacheClosedException if the cache has been closed
@returns A smart pointer to the single ResultSet or StructSet item, or NULLPTR of no results are available.

</member>
        <member name="M:gemfire.Region.existsValue(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Executes the query on the server based on the predicate and returns whether any result exists.
Valid only for a Native Client region.
@param predicate The query predicate (just the WHERE clause) or the entire query to execute.
@param timeout The time (in seconds) to wait for the response, optional.
       This should be less than or equal to 2^31/1000 i.e. 2147483.
@throws IllegalArgumentException If predicate is empty or timeout
        parameter is greater than 2^31/1000.
@throws QueryException if some query error occurred at the server.
@throws NotConnectedException if a server connection error occurs.
        For pools configured with locators, if no locators are available, the cause
        of NotConnectedException is set to NoAvailableLocatorsException.
@throws MessageExcepton If the message received from server could not be
        handled. This will be the case when the reply is not well formed.
        More information can be found in the log.
@throws TimeoutException if operation timed out
@throws CacheClosedException if the cache has been closed
@returns true if the result size is non-zero, false otherwise.

</member>
        <member name="M:gemfire.Region.query(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Executes the query on the server based on the predicate.
 Valid only for a Native Client region.

 @param predicate The query predicate (just the WHERE clause) or the entire query to execute.
 @param timeout The time (in seconds) to wait for the query response, optional.
        This should be less than or equal to 2^31/1000 i.e. 2147483.

 @throws IllegalArgumentException If predicate is empty or timeout
         parameter is greater than 2^31/1000.
 @throws QueryException if some query error occurred at the server.
 @throws CacheServerException If an exception is received from the Java cache server.
 @throws NotConnectedException if a server connection error occurs.
         For pools configured with locators, if no locators are available, the cause
         of NotConnectedException is set to NoAvailableLocatorsException.
 @throws MessageExcepton If the message received from server could not be
         handled. This will be the case when an unregistered typeId is
         received in the reply or reply is not well formed.
         More information can be found in the log.
 @throws TimeoutException if operation timed out
 @throws CacheClosedException if the cache has been closed

 @returns A smart pointer to the SelectResults which can either be a ResultSet or a StructSet.

</member>
        <member name="M:gemfire.Region.unregisterRegex(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Unregisters a regular expression to stop getting updates for keys from the server.
 Valid only for a Native Client region when client notification
 ( {@link AttributesFactory::setClientNotification} ) is true.

 @param regex The regular expression string.

 @throws IllegalArgumentException If regex is empty.
 @throws IllegalStateException If not previously registered this regular expression string.
 @throws RedundancyException if the redundancy level specified using
 {@link CacheAttributesFactory::setRedundancyLevel} is not satisfied.
 @throws UnsupportedOperationException If the region is not a Native Client region or
 {@link AttributesFactory::setClientNotification} is false.
 @throws CacheServerException If an exception is received from the Java cache server.
 @throws NotConnectedException if it is not connected to the cache because the client
         cannot establish usable connections to any of the servers given to it
         For pools configured with locators, if no locators are available, the cause
         of NotConnectedException is set to NoAvailableLocatorsException.
 @throws RegionDestroyedException If region destroy is pending.
 @throws UnknownException For other exceptions.
 @throws TimeoutException if operation timed out

</member>
        <member name="M:gemfire.Region.registerRegex(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,gemfire.SharedPtr&lt;gemfire.VectorOfCacheableKey&gt;,System.Boolean,System.Boolean)">
 Registers a regular expression to match with keys to get updates from the server.
 Valid only for a Native Client region when client notification
 ( {@link AttributesFactory::setClientNotification} ) is true.

 @param regex The regular expression string.
 @param isDurable flag to indicate whether this is a durable registration
 @param resultKeys If non-NULLPTR then the keys that match the regular
   expression on the server are returned. The vector is cleared at the
   start to discard any existing keys in the vector.
 @param getInitialValues true to populate the cache with values of the keys
   that were registered on the server
 @param receiveValues whether to act like notify-by-subscription is set

 @throws IllegalArgumentException If regex is empty.
 @throws IllegalStateException If already registered interest for all keys.
 @throws EntryNotFoundException If an exception occurs while obtaining
   values from server after register interest is complete. The actual cause
   of the exception can be obtained using <code>Exception::getCause</code>.
   If an application wants to undo the registration on server, or take
   some other steps for the incomplete cache population then this is
   the exception that should be caught.
 @throws RedundancyException if the redundancy level specified using
 {@link CacheAttributesFactory::setRedundancyLevel} is not satisfied.
   Application can catch this exception and proceed if working with
   insufficient secondaries is acceptable; the registration is performed
   on the available secondaries before exception is thrown.
 @throws UnsupportedOperationException If the region is not a Native Client region or
 {@link AttributesFactory::setClientNotification} is false.
 @throws CacheServerException If an exception is received from the Java cache server.
 @throws NotConnectedException if it is not connected to the cache because the client
         cannot establish usable connections to any of the servers given to it
         For pools configured with locators, if no locators are available, the cause
         of NotConnectedException is set to NoAvailableLocatorsException.
 @throws MessageExcepton If the message received from server could not be
         handled. This will be the case when an unregistered typeId is
         received in the reply or reply is not well formed.
         More information can be found in the log.
 @throws RegionDestroyedException If region destroy is pending.
 @throws UnknownException For other exceptions.
 @throws TimeoutException if operation timed out

</member>
        <member name="M:gemfire.Region.unregisterAllKeys">
 Registers to get updates for all keys from the server.
 Valid only for a Native Client region when client notification
 ( {@link AttributesFactory::setClientNotification} ) is true.

 @throws IllegalStateException If not previously registered all keys.
 @throws RedundancyException if the redundancy level specified using
 {@link CacheAttributesFactory::setRedundancyLevel} is not satisfied.
 @throws UnsupportedOperationException If the region is not a Native Client region or
 {@link AttributesFactory::setClientNotification} is false.
 @throws CacheServerException If an exception is received from the Java cache server.
 @throws NotConnectedException if it is not connected to the cache because the client
         cannot establish usable connections to any of the servers given to it
         For pools configured with locators, if no locators are available, the cause
         of NotConnectedException is set to NoAvailableLocatorsException.
 @throws RegionDestroyedException If region destroy is pending.
 @throws UnknownException For other exceptions.
 @throws TimeoutException if operation timed out

</member>
        <member name="M:gemfire.Region.registerAllKeys(System.Boolean,gemfire.SharedPtr&lt;gemfire.VectorOfCacheableKey&gt;,System.Boolean,System.Boolean)">
 Registers to get updates for all keys from the server.
 Valid only for a Native Client region when client notification
 ( {@link AttributesFactory::setClientNotification} ) is true.

 @param isDurable flag to indicate whether this is a durable registration
 @param resultKeys If non-NULLPTR then all the keys on the server that got
   registered are returned. The vector is cleared at the start to discard
   any existing keys in the vector.
 @param getInitialValues true to populate the cache with values of all keys
   from the server
 @param receiveValues whether to act like notify-by-subscription is set

 @throws EntryNotFoundException If an exception occurs while obtaining
   values from server after register interest is complete. The actual cause
   of the exception can be obtained using <code>Exception::getCause</code>.
   If an application wants to undo the registration on server, or take
   some other steps for the incomplete cache population then this is
   the exception that should be caught.
 @throws RedundancyException if the redundancy level specified using
 {@link CacheAttributesFactory::setRedundancyLevel} is not satisfied.
   Application can catch this exception and proceed if working with
   insufficient secondaries is acceptable; the registration is performed
   on the available secondaries before exception is thrown.
 @throws UnsupportedOperationException If the region is not a Native Client region or
 {@link AttributesFactory::setClientNotification} is false.
 @throws CacheServerException If an exception is received from the Java cache server.
 @throws NotConnectedException if it is not connected to the cache because the client
         cannot establish usable connections to any of the servers given to it
         For pools configured with locators, if no locators are available, the cause
         of NotConnectedException is set to NoAvailableLocatorsException.
 @throws RegionDestroyedException If region destroy is pending.
 @throws UnknownException For other exceptions.
 @throws TimeoutException if operation timed out

</member>
        <member name="M:gemfire.Region.unregisterKeys(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Unregisters an array of keys to stop getting updates for them.
 Valid only for a Native Client region when client notification
 ( {@link AttributesFactory::setClientNotification} ) is true.

 @param keys the array of keys

 @throws IllegalArgumentException If the array of keys is empty.
 @throws IllegalStateException If no keys were previously registered.
 @throws RedundancyException if the redundancy level specified using
 {@link CacheAttributesFactory::setRedundancyLevel} is not satisfied.
 @throws UnsupportedOperationException If the region is not a Native Client region or
 {@link AttributesFactory::setClientNotification} is false.
 @throws CacheServerException If an exception is received from the Java cache server.
 @throws NotConnectedException if it is not connected to the cache because the client
         cannot establish usable connections to any of the servers given to it
         For pools configured with locators, if no locators are available, the cause
         of NotConnectedException is set to NoAvailableLocatorsException.
 @throws RegionDestroyedException If region destroy is pending.
 @throws UnknownException For other exceptions.
 @throws TimeoutException if operation timed out

</member>
        <member name="M:gemfire.Region.registerKeys(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,System.Boolean)">
 Registers an array of keys for getting updates from the server.
 Valid only for a Native Client region when client notification
 ( {@link AttributesFactory::setClientNotification} ) is true.

 @param keys the array of keys
 @param isDurable flag to indicate whether this is a durable registration
 @param getInitialValues true to populate the cache with values of the keys
   that were registered on the server
 @param receiveValues whether to act like notify-by-subscription is set

 @throws IllegalArgumentException If the array of keys is empty.
 @throws IllegalStateException If already registered interest for all keys.
 @throws EntryNotFoundException If an exception occurs while obtaining
   values from server after register interest is complete. The actual cause
   of the exception can be obtained using <code>Exception::getCause</code>.
   If an application wants to undo the registration on server, or take
   some other steps for the incomplete cache population then this is
   the exception that should be caught.
 @throws RedundancyException if the redundancy level specified using
 {@link CacheAttributesFactory::setRedundancyLevel} is not satisfied.
   Application can catch this exception and proceed if working with
   insufficient secondaries is acceptable; the registration is performed
   on the available secondaries before exception is thrown.
 @throws UnsupportedOperationException If the region is not a Native Client region or
 {@link AttributesFactory::setClientNotification} is false.
 @throws CacheServerException If an exception is received from the Java cache server.
 @throws NotConnectedException if it is not connected to the cache because the client
         cannot establish usable connections to any of the servers given to it
         For pools configured with locators, if no locators are available, the cause
         of NotConnectedException is set to NoAvailableLocatorsException.
 @throws RegionDestroyedException If region destroy is pending.
 @throws UnknownException For other exceptions.
 @throws TimeoutException if operation timed out

</member>
        <member name="M:gemfire.Region.getInterestListRegex(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CacheableString&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the list of regular expresssions on which this client is
interested and will be notified of changes.
@throws UnsupportedOperationException if the region's scope is ScopeType::LOCAL.

</member>
        <member name="M:gemfire.Region.getInterestList(gemfire.VectorOfCacheableKey*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the list of keys on which this client is interested and will be
notified of changes.
@throws UnsupportedOperationException if the region's scope is ScopeType::LOCAL.

</member>
        <member name="M:gemfire.Region.containsKeyOnServer(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The cache of the server, to which it is connected with, is searched
for the key to see if the key is present.
@throws UnsupportedOperationException if the region's scope is ScopeType::LOCAL.

</member>
        <member name="M:gemfire.Region.containsKey(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Only the client's cache is searched for the key. It does not go to the java server
to which it is connected with.

</member>
        <member name="M:gemfire.Region.containsValueForKey(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This operations checks for the value in the local cache .
It is not propagated to the Gemfire cache server
to which it is connected.

</member>
        <member name="M:gemfire.Region.getRegionService">
Returns the <code>cache</code> associated with this region.
@return the cache

</member>
        <member name="M:gemfire.Region.getCache">
Returns the <code>cache</code> associated with this region.
@return the cache
@deprecated as of NativeClient 3.5, use {@link Region#getRegionService} instead.

</member>
        <member name="M:gemfire.Region.values(gemfire.VectorOfCacheable*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return all values in the local process for this region. No value is included
for entries that are invalidated.

</member>
        <member name="M:gemfire.Region.serverKeys(gemfire.VectorOfCacheableKey*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the set of keys defined in the server process associated to this
client and region. If a server has the region defined as a mirror, then
this will be the entire keyset for the region across all PEER in the
distributed system.
The vector v will contain only the server keys. Any prior contents in the
vector will be removed.
@throws CacheServerException If an exception is received from the Gemfire cache server.
        Only for Native Client regions.
@throws NotConnectedException if it is not connected to the cache because the client
        cannot establish usable connections to any of the servers given to it
        For pools configured with locators, if no locators are available, the cause
        of NotConnectedException is set to NoAvailableLocatorsException.
@throws MessageExcepton If the message received from server could not be
        handled. This will be the case when an unregistered typeId is
        received in the reply or reply is not well formed.
        More information can be found in the log.
@throws TimeoutException if there is a timeout getting the keys
@throws UnsupportedOperationException if the member type is not CLIENT
                                      or region is not a native client one.

</member>
        <member name="M:gemfire.Region.keys(gemfire.VectorOfCacheableKey*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return all the keys in the local process for this region. This includes
keys for which the entry is invalid.

</member>
        <member name="M:gemfire.Region.getEntry(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the meta-object RegionEntry for key.
    * @throws IllegalArgumentException, RegionDestroyedException.

</member>
        <member name="M:gemfire.Region.subregions(System.Boolean!System.Runtime.CompilerServices.IsConst,gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.Region&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Populates the passed in VectorOfRegion with subregions of the current region
    * @param recursive determines whether the method recursively fills in subregions
    * @param[out] sr subregions
    * @throws RegionDestroyedException

</member>
        <member name="M:gemfire.Region.createSubregion(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.RegionAttributes&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a subregion with the specified attributes 
</member>
        <member name="M:gemfire.Region.getSubregion(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns the subregion identified by the path, NULLPTR if no such subregion 
</member>
        <member name="M:gemfire.Region.localDestroyRegion(gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys the whole region and provides a user-defined parameter
    * object to any <code>CacheWriter</code> invoked in the process.
    * Destroy cascades to all entries
    * and subregions. After the destroy, this region object cannot be used
    * any more. Any attempt to use this region object will get a
    * <code>RegionDestroyedException</code> exception. The region destroy is not
    * distributed to other caches.
    *
    * @param aCallbackArgument a user-defined parameter to pass to callback events
    *        triggered by this call.
    *        Can be NULLPTR. If it is sent on the wire, it has to be Serializable.
    * @throws CacheWriterException if CacheWriter aborts the operation; if this
    *         occurs some subregions may have already been successfully destroyed.
    * @throws CacheListenerException if CacheListener throws an exception; if this
    *         occurs some subregions may have already been successfully invalidated
    *
    * @see  localInvalidateRegion

</member>
        <member name="M:gemfire.Region.localClear(gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes all entries from this region and provides a user-defined parameter
object to any <code>CacheWriter</code> or <code>CacheListener</code>
invoked in the process. Clear will not be distributed to other caches.
@see CacheListener#afterRegionClear
@see CacheWriter#beforeRegionClear

</member>
        <member name="M:gemfire.Region.clear(gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes all entries from this region and provides a user-defined parameter
object to any <code>CacheWriter</code> or <code>CacheListener</code>
invoked in the process.
@see CacheListener#afterRegionClear
@see CacheWriter#beforeRegionClear

</member>
        <member name="M:gemfire.Region.destroyRegion(gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Destroys the whole region and provides a user-defined parameter
    * object to any <code>CacheWriter</code> invoked in the process.
    * Destroy cascades to all entries
    * and subregions. After the destroy, this region object cannot be used
    * any more. Any attempt to use this region object will get a
    * <code>RegionDestroyedException</code> exception.
    *
    * The region destroy not only destroys the local region but also destroys the
    * server region. However, if server region destroy fails throwing back
    * <code>CacheServerException</code> or security exception,
    * the local region is still destroyed.
    *
    * @param aCallbackArgument a user-defined parameter to pass to callback events
    *        triggered by this call.
    *        Can be NULLPTR. If it is sent on the wire, it has to be Serializable.
    * @throws CacheWriterException if CacheWriter aborts the operation; if this
    *         occurs some subregions may have already been successfully destroyed.
    * @throws CacheListenerException if CacheListener throws an exception; if this
    *         occurs some subregions may have already been successfully invalidated
    * @throws CacheServerException If an exception is received from the Java cache server.
    *         Only for Native Client regions.
    * @throws NotConnectedException if not connected to the gemfire system because the client
    *         cannot establish usable connections to any of the servers given to it.
    *         For pools configured with locators, if no locators are available, the cause
    *         of NotConnectedException is set to NoAvailableLocatorsException.
    * @throws MessageExcepton If the message received from server could not be
    *         handled. This will be the case when an unregistered typeId is
    *         received in the reply or reply is not well formed.
    *         More information can be found in the log.
    * @throws TimeoutException if operation timed out
    * @see  invalidateRegion

</member>
        <member name="M:gemfire.Region.localInvalidateRegion(gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Invalidates this region. The invalidation will cascade to
    * all the subregions and cached entries. After
    * the <code>invalidateRegion</code> , the region and the entries in it still
    * exist. In order to remove all the entries and the region,
    * <code>destroyRegion</code> should be used. The region invalidate will not be distributed
    * to other caches
    *
    * @param aCallbackArgument a user-defined parameter to pass to callback events
    *        triggered by this method.
    *        Can be NULLPTR. If it is sent on the wire, it has to be Serializable.
    * @throws CacheListenerException if CacheListener throws an exception; if this
    *         occurs some subregions may have already been successfully invalidated
    * @throws RegionDestroyedException if the region is no longer valid
    * @see   destroyRegion
    * @see   CacheListener::afterRegionInvalidate


</member>
        <member name="M:gemfire.Region.invalidateRegion(gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Invalidates this region. The invalidation will cascade to
    * all the subregions and cached entries. After
    * the <code>invalidateRegion</code> , the region and the entries in it still
    * exist. In order to remove all the entries and the region,
    * <code>destroyRegion</code> should be used.
    *
    * @param aCallbackArgument a user-defined parameter to pass to callback events
    *        triggered by this method.
    *        Can be NULLPTR. If it is sent on the wire, it has to be Serializable.
    * @throws CacheListenerException if CacheListener throws an exception; if this
    *         occurs some subregions may have already been successfully invalidated
    * @throws RegionDestroyedException if the region is no longer valid
    * @see   destroyRegion
    * @see   CacheListener::afterRegionInvalidate
    * This operation is not distributed.

</member>
        <member name="M:gemfire.Region.getAttributesMutator">
Return the a mutator object for changing a subset of the region
    * attributes.
    * @throws RegionDestroyedException.

</member>
        <member name="M:gemfire.Region.getAttributes">
Return the RegionAttributes for this region.

</member>
        <member name="M:gemfire.Region.getParentRegion">
Returns the parent region, or NULLPTR if a root region.
    * @throws RegionDestroyedException

</member>
        <member name="M:gemfire.Region.getFullPath">
return the full path of the region as can be used to lookup the
    * region from Cache::getRegion. The storage is backed by the region.

</member>
        <member name="M:gemfire.Region.getName">
@brief Public Methods

return single name of region. The storage is backed by the region. 
</member>
        <member name="T:gemfire.Region">
 @class Region Region.hpp

 This class manages subregions and cached data. Each region
 can contain multiple subregions and entries for data.
 Regions provide a hierachical name space
 within the cache. Also, a region can be used to group cached
 objects for management purposes.

 Entries managed by the region are key-value pairs. A set of region attributes
 is associated with the region when it is created.

 The Region interface basically contains two set of APIs: Region management
 APIs and (potentially) distributed operations on entries. Non-distributed
 operations on entries  are provided by <code>RegionEntry</code>.

 Each <code>Cache</code> defines regions called the root regions.
 User applications can use the root regions to create subregions
 for isolated name space and object grouping.

 A region's name can be any String, except that it should not contain
 the region name separator, a forward slash (/).

 <code>Regions</code>  can be referenced by a relative path name from any region
 higher in the hierarchy in {@link Region::getSubregion}. You can get the relative
 path from the root region with {@link Region::getFullPath}. The name separator
 is used to concatenate all the region names together from the root, starting
 with the root's subregions.

 @see RegionAttributes

</member>
        <member name="M:gemfire.Query.isCompiled">
 Check whether the Query is compiled - client side query compilation
 is not supported.

 @throws UnsupportedOperationException because this is not currently supported.

</member>
        <member name="M:gemfire.Query.compile">
 Compile the Query - client side query compilation is not supported.

 @throws UnsupportedOperationException because this is not currently supported.

</member>
        <member name="M:gemfire.Query.getQueryString">
 Get the query string provided when a new Query was created from a QueryService.

 @returns The query string.

</member>
        <member name="M:gemfire.Query.execute(gemfire.SharedPtr&lt;gemfire.CacheableVector&gt;,System.UInt32)">
Executes the parameterized OQL Query on the cache server and returns the results.

@param paramList The query parameters list
@param timeout The time (in seconds) to wait for query response, optional.
      This should be less than or equal to 2^31/1000 i.e. 2147483.

@throws IllegalArgumentException if timeout parameter is greater than 2^31/1000.
@throws QueryException if some query error occurred at the server.
@throws IllegalStateException if some error occurred.
@throws NotConnectedException if no java cache server is available.  For pools
configured with locators, if no locators are available, the cause of NotConnectedException
is set to NoAvailableLocatorsException.
returns A smart pointer to the SelectResults which can either be a ResultSet or a StructSet.

</member>
        <member name="M:gemfire.Query.execute(System.UInt32)">
 Executes the OQL Query on the cache server and returns the results.

 @param timeout The time (in seconds) to wait for query response, optional.
        This should be less than or equal to 2^31/1000 i.e. 2147483.

 @throws IllegalArgumentException if timeout parameter is greater than 2^31/1000.
 @throws QueryException if some query error occurred at the server.
 @throws IllegalStateException if some error occurred.
 @throws NotConnectedException if no java cache server is available.  For pools
 configured with locators, if no locators are available, the cause of NotConnectedException
 is set to NoAvailableLocatorsException.
 @returns A smart pointer to the SelectResults which can either be a ResultSet or a StructSet.

</member>
        <member name="T:gemfire.Query">
 @class Query Query.hpp

 A Query is obtained from a QueryService which in turn is obtained from the Cache.
 This can be executed to return SelectResults which can be either a ResultSet or a StructSet.

 This class is intentionally not thread-safe. So multiple threads should not
 operate on the same <code>Query</code> object concurrently rather should
 have their own <code>Query</code> objects.

</member>
        <member name="M:gemfire.AttributesMutator.setCacheWriter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets cache writer for region. The previous cache writer will be replaced with 
   * a writer created using the factory function provided in the given library.
   * @param libpath path of the library containing cache writer factory function. 
   * @param factoryFuncName factory function for creating cache writer.

</member>
        <member name="M:gemfire.AttributesMutator.setCacheWriter(gemfire.SharedPtr&lt;gemfire.CacheWriter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets cache writer for region. The previous cache writer will be replaced with 
   * <code>aWriter</code>.
   * @param aWriter cache writer

</member>
        <member name="M:gemfire.AttributesMutator.setCacheLoader(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets cache loader for region. The previous cache loader will be replaced with 
   * a loader created using the factory function provided in the given library.
   * @param libpath path of the library containing cache loader factory function. 
   * @param factoryFuncName factory function for creating cache loader.

</member>
        <member name="M:gemfire.AttributesMutator.setCacheLoader(gemfire.SharedPtr&lt;gemfire.CacheLoader&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets cache loader for region. The previous cache loader will be replaced with 
   * <code>aLoader</code>.
   * @param aLoader cache loader

</member>
        <member name="M:gemfire.AttributesMutator.setCacheListener(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets cache listener for region. The previous cache listener will be replaced with 
   * a listener created using the factory function provided in the given library.
   * @param libpath path of the library containing cache listener factory function. 
   * @param factoryFuncName factory function for creating cache listener.

</member>
        <member name="M:gemfire.AttributesMutator.setCacheListener(gemfire.SharedPtr&lt;gemfire.CacheListener&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets cache listener for region. The previous cache listener will be replaced with 
   * <code>aListener</code>.
   * @param aListener cache listener

</member>
        <member name="M:gemfire.AttributesMutator.setLruEntriesLimit(System.UInt32)">
Sets the Maximum entry count in the region before LRU eviction.
   * @param entriesLimit the number of entries to allow.
   * @return the previous value.
   * @throw IllegalStateException if the new entriesLimit changes LRU from
   *   disabled to enabled or enabled to disabled.

</member>
        <member name="M:gemfire.AttributesMutator.setRegionTimeToLiveAction(gemfire.ExpirationAction.Action)">
Set the timeToLive Action for the region itself.
   * @param action the timeToLive ExpirationAction::Action for this region.
   * @return the previous value.

</member>
        <member name="M:gemfire.AttributesMutator.setRegionTimeToLive(System.Int32)">
Sets the timeToLive duration for the region itself.
   * @param timeToLive the ExpirationAttributes for this region timeToLive
   * @return the previous value.
   * @throw IllegalStateException if the new timeToLive changes region expiration from
   *   disabled to enabled or enabled to disabled.

</member>
        <member name="M:gemfire.AttributesMutator.setRegionIdleTimeoutAction(gemfire.ExpirationAction.Action)">
Set the idleTimeout Action for the region itself.
   * @param action the idleTimeout ExpirationAction::Action for this region.
   * @return the previous value.

</member>
        <member name="M:gemfire.AttributesMutator.setRegionIdleTimeout(System.Int32)">
Sets the idleTimeout duration for the region itself.
   * @param idleTimeout the ExpirationAttributes for this region idleTimeout
   * @return the previous value.
   * @throw IllegalStateException if the new idleTimeout changes region expiration from
   *   disabled to enabled or enabled to disabled.

</member>
        <member name="M:gemfire.AttributesMutator.setEntryTimeToLiveAction(gemfire.ExpirationAction.Action)">
Set the timeToLive Action for region entries.
   * @param action the timeToLive ExpirationAction::Action for entries in this region.
   * @return the previous value.

</member>
        <member name="M:gemfire.AttributesMutator.setEntryTimeToLive(System.Int32)">
Sets the timeToLive duration for region entries.
   * @param timeToLive the timeToLive in seconds for entries in this region.
   * @return the previous value.
   * @throw IllegalStateException if the new timeToLive changes entry expiration from
   *   disabled to enabled or enabled to disabled.

</member>
        <member name="M:gemfire.AttributesMutator.setEntryIdleTimeoutAction(gemfire.ExpirationAction.Action)">
Set the idleTimeout Action for region entries.
   * @param action the idleTimeout ExpirationAction::Action for entries in this region.
   * @return the previous value.

</member>
        <member name="M:gemfire.AttributesMutator.setEntryIdleTimeout(System.Int32)">
Sets the idleTimeout duration for region entries.
   * @param idleTimeout the idleTimeout in seconds for entries in this region.
   * @return the previous value.
   * @throw IllegalStateException if the new idleTimeout changes entry expiration from
   *   disabled to enabled or enabled to disabled.

</member>
        <member name="M:gemfire.AttributesMutator.#ctor(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Internal constructor. Use Region::getAttributesMutator() to acquire the
   * mutator for a region. 
</member>
        <member name="M:gemfire.RegionEntry.#ctor(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief constructors
created by region

</member>
        <member name="M:gemfire.RegionEntry.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.RegionEntry.getStatistics(gemfire.SharedPtr&lt;gemfire.CacheStatistics&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the statistics for this entry.
     *
     * @return the CacheStatistics for this entry
     * @throws StatisticsDisabledException if statistics have been disabled for
     * this region

</member>
        <member name="M:gemfire.RegionEntry.getRegion(gemfire.SharedPtr&lt;gemfire.Region&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the region that contains this entry.
     *
     * @return the Region that contains this entry

</member>
        <member name="M:gemfire.RegionEntry.getValue">
Returns the value of this entry in the local cache. Does not invoke
     * a <code>CacheLoader</code>,
     *
     * @return the value or <code>NULLPTR</code> if this entry is invalid

</member>
        <member name="M:gemfire.RegionEntry.getKey">
Returns the key for this entry.
     *
     * @return the key for this entry

</member>
        <member name="T:gemfire.CacheStatistics">
 @class CacheStatistics CacheStatistics.hpp

 Defines common statistical information
 for both the region and its entries. All of these methods may throw a
 CacheClosedException, RegionDestroyedException, or EntryDestroyedException.

 @see Region::getStatistics
 @see RegionEntry::getStatistics

</member>
        <member name="M:gemfire.GemFireCache.getPdxIgnoreUnreadFields">
Returns whther Cache saves unread fields for Pdx types.
Currently c++ don't support pdx types, thus it is for internal purpose only

</member>
        <member name="M:gemfire.GemFireCache.getDistributedSystem">
Returns the distributed system that this cache was
{@link CacheFactory::createCacheFactory created} with.

</member>
        <member name="M:gemfire.GemFireCache.initializeDeclarativeCache(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Initializes the cache from an xml file

 @param cacheXml
        Valid cache.xml file

</member>
        <member name="M:gemfire.GemFireCache.getName">
@brief public methods

Returns the name of this cache.
   * @return the string name of this cache

</member>
        <member name="M:gemfire.RegionService.rootRegions(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.Region&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Returns a set of root regions in the cache. This set is a snapshot and
 is not backed by the Cache. The vector passed in is cleared and the
 regions are added to it.

 @param regions the returned set of
 regions

</member>
        <member name="M:gemfire.RegionService.getQueryService">
Gets the QueryService from which a new Query can be obtained.
@returns A smart pointer to the QueryService.

</member>
        <member name="M:gemfire.RegionService.getRegion(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Look up a region with the name.
   *
   * @param name the region's name, such as <code>root</code>.
   * @returns region, or NULLPTR if no such region exists.

</member>
        <member name="M:gemfire.RegionService.close">
Terminates this object cache and releases all the local resources.
After this cache is closed, any further
method call on this cache or any region object will throw
<code>CacheClosedException</code>, unless otherwise noted.
If RegionService is created from {@link Cache#createAuthenticatedView" }, then it clears user related security data.
@param keepalive whether to keep a durable CQ kept alive for this user.
@throws CacheClosedException,  if the cache is already closed.

</member>
        <member name="M:gemfire.RegionService.isClosed">
@brief public methods

 Indicates if this cache has been closed.
 After a new cache object is created, this method returns false;
 After the close is called on this cache object, this method
 returns true.

 @return true, if this cache is closed; false, otherwise

</member>
        <member name="M:gemfire.RegionAttributes.getPersistenceManager">
Gets the persistence for the region.
   * @return  a pointer that points to the region's ,
   * <code>PersistenceManager</code> , NULLPTR if there is no PersistenceManager for this
   * region.

</member>
        <member name="M:gemfire.RegionAttributes.getPersistenceProperties">
This method returns the properties pointer which is set for persistence.

</member>
        <member name="M:gemfire.RegionAttributes.getPersistenceFactory">
This method returns the symbol name of the factory function from which
the persistence will be created on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getPersistenceLibrary">
This method returns the path of the library from which
the factory function will be invoked on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getClientNotificationEnabled">
This method returns the setting of client notification

</member>
        <member name="M:gemfire.RegionAttributes.getEndpoints">
This method returns the list of servername:portno separated by comma

</member>
        <member name="M:gemfire.RegionAttributes.validateSerializableAttributes">
throws IllegalStateException if the attributes are not suited for serialization
   * such as those that have a cache callback (listener, loader, or writer) set
   * directly instead of through the string value setters.

</member>
        <member name="M:gemfire.RegionAttributes.op_Inequality(gemfire.RegionAttributes!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return true if any of the attributes are not equal to those of other. 
</member>
        <member name="M:gemfire.RegionAttributes.op_Equality(gemfire.RegionAttributes!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return true if all the attributes are equal to those of other. 
</member>
        <member name="M:gemfire.RegionAttributes.getPartitionResolverFactory">
This method returns the symbol name of the factory function from which
the loader will be created on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getPartitionResolverLibrary">
This method returns the path of the library from which
the factory function will be invoked on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getCacheWriterFactory">
This method returns the symbol name of the factory function from which
the loader will be created on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getCacheWriterLibrary">
This method returns the path of the library from which
the factory function will be invoked on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getCacheListenerFactory">
This method returns the symbol name of the factory function from which
the loader will be created on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getCacheListenerLibrary">
This method returns the path of the library from which
the factory function will be invoked on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getCacheLoaderFactory">
This method returns the symbol name of the factory function from which
the loader will be created on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.getCacheLoaderLibrary">
This method returns the path of the library from which
the factory function will be invoked on a cache server.

</member>
        <member name="M:gemfire.RegionAttributes.typeId">
Return type id for serialization. 
</member>
        <member name="M:gemfire.RegionAttributes.classId">
Return class id for serialization. 
</member>
        <member name="M:gemfire.RegionAttributes.createDeserializable">
Return an empty instance for deserialization. 
</member>
        <member name="M:gemfire.RegionAttributes.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Initialize members from serialized data. 
</member>
        <member name="M:gemfire.RegionAttributes.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Serialize out to stream 
</member>
        <member name="M:gemfire.RegionAttributes.getPoolName">
Returns the name of the pool attached to the region.


TODO
   * Returns the name of the {@link Pool} that this region
   * will use to communicate with servers, if any.
   * @return the name of the client-server {@link Pool}

</member>
        <member name="M:gemfire.RegionAttributes.getLruEvictionAction">
Returns the ExpirationAction used for LRU Eviction, default is LOCAL_DESTROY.

</member>
        <member name="M:gemfire.RegionAttributes.getDiskPolicy">
Returns the disk policy type of the region.
   *
   * @return the <code>DiskPolicyType::PolicyType</code>, default is DiskPolicyType::NONE.

</member>
        <member name="M:gemfire.RegionAttributes.getLruEntriesLimit">
Returns the maximum number of entries this cache will hold before
using LRU eviction. A return value of zero, 0, indicates no limit.

</member>
        <member name="M:gemfire.RegionAttributes.getConcurrencyLevel">
Returns the concurrencyLevel of the entry's local cache.
   * @return the concurrencyLevel
   * @see AttributesFactory

</member>
        <member name="M:gemfire.RegionAttributes.getLoadFactor">
Returns the load factor of the entry's local cache.
   * @return the load factor of the entry's local cache

</member>
        <member name="M:gemfire.RegionAttributes.getInitialCapacity">
Returns the initial capacity of the entry's local cache.
   * @return the initial capacity of the entry's local cache

</member>
        <member name="M:gemfire.RegionAttributes.getCachingEnabled">
If true, this region will store data in the current process.
@return true or false, indicating cachingEnabled state.

</member>
        <member name="M:gemfire.RegionAttributes.getScope">
Returns the scope of the region.
   *
   * @return the region's <code>ScopeType::Scope</code></member>
        <member name="M:gemfire.RegionAttributes.getEntryIdleTimeout">
Gets the <code>idleTimeout</code> expiration attributes for entries in this region.
   * @return the idleTimeout expiration attributes for entries in this region

</member>
        <member name="M:gemfire.RegionAttributes.getEntryTimeToLive">
Gets the <code>timeToLive</code> expiration attributes for entries in this region.
   * @return the timeToLive expiration attributes for entries in this region

</member>
        <member name="M:gemfire.RegionAttributes.getRegionIdleTimeout">
Gets the idleTimeout expiration attributes for the region as a whole.
   *
   * @return the IdleTimeout expiration attributes for this region

</member>
        <member name="M:gemfire.RegionAttributes.getRegionTimeToLive">
Gets the <code>timeToLive</code> expiration attributes for the region as a whole.
   * @return the timeToLive expiration attributes for this region

</member>
        <member name="M:gemfire.RegionAttributes.getPartitionResolver">
Gets the partition resolver for the partition region.
   * @return  a pointer that points to the region's ,
   * <code>PartitionResolver</code> , NULLPTR if there is no PartitionResolver defined
   * for this region.

</member>
        <member name="M:gemfire.RegionAttributes.getCacheListener">
Gets the cache listener for the region.
   * @return  a pointer that points to the region's ,
   * <code>CacheListener</code> , NULLPTR if there is no CacheListener defined
   * for this region.

</member>
        <member name="M:gemfire.RegionAttributes.getCacheWriter">
Gets the cache writer for the region.
   * @return  a pointer that points to the region's ,
   * <code>CacheWriter</code> , NULLPTR if there is no CacheWriter for this
   * region

</member>
        <member name="M:gemfire.RegionAttributes.getCacheLoader">
@brief public static methods

Gets the cache loader for the region.
   * @return  a pointer that points to the region's ,
   * <code>CacheLoader</code> , NULLPTR if there is no CacheLoader for this
   * region.

</member>
        <member name="F:gemfire.PersistenceManager.m_regionPtr">
Region for this persistence manager. 

</member>
        <member name="M:gemfire.PersistenceManager.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.PersistenceManager.close">
Closes the persistence manager instance.
@throws ShutdownFailedException if close is not successful.

</member>
        <member name="M:gemfire.PersistenceManager.destroy(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
destroys the entry specified by the key in the argument.
@param key is the key of the entry which is being destroyed.
@param PersistenceInfo related persistence information.
@throws RegionDestroyedException is the region is already destroyed.
@throws EntryNotFoundException if the entry is not found on the disk.

</member>
        <member name="M:gemfire.PersistenceManager.readAll">
Reads all the values from the region.
@return true

</member>
        <member name="M:gemfire.PersistenceManager.read(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Reads the value for the key from the disk.
@param key is the key for which the value has to be read.
@param PersistenceInfo related persistence information.
@returns value of type CacheablePtr.
@throws DiskCorruptException if the data to be read is corrupt.

</member>
        <member name="M:gemfire.PersistenceManager.init(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Properties&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method gets called after an implementation object is created. Initializes all the implementation
specific environments needed.
@throws InitfailedException if the persistence manager cannot be initialized.

</member>
        <member name="M:gemfire.PersistenceManager.writeAll">
Writes all the entries for a region. Refer persistance requirement doc for the use case.
@throws DiskFailureException if the write fails due to disk fail. 

</member>
        <member name="M:gemfire.PersistenceManager.write(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes a key, value pair of region to the disk. The actual file or database related write operations should be implemented 
in this method by the class implementing this method.
@param key the key to write.
@param value the value to write
@param PersistenceInfo related persistence information.
@throws RegionDestroyedException is the region is already destroyed.
@throws OutofMemoryException if the disk is full
@throws DiskFailureException if the write fails due to disk fail.

</member>
        <member name="M:gemfire.PersistenceManager.getPersistenceManager">
@brief public methods

Returns the current persistence manager.
@return persistence manager

</member>
        <member name="T:gemfire.PersistenceManager">
@class PersistenceManager PersistenceManager.hpp
PersistenceManager API for persistence and overflow. 
This class abstracts the disk-related operations in case of persistence or overflow to disk.
A specific disk storage implementation will implement all the methods described here.

</member>
        <member name="M:gemfire.DistributedSystem.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief constructors

</member>
        <member name="M:gemfire.DistributedSystem.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.DistributedSystem.getInstance">
Returns a pointer to the DistributedSystem instance
     *
     * @return  instance

</member>
        <member name="M:gemfire.DistributedSystem.isConnected">
Returns  true if connected, false otherwise
     *
     * @return  true if connected, false otherwise

</member>
        <member name="M:gemfire.DistributedSystem.getName">
Returns the name that identifies the distributed system instance
     * @return  name

</member>
        <member name="M:gemfire.DistributedSystem.getSystemProperties">
Returns the SystemProperties that were used to create this instance of the
   *  DistributedSystem
   * @return  SystemProperties

</member>
        <member name="M:gemfire.DistributedSystem.disconnect">
@brief disconnect from the distributed system
@throws IllegalStateException if not connected

</member>
        <member name="M:gemfire.DistributedSystem.connect(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.SharedPtr&lt;gemfire.Properties&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief public methods

 Initializes the Native Client system to be able to connect to the
 GemFire Java servers. If the name string is empty, then the default
 "NativeDS" is used as the name of distributed system.
 @throws LicenseException if no valid license is found.
 @throws IllegalStateException if GFCPP variable is not set and
   product installation directory cannot be determined
 @throws IllegalArgument exception if DS name is NULL
 @throws AlreadyConnectedException if this call has succeeded once before for this process

</member>
        <member name="T:gemfire.SystemProperties">
@class DistributedSystem DistributedSystem.hpp
DistributedSystem encapsulates this applications "connection" into the
GemFire Java servers distributed system. In order to participate in the
GemFire Java servers distributed system, each application needs to connect to the DistributedSystem.
Each application can only be connected to one DistributedSystem.


 A class for internal use, that encapsulates the properties that can be
 set from DistributedSystem::connect.


</member>
        <member name="M:gemfire.DiskPolicyType.#ctor">
No instance allowed. 
</member>
        <member name="M:gemfire.DiskPolicyType.isPersist(gemfire.DiskPolicyType.PolicyType!System.Runtime.CompilerServices.IsConst)">
Return whether this is <code>persist</code>. 
</member>
        <member name="M:gemfire.DiskPolicyType.isNone(gemfire.DiskPolicyType.PolicyType!System.Runtime.CompilerServices.IsConst)">
Return whether this is <code>NONE</code>. 
</member>
        <member name="M:gemfire.DiskPolicyType.isOverflow(gemfire.DiskPolicyType.PolicyType!System.Runtime.CompilerServices.IsConst)">
Returns whether this is one of the overflow to disk type.
     * @return true if this is any action other than NONE

</member>
        <member name="M:gemfire.DiskPolicyType.fromName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns the type of the Lru action represented by name. 
</member>
        <member name="M:gemfire.DiskPolicyType.fromOrdinal(System.Byte!System.Runtime.CompilerServices.IsConst)">
Returns the Name of the Lru action represented by specified ordinal. 
</member>
        <member name="T:gemfire.DiskPolicyType">
@class DiskPolicyType DiskPolicyType.hpp
Enumerated type for disk policy.
@see RegionAttributes::getDiskPolicy
@see AttributesFactory::setDiskPolicy

</member>
        <member name="M:gemfire.Properties.Dispose">
destructor. 
</member>
        <member name="M:gemfire.Properties.typeId">
Return type id for serialization. 
</member>
        <member name="M:gemfire.Properties.classId">
Return class id for serialization. 
</member>
        <member name="M:gemfire.Properties.createDeserializable">
Return an empty instance for deserialization. 
</member>
        <member name="M:gemfire.Properties.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief deserialize this object

</member>
        <member name="M:gemfire.Properties.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief serialize this object

</member>
        <member name="M:gemfire.Properties.load(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Read property values from a file, overriding what is currently
    * in the properties object. 

</member>
        <member name="M:gemfire.Properties.create">
Factory method, returns an empty collection. 
</member>
        <member name="M:gemfire.Properties.addAll(gemfire.SharedPtr&lt;gemfire.Properties&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add the contents of other to this instance, replacing any existing
    * values with those from other.

</member>
        <member name="M:gemfire.Properties.getSize">
Return the number of entries in the collection. 
</member>
        <member name="M:gemfire.Properties.foreach(gemfire.Properties.Visitor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Execute the Visitor's <code>visit( const char* key, const char* value )</code>
    * method for each entry in the collection.

</member>
        <member name="M:gemfire.Properties.remove(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Remove the <code>CacheableKey</code> from the collection.

 @throws NullPointerException if the key is NULLPTR

</member>
        <member name="M:gemfire.Properties.remove(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Remove the key from the collection.

 @throws NullPointerException if the key is null

</member>
        <member name="M:gemfire.Properties.insert(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Add or update Cacheable value for CacheableKey

 @throws NullPointerException if the key is NULLPTR

</member>
        <member name="M:gemfire.Properties.insert(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst)">
 Add or update the int value for key.

 @throws NullPointerException if the key is null

</member>
        <member name="M:gemfire.Properties.insert(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Add or update the string value for key.

 @throws NullPointerException if the key is null

</member>
        <member name="M:gemfire.Properties.find(gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Return the value for the given <code>CacheableKey</code>,
 or NULLPTR if not found.

 @throws NullPointerException if the key is NULLPTR

</member>
        <member name="M:gemfire.Properties.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 Return the value for the given key, or NULLPTR if not found.

 @throws NullPointerException if the key is null

</member>
        <member name="T:gemfire.Properties">
@class Properties Properties.hpp
Contains a set of (key, value) pair properties with key being the name of 
the property; value, the value of the property.


</member>
        <member name="F:gemfire.ExpirationAttributes.m_timeout">
The number of seconds since this value or region was created before it expires. 
</member>
        <member name="F:gemfire.ExpirationAttributes.m_action">
The action that should take place when this object or region expires.

</member>
        <member name="M:gemfire.ExpirationAttributes.getAction">
Returns the action that should take place when this value or region expires.
   * 
   * @return the action to take when expiring

</member>
        <member name="M:gemfire.ExpirationAttributes.getTimeout">
Returns the number of seconds before a region or value expires.
   *
   * @return the relative number of seconds before a region or value expires
   * or zero if it will never expire

</member>
        <member name="M:gemfire.ExpirationAttributes.#ctor(System.Int32!System.Runtime.CompilerServices.IsConst,gemfire.ExpirationAction.Action!System.Runtime.CompilerServices.IsConst)">
Constructs an <code>ExpirationAttributes</code> with the specified expiration time and
   * expiration action.
   * @param expirationTime The number of seconds for a value to live before it expires
   * @param expirationAction the action to take when the value expires
   * @throws IllegalArgumentException if expirationTime is nonpositive

</member>
        <member name="M:gemfire.ExpirationAttributes.#ctor">
@brief public methods

@brief  constructors

Constructs a default <code>ExpirationAttributes</code>, which indicates no expiration
   * will take place.

</member>
        <member name="T:gemfire.ExpirationAttributes">
@class ExpirationAttributes ExpirationAttributes.hpp

Immutable parameter object for accessing and setting the attributes associated with
<code>timeToLive</code> and <code>idleTimeout</code>. If the expiration
action is not specified, it defaults to <code>ExpirationAction.INVALIDATE</code>.
If the timeout is not specified, it defaults to zero (which means to never time out).

@see AttributesFactory
@see RegionAttributes
@see AttributesMutator

</member>
        <member name="M:gemfire.ScopeType.#ctor">
No instance allowed. 
</member>
        <member name="M:gemfire.ScopeType.isAck(gemfire.ScopeType.Scope!System.Runtime.CompilerServices.IsConst)">
Returns whether acknowledgements are required for this scope.
     * @return true if this is DISTRIBUTED_ACK or GLOBAL, false otherwise

</member>
        <member name="M:gemfire.ScopeType.isGlobal(gemfire.ScopeType.Scope!System.Runtime.CompilerServices.IsConst)">
Returns whether this is global scope.
     * @return true if this is GLOBAL

</member>
        <member name="M:gemfire.ScopeType.isDistributedAck(gemfire.ScopeType.Scope!System.Runtime.CompilerServices.IsConst)">
Returns whether this is distributed ack scope.
     * @return true if this is DISTRIBUTED_ACK

</member>
        <member name="M:gemfire.ScopeType.isDistributedNoAck(gemfire.ScopeType.Scope!System.Runtime.CompilerServices.IsConst)">
Returns whether this is distributed no ack scope.
     * @return true if this is DISTRIBUTED_NO_ACK

</member>
        <member name="M:gemfire.ScopeType.isDistributed(gemfire.ScopeType.Scope!System.Runtime.CompilerServices.IsConst)">
Returns whether this is one of the distributed scopes.
     * @return true if this is any scope other than LOCAL

</member>
        <member name="M:gemfire.ScopeType.isLocal(gemfire.ScopeType.Scope!System.Runtime.CompilerServices.IsConst)">
Returns whether this is local scope.
     * @return true if this is LOCAL

</member>
        <member name="M:gemfire.ScopeType.fromName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns the type of the Scope represented by name. 
</member>
        <member name="M:gemfire.ScopeType.fromOrdinal(System.Byte!System.Runtime.CompilerServices.IsConst)">
Returns the Name of the Scope represented by specified ordinal. 
</member>
        <member name="T:gemfire.ScopeType">
 @class ScopeType ScopeType.hpp
 Enumerated type for region distribution scope.

 For Native Clients:
 LOCAL scope is invalid (it is a non-native client local region), and
 DISTRIBUTED_ACK and DISTRIBUTED_NO_ACK have the same behavior.

 @see RegionAttributes::getScope
 @see AttributesFactory::setScope

</member>
        <member name="M:gemfire.PartitionResolver.#ctor">
@brief constructors

</member>
        <member name="M:gemfire.PartitionResolver.getRoutingObject(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@param opDetails the detail of the entry event                   
@throws RuntimeException - any exception thrown will terminate the operation and the exception will be passed to the
calling thread.
@return object associated with entry event which allows the Partitioned Region to store associated data together

</member>
        <member name="M:gemfire.PartitionResolver.getName">
Returns the name of the PartitionResolver    
@return String name

</member>
        <member name="M:gemfire.PartitionResolver.Dispose">
@brief public methods

@brief destructor

</member>
        <member name="M:gemfire.CacheListener.#ctor">
@brief constructors

</member>
        <member name="M:gemfire.CacheListener.afterRegionDisconnected(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when all the endpoints assosiated with region are down.
This will be called when all the endpoints are down for the first time. 
If endpoints come up and again go down it will be called again.
This will also be called when all endpoints are down and region is attached to the pool.
@param region RegionPtr denotes the assosiated region.

</member>
        <member name="M:gemfire.CacheListener.afterRegionLive(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Handles the event of a region being live. This event will be invoked
   * after processing all the past messages.
   * Each subregion, however, gets its own <code>afterRegionLive</code> event
   * invoked on its listener.
   * @param event RegionEvent denotes the associated event object

</member>
        <member name="M:gemfire.CacheListener.afterRegionClear(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Handles the event of a region being cleared. Events are not invoked for
   * each individual entry that is removed as a result of the region being
   * cleared. Each subregion, however, gets its own <code>afterRegionClear</code> event
   * invoked on its listener.
   * @param event RegionEvent denotes the event object associated with the region
   *        removal
   * @see Region::clear

</member>
        <member name="M:gemfire.CacheListener.afterRegionDestroy(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Handles the event of a region being destroyed. Events are not invoked for
   * each individual entry that is destroyed as a result of the region being
   * destroyed. Each subregion, however, gets its own <code>afterRegionDestroyed</code> event
   * invoked on its listener.
   * @param event RegionEvent denotes the event object associated with the region
   *        destruction
   * @see Region::destroyRegion

</member>
        <member name="M:gemfire.CacheListener.afterRegionInvalidate(gemfire.RegionEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Handles the event of a region being invalidated. Events are not
   * invoked for each individual value that is invalidated as a result of
   * the region being invalidated. Each subregion, however, gets its own
   * <code>regionInvalidated</code> event invoked on its listener.
   * @param event RegionEvent denotes the event object associated with the region
   *        invalidation
   * @see Region::invalidateRegion

</member>
        <member name="M:gemfire.CacheListener.afterDestroy(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Handles the event of an entry being destroyed.

 @param event EntryEvent denotes the event object associated with the entry destruction
 @see Region::destroy

</member>
        <member name="M:gemfire.CacheListener.afterInvalidate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Handles the event of an entry's value being invalidated.

 @param event EntryEvent denotes the event object associated with the entry invalidation

</member>
        <member name="M:gemfire.CacheListener.afterUpdate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Handles the event of an entry's value being modified in a region. This entry
   * previously existed in this region in the local cache, but its previous value
   * may have been NULLPTR.
   *
   * @param event EntryEvent denotes the event object associated with updating the entry
   * @see Region::put

</member>
        <member name="M:gemfire.CacheListener.afterCreate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Handles the event of a new key being added to a region. The entry
   * did not previously exist in this region in the local cache (even with a NULLPTR value).
   *
   * @param event denotes the event object associated with the entry creation
   * This function does not throw any exception.
   * @see Region::create
   * @see Region::put
   * @see Region::get

</member>
        <member name="M:gemfire.CacheListener.Dispose">
@brief public methods

@brief destructor

</member>
        <member name="T:gemfire.CacheListener">
 @class CacheListener CacheListener.hpp
 An application plug-in that can be installed on a region.
 Listeners are change notifications that are invoked
 AFTER the change has occured for region update operations on a client.
 Listeners also receive notifications when entries in a region are modified.
 Multiple events can cause concurrent invocation
 of <code>CacheListener</code> methods.  If event A occurs before event B,
 there is no guarantee that their corresponding <code>CacheListener</code>
 method invocations will occur in the same order. Any exceptions thrown by
 the listener are caught by GemFire and logged. If the exception is due to
 listener invocation on the same thread where a region operation has been
 performed, then a <code>CacheListenerException</code> is thrown back to
 the application. If the exception is for a notification received from
 server then that is logged and the notification thread moves on to
 receiving other notifications.

 There are two cases in which listeners are invoked. The first is when a
 region modification operation (e.g. put, create, destroy, invalidate)
 is performed. For this case it is important to ensure that minimal work is
 done in the listener before returning control back to Gemfire since the
 operation will block till the listener has not completed. For example,
 a listener implementation may choose to hand off the event to a thread pool
 that then processes the event on its thread rather than the listener thread.
 The second is when notifications are received from java server as a result
 of region register interest calls (<code>Region::registerKeys</code> etc),
 or invalidate notifications when notify-by-subscription is false on the
 server. In this case the methods of <code>CacheListener</code> are invoked
 asynchronously (i.e. does not block the thread that receives notification
 messages). Additionally for the latter case of notifications from server,
 listener is always invoked whether or not local operation is successful
 e.g. if a destroy notification is received and key does not exist in the
 region, the listener will still be invoked. This is different from the
 first case where listeners are invoked only when the region update
 operation succeeds.

 @see AttributesFactory::setCacheListener
 @see RegionAttributes::getCacheListener
 @see CacheListenerException

</member>
        <member name="M:gemfire.CacheWriter.beforeDestroy(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Called before an entry is destroyed. The entry being destroyed may or may
 not exist in the local cache where the CacheWriter is installed. This method
 is <em>not</em> called as a result of expiration or {@link Region::localDestroyRegion}.

 @param event EntryEvent denotes the event object associated with destroying the entry

 @see Region::destroy

</member>
        <member name="M:gemfire.CacheWriter.beforeCreate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called before an entry is created. Entry creation is initiated by a
   * <code>create</code>, a <code>put</code>, or a <code>get</code>.
   * The <code>CacheWriter</code> can determine whether this value comes from a
   * <code>get</code> or not from {@link EntryEvent::isLoad}. The entry being
   * created may already exist in the local cache where this <code>CacheWriter</code>
   * is installed, but it does not yet exist in the cache where the operation was initiated.
   * @param event EntryEvent denotes the event object associated with creating the entry
   *
   *
   * @see Region::create
   * @see Region::put
   * @see Region::get

</member>
        <member name="M:gemfire.CacheWriter.beforeUpdate(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 Called before an entry is updated. The entry update is initiated by a <code>put</code>
 or a <code>get</code> that causes the loader to update an existing entry.
 The entry previously existed in the cache where the operation was
 initiated, although the old value may have been NULLPTR. The entry being
 updated may or may not exist in the local cache where the CacheWriter is
 installed.

 @param event EntryEvent denotes the event object associated with updating the entry


 @see Region::put
 @see Region::get

</member>
        <member name="M:gemfire.CacheLoader.load(gemfire.SharedPtr&lt;gemfire.Region&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Loads a value. Application writers should implement this
   * method to customize the loading of a value. This method is called
   * by the caching service when the requested value is not in the cache.
   * Any exception thrown by this method is propagated back to and thrown
   * by the invocation of {@link Region::get} that triggered this load.
   * @param rp a Region Pointer for which this is called.
   * @param key the key for the cacheable
   * @param helper any related user data, or NULLPTR
   * @return the value supplied for this key, or NULLPTR if no value can be
   * supplied. 
   *
   *@see Region::get .

</member>
        <member name="T:gemfire.CacheLoader">
 @class CacheLoader CacheLoader.hpp
 An application plug-in that can be installed on a region. Loaders
 facilitate loading of data into the cache. When an application does a
 lookup for a key in a region and it does not exist, the system checks to
 see if any loaders are available for the region in the system and
 invokes them to get the value for the key into the cache.
 Allows data to be loaded from a 3rd party data source and placed
 into the region
 When {@link Region::get} is called for a region
 entry that has a <code>NULLPTR</code> value, the
 {@link CacheLoader::load} method of the
 region's cache loader is invoked.  The <code>load</code> method
 creates the value for the desired key by performing an operation such
 as a database query.  

 @see AttributesFactory::setCacheLoader
 @see RegionAttributes::getCacheLoader

</member>
        <member name="M:gemfire.ExpirationAction.fromOrdinal(System.Int32!System.Runtime.CompilerServices.IsConst)">
Return the ExpirationAction represented by the specified ordinal 
</member>
        <member name="M:gemfire.ExpirationAction.isDistributed(gemfire.ExpirationAction.Action!System.Runtime.CompilerServices.IsConst)">
Returns whether this action is distributed.
     * @return true if this is INVALIDATE or DESTROY

</member>
        <member name="M:gemfire.ExpirationAction.isLocal(gemfire.ExpirationAction.Action!System.Runtime.CompilerServices.IsConst)">
Returns whether this action is local.
     * @return true if this is LOCAL_INVALIDATE or LOCAL_DESTROY

</member>
        <member name="M:gemfire.ExpirationAction.isLocalDestroy(gemfire.ExpirationAction.Action!System.Runtime.CompilerServices.IsConst)">
Returns whether this is the action for local destroy.
     * @return true if thisis LOCAL_DESTROY

</member>
        <member name="M:gemfire.ExpirationAction.isDestroy(gemfire.ExpirationAction.Action!System.Runtime.CompilerServices.IsConst)">
Returns whether this is the action for distributed destroy.
     * @return true if this is DESTROY

</member>
        <member name="M:gemfire.ExpirationAction.isLocalInvalidate(gemfire.ExpirationAction.Action!System.Runtime.CompilerServices.IsConst)">
Returns whether this is the action for local invalidate.
@return true if this is LOCAL_INVALIDATE

</member>
        <member name="M:gemfire.ExpirationAction.isInvalidate(gemfire.ExpirationAction.Action!System.Runtime.CompilerServices.IsConst)">
Returns whether this is the action for distributed invalidate.
@return true if this in INVALIDATE

</member>
        <member name="M:gemfire.ExpirationAction.fromName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@param name the name of the expiration action

</member>
        <member name="F:INVALID_ACTION">
invalid type. 
</member>
        <member name="F:LOCAL_DESTROY">
When expired, destroyed locally only. 
</member>
        <member name="F:DESTROY">
When the region or cached object expires, it is destroyed. 
</member>
        <member name="F:LOCAL_INVALIDATE">
When expired, invalidated locally only. 
</member>
        <member name="F:INVALIDATE">
When the region or cached object expires, it is invalidated. 
</member>
        <member name="T:gemfire.ExpirationAction">
@class ExpirationAction ExpirationAction.hpp
Enumerated type for expiration actions.

@see ExpirationAttributes

</member>
        <member name="M:GemStone.GemFire.Cache.SafeMKeyConvert(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Helper function to convert managed <see cref="T:GemStone.GemFire.Cache.ICacheableKey" />
object to native <c>gemfire::CacheableKey</c> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.SafeUMKeyConvert(gemfire.CacheableKey*)">
            <summary>
Helper function to convert native <c>gemfire::CacheableKey</c> object
to managed <see cref="T:GemStone.GemFire.Cache.ICacheableKey" /> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.SafeMSerializableConvert(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Helper function to convert managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" />
object to native <c>gemfire::Serializable</c> object using
<c>SafeM2UMConvert</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.SafeUMSerializableConvert(gemfire.Serializable*)">
            <summary>
Helper function to convert native <c>gemfire::Serializable</c> object
to managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" /> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqEvent.#ctor(gemfire.CqEvent!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqEvent.getNewValue">
            <summary>
Get the new value of the modification.
If there is no new value returns null, this will happen during delete
operation.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqEvent.getKey">
            <summary>
Get the key relating to the event.
In case of REGION_CLEAR and REGION_INVALIDATE operation, the key will be null.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqEvent.getQueryOperation">
            <summary>
Get the operation on the query operation that triggered this event.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqEvent.getBaseOperation">
            <summary>
Get the operation on the base operation that triggered this event.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqEvent.getCq">
            <summary>
Return the cqquery this event occurred in.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqEvent">
            <summary>
This class encapsulates events that occur for cq.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICqEvent.getKey">
            <summary>
Called when the region containing this callback is destroyed, when
the cache is closed.
</summary>
            <remarks>
Implementations should clean up any external resources,
such as database connections. Any runtime exceptions this method
throws will be logged.
<para>
It is possible for this method to be called multiple times on a single
callback instance, so implementations must be tolerant of this.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Cache.Close" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.DestroyRegion(GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICqEvent.getBaseOperation">
            <summary>
Handles the event of an entry's value being modified in a region.
</summary>
            <remarks>
This entry previously existed in this region in the local cache,
but its previous value may have been null.
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="M:GemStone.GemFire.Cache.ICqEvent.getCq">
            <summary>
Handles the event of a new key being added to a region.
</summary>
            <remarks>
The entry did not previously exist in this region in the local cache
(even with a null value).
<para>
This function does not throw any exception.
</para></remarks>
            <seealso cref="M:GemStone.GemFire.Cache.Region.Create(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Put(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)" />
            <seealso cref="M:GemStone.GemFire.Cache.Region.Get(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable)" />
        </member>
        <member name="T:GemStone.GemFire.Cache.ICqEvent">
            <summary>
An application plug-in that can be installed on a region.
Listener change notifications are invoked <c>after</c>
the change has occured.
</summary>
            <remarks>
Listeners receive notifications when entries in a region change or changes occur to the
region attributes themselves.
<para>
A cache listener is defined in the <see cref="T:GemStone.GemFire.Cache.RegionAttributes" />.
</para>
The methods on a <c>ICacheListener</c>
are invoked asynchronously. Multiple events can cause concurrent invocation
of <c>ICacheListener</c> methods.  If event A occurs before event B,
there is no guarantee that their corresponding <c>ICacheListener</c>
method invocations will occur in the same order.  Any exceptions thrown by
the listener are caught by GemFire and logged. 

Listeners are user callbacks that
are invoked by GemFire. It is important to ensure that minimal work is done in the
listener before returning control back to GemFire. For example, a listener
implementation may choose to hand off the event to a thread pool that then processes
the event on its thread rather than the listener thread
</remarks>
            <seealso cref="M:GemStone.GemFire.Cache.AttributesFactory.SetCacheListener(GemStone.GemFire.Cache.ICacheListener)" />
            <seealso cref="P:GemStone.GemFire.Cache.RegionAttributes.CacheListener" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheLoader" />
            <seealso cref="T:GemStone.GemFire.Cache.ICacheWriter" />
        </member>
        <member name="M:GemStone.GemFire.Cache.CqOperation.#ctor(gemfire.CqOperation*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqOperation.ConvertFromNative(gemfire.CqOperation.CqOperationType)">
            <summary>
conenience function for convertin from c++ 
gemfire::CqOperation::CqOperationType to
CqOperationType here.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqOperationType">
            <summary>
Enumerated type for CqOperationType
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.#ctor(gemfire.CqQuery*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.Create(gemfire.CqQuery*)">
            <summary>
Internal factory function to wrap a native object pointer inside
this managed class with null pointer check.
</summary>
            <param name="nativeptr">The native object pointer</param>
            <returns>
The managed wrapper object; null if the native pointer is null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.IsClosed">
            <summary>
Is this Cq in closed state?
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.IsStopped">
            <summary>
Is this Cq in stopped state?
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.IsRunning">
            <summary>
Is this Cq in running state?
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.GetState">
            <summary>
get the state of this cq query
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.Close">
            <summary>
stop the cq query
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.Stop">
            <summary>
stop the cq query
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.GetQuery">
            <summary>
Get the Query for this cq query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.GetStatistics">
            <summary>
Get the stats for this cq query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.GetCqAttributesMutator">
            <summary>
Get the Attributes Mutator for this cq query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.GetCqAttributes">
            <summary>
Get the Attributes for this cq query.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CqQuery.Name">
            <summary>
Get the name for this cq query.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CqQuery.QueryString">
            <summary>
Get the string for this cq query.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.ExecuteWithInitialResults(System.UInt32)">
            <summary>
Executes the Cq Query on the cache server
with the specified timeout and returns the results.
</summary>
            <param name="timeout">The time (in seconds) to wait for query response.
This should be less than or equal to 2^31/1000 i.e. 2147483.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if timeout parameter is greater than 2^31/1000.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.ExecuteWithInitialResults">
            <summary>
Executes the Cq Query on the cache server
and returns the Cqresults.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqQuery.Execute">
            <summary>
Executes the Cq  Query on the cache server
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqQuery">
            <summary>
Class to encapsulate a continuous query (CQ).
</summary>
            <remarks>
A CqQuery is obtained from a QueryService which in turn is obtained
from the Cache.
This can be executed to return SelectResults which can be either
a ResultSet or a StructSet, or it can be just registered on the
java server without returning results immediately rather only
the incremental results.

This class is intentionally not thread-safe. So multiple threads
should not operate on the same <c>CqQuery</c> object concurrently
rather should have their own <c>CqQuery</c> objects.
</remarks>
        </member>
        <member name="M:gemfire.CqQuery.isDurable">
This allows to check if the CQ is durable.
@return boolean true if durable, false otherwise
@since 5.5

</member>
        <member name="M:gemfire.CqQuery.isClosed">
This allows to check if the CQ is closed.
@return boolean true if closed, false otherwise

</member>
        <member name="M:gemfire.CqQuery.isStopped">
This allows to check if the CQ is in stopped.
@return boolean true if stopped, false otherwise

</member>
        <member name="M:gemfire.CqQuery.isRunning">
This allows to check if the CQ is in running or active.
@return boolean true if running, false otherwise

</member>
        <member name="M:gemfire.CqQuery.close">
Close the CQ and stop execution.
Releases the resources associated with this CqQuery.
@throws CqClosedException Further calls on this CqQuery instance except
        for getState() or getName().
@throws CqException - if failure during cleanup of CQ resources.

</member>
        <member name="M:gemfire.CqQuery.getState">
Get the state of the CQ in CqState object form.
CqState supports methods like isClosed(), isRunning(), isStopped().
@see CqState
@return CqState state object of the CQ.

</member>
        <member name="M:gemfire.CqQuery.stop">
Stops this CqQuery without releasing resources. Puts the CqQuery into
the STOPPED state. Can be resumed by calling execute or
executeWithInitialResults.
@throws IllegalStateException if the CqQuery is in the STOPPED state
        already.
@throws CqClosedException if the CQ is CLOSED.

</member>
        <member name="M:gemfire.CqQuery.execute">
 @notsupported_cacheserver
 @nativeclient
 Executes the OQL Query on the cache server and returns the results.

 @throws RegionNotFoundException if the specified region in the
         query string is not found.
 @throws CqClosedException if this CqQuery is closed.
 @throws CqException if some query error occurred at the server.
 @throws IllegalStateException if some error occurred.
 @throws NotConnectedException if no java cache server is available. For pools
 configured with locators, if no locators are available, the cause of NotConnectedException
 is set to NoAvailableLocatorsException.
 @endnativeclient

</member>
        <member name="M:gemfire.CqQuery.executeWithInitialResults(System.UInt32)">
 Start executing the CQ or if this CQ is stopped earlier, resumes execution of the CQ.
 Get the resultset associated with CQ query.
 The CQ is executed on primary and redundant servers, if CQ execution fails on all the
 server then a CqException is thrown.

 @param timeout The time (in seconds) to wait for query response, optional.
        This should be less than or equal to 2^31/1000 i.e. 2147483.

 @throws IllegalArgumentException if timeout parameter is greater than 2^31/1000.
 @throws CqClosedException if this CqQuery is closed.
 @throws RegionNotFoundException if the specified region in the
         query string is not found.
 @throws IllegalStateException if the CqQuery is in the RUNNING state
         already.
 @throws CqException if failed to execute and get initial results.
 @return CqResults resultset obtained by executing the query.

</member>
        <member name="M:gemfire.CqQuery.getCqAttributesMutator">
Get the AttributesMutator of this CQ.
@return CqAttributesMutator, the CqAttributesMutator object.

</member>
        <member name="M:gemfire.CqQuery.getCqAttributes">
Get the Attributes of this CQ.
@return CqAttributes, the CqAttributes object.

</member>
        <member name="M:gemfire.CqQuery.getStatistics">
Get the statistics information of this CQ.
@return CqStatistics, the CqStatistics object.

</member>
        <member name="M:gemfire.CqQuery.getName">
Get the name of the CQ.
@return the name of the CQ.

</member>
        <member name="M:gemfire.CqQuery.getQuery">
Get teh query object generated for this CQs query.
@return Query object fort he query string

</member>
        <member name="M:gemfire.CqQuery.getQueryString">
Get the query string provided when a new Query was created from a QueryService.
@returns The query string.

</member>
        <member name="T:gemfire.CqQuery">
 @class CqQuery CqQuery.hpp

 A Query is obtained from a QueryService which in turn is obtained from the Cache.
 This can be executed to return SelectResults which can be either
 a ResultSet or a StructSet, or it can be just registered on the java server
 without returning results immediately rather only the incremental results.

 This class is intentionally not thread-safe. So multiple threads should not
 operate on the same <code>CqQuery</code> object concurrently rather should
 have their own <code>CqQuery</code> objects.

</member>
        <member name="M:gemfire.CqAttributesMutator.setCqListeners(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CqListener&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds the given set CqListner on this CQ. If the CQ already has CqListeners, this 
removes those old CQs and initializes with the newListeners.
@param newListeners a possibly empty array of listeners to add 
to this CqQuery.
@throws IllegalArgumentException if the <code>newListeners</code> array 
has a NULLPTR element

</member>
        <member name="M:gemfire.CqAttributesMutator.removeCqListener(gemfire.SharedPtr&lt;gemfire.CqListener&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Removes given CQ listener from the list of CQ listeners on this CqQuery.
Does nothing if the specified listener has not been added.
If the specified listener has been added then will
be called on it; otherwise does nothing.
@param aListener the CQ listener to remove from the CqQuery.
@throws IllegalArgumentException if <code>aListener</code> is NULLPTR

</member>
        <member name="M:gemfire.CqAttributesMutator.addCqListener(gemfire.SharedPtr&lt;gemfire.CqListener&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds a CQ listener to the end of the list of CQ listeners on this CqQuery.
@param aListener the user defined CQ listener to add to the CqQuery.
@throws IllegalArgumentException if <code>aListener</code> is NULLPTR

</member>
        <member name="T:gemfire.CqAttributesMutator">
 @class CqAttributesMutator CqAttributesMutator.hpp

 This interface is used to modify the listeners that are associated with a CQ. 
 Each CqQuery has an CqAttributesMutator interface which supports modification 
 of certain CQ attributes after the CQ has been created. 
 

</member>
        <member name="M:gemfire.CqAttributes.getCqListeners(gemfire.VectorT&lt;gemfire.SharedPtr&lt;gemfire.CqListener&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get the CqListeners set with the CQ.
Returns all the Listener associated with this CQ.
@see CqListener
@return VectorOfCqListener of CqListnerPtr

</member>
        <member name="T:gemfire.CqAttributes">
 @cacheserver
 Querying is only supported for native clients.
 @endcacheserver
 @class CqAttributes CqAttributes.hpp

 This interface holds all attribute values for a CQ and provides methods for 
 retrieving all attribute settings. This interface can be modified only by 
 the CqAttributesFactory class (before CQ creation) and the CqAttributesMutator 
 interface (after CQ creation).
 
 For compatibility rules and default values, see {@link CqAttributesFactory}.

</member>
        <member name="M:gemfire.CqListener.#ctor">
@brief constructors

</member>
        <member name="M:gemfire.CqListener.onError(gemfire.CqEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method is invoked when there is an error during CQ processing.  
The error can appear while applying query condition on the event.
e.g if the event doesn't has attributes as specified in the CQ query.
This event does contain an error. The newValue may or may not be 
available, and will be NULLPTR if not available.

</member>
        <member name="M:gemfire.CqListener.onEvent(gemfire.CqEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method is invoked when an event is occurred on the region
that satisfied the query condition of this CQ.
This event does not contain an error.

</member>
        <member name="T:gemfire.CqListener">
 @cacheserver
 Querying is only supported for native clients.
 @endcacheserver
 @class CqListener CqListener.hpp

 Application plug-in interface for handling continuous query events after 
 they occur. The listener has two methods, one that is called when there 
 is an event satisfied by the CQ and the other called when there is an 
 error during CQ processing. 

</member>
        <member name="M:gemfire.CqStatistics.numEvents">
Get total of all the events qualified by this CQ.
@return total number of events.

</member>
        <member name="M:gemfire.CqStatistics.numUpdates">
Get number of Update events qualified by this CQ.
@return number of updates.

</member>
        <member name="M:gemfire.CqStatistics.numDeletes">
Get number of Delete events qualified by this CQ.
@return number of deletes.

</member>
        <member name="M:gemfire.CqStatistics.numInserts">
Get number of Insert events qualified by this CQ.
@return number of inserts.

</member>
        <member name="T:gemfire.CqStatistics">
 @cacheserver
 Querying is only supported for native clients.
 @endcacheserver
 @class CqStatistics CqStatistics.hpp

 This class provides methods to get statistical information about a registered Continuous Query (CQ)
 represented by the CqQuery object. 
 

</member>
        <member name="T:gemfire.CqResults">
 @class CqResults CqResults.hpp

 A CqResults is obtained by executing a Query on the server.
 This will be a StructSet.

</member>
        <member name="M:gemfire.SelectResults.end">
Get an iterator pointing to the end of vector. 
</member>
        <member name="M:gemfire.SelectResults.begin">
Get an iterator pointing to the start of vector. 
</member>
        <member name="D:gemfire.SelectResults.Iterator">
Interface of an iterator for <code>SelectResults</code>.
</member>
        <member name="M:gemfire.SelectResults.getIterator">
 Get a SelectResultsIterator with which to iterate over the items in the SelectResults.

 @returns The SelectResultsIterator with which to iterate.

</member>
        <member name="M:gemfire.SelectResults.op_Subscript(System.Int32)">
 Index operator to directly access an item in the SelectResults.

 @param index the index number of the required item.
 @throws IllegalArgumentException if the index is out of bounds.
 @returns A smart pointer to the item indexed.

</member>
        <member name="M:gemfire.SelectResults.size">
 Get the size of the SelectResults.

 @returns the number of items in the SelectResults.

</member>
        <member name="M:gemfire.SelectResults.isModifiable">
 Check whether the SelectResults is modifiable.

 @returns false always at this time.

</member>
        <member name="T:gemfire.SelectResults">
 @class SelectResults SelectResults.hpp

 A SelectResults is obtained by executing a Query on the server.
 This can either be a ResultSet or a StructSet.

</member>
        <member name="M:GemStone.GemFire.Cache.CqState.#ctor(gemfire.CqState*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqState.IsClosing">
            <summary>
Returns true if the CQ is in Closing state.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqState.IsClosed">
            <summary>
Returns true if the CQ is in Closed state.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqState.IsStopped">
            <summary>
Returns true if the CQ is in Stopped state.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqState.IsRunning">
            <summary>
Returns true if the CQ is in Running state.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CqState.ToString">
            <summary>
Returns the state in string form.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqState">
            <summary>
Static class containing convenience methods for <c>CqState</c>.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqStateType">
            <summary>
Enumerated type for cq state
@nativeclient
For Native Clients:
@endnativeclient      
</summary>
        </member>
        <member name="M:gemfire.CqState.isClosing">
Returns true if the CQ is in Closing state.

</member>
        <member name="M:gemfire.CqState.isClosed">
Returns true if the CQ is in Closed state.

</member>
        <member name="M:gemfire.CqState.isStopped">
Returns true if the CQ is in Stopped state.

</member>
        <member name="M:gemfire.CqState.isRunning">
Returns true if the CQ is in Running state.

</member>
        <member name="M:gemfire.CqState.toString">
Returns the state in string form.

</member>
        <member name="T:gemfire.CqState">
 @class CqState CqState.hpp

 This interface gives information on the state of a CqQuery. 
 It is provided by the getState method of the CqQuery instance. 

</member>
        <member name="M:gemfire.CqEvent.getNewValue">
Get the new value of the modification.
If there is no new value returns NULLPTR, this will happen during delete
operation.
@return Object new/modified value.

</member>
        <member name="M:gemfire.CqEvent.getKey">
Get the key relating to the event.
In case of REGION_CLEAR and REGION_INVALIDATE operation, the key will be NULLPTR.
@return Object key.

</member>
        <member name="M:gemfire.CqEvent.getQueryOperation">
Get the operation on the query results. Supported operations
include update, create, destroy, region clear and region invalidate.
@return Operation operation with respect to CQ.

</member>
        <member name="M:gemfire.CqEvent.getBaseOperation">
Get the operation on the base region that triggered this event.
@return Operation operation on the base region (on which CQ is created).

</member>
        <member name="M:gemfire.CqEvent.getCq">
Get the CqQuery object of this event.
@see CqQuery
@return CqQuery object.

</member>
        <member name="T:gemfire.CqEvent">
 @class CqEvent CqEvent.hpp

 This interface provides methods to get all the information sent from the server
 about the CQ event.
 The CqEvent is passed to the CQs CqListener methods. It can be used to retrieve
 such information as the region operation, CQ operation associated with the event,
 the new key and value from the event, and the CqQuery object associated with the
 event.
 The CqEvent is not an extension of CacheEvent.

</member>
        <member name="T:gemfire.CqOperation">
@class Operation CqOperation.hpp
Enumerated type for Operation actions.

</member>
        <member name="F:gemfire.ManagedCacheableDeltaBytes.m_domainId">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFDelta
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytes.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytes.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytes.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytes.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytes.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytes.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytes.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDeltaBytes.#ctor(GemStone.GemFire.Cache.IGFDelta,System.Boolean)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedDeltaptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheableDeltaBytes">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFDelta" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
            <summary>
Copy the string form of a key into a char* buffer for logging purposes.
implementations should only generate a string as long as maxLength chars,
and return the number of chars written. buffer is expected to be large 
enough to hold at least maxLength chars.
The default implementation renders the classname and instance address.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.hashcode">
            <summary>
return the hashcode for this key.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.op_Equality(gemfire.ManagedCacheableKeyBytes!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other ManagedCacheableKeyBytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other CacheableKey
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.toString">
            <summary>
Display this object as 'string', which depends on the implementation in
the managed class
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKeyBytes.#ctor(GemStone.GemFire.Cache.IGFSerializable,System.Boolean)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="F:gemfire.ManagedCacheableKeyBytes.m_domainId">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFSerializable
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="T:gemfire.ManagedCacheableKeyBytes">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheableDelta.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFDelta
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDelta.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDelta.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDelta.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDelta.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDelta.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDelta.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDelta.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableDelta.#ctor(GemStone.GemFire.Cache.IGFDelta)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheableDelta">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFDelta" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="F:gemfire.ManagedCacheableKey.m_managedptr">
            <summary>
Using gcroot to hold the managed delegate pointer (since it cannot be stored directly).
Note: not using auto_gcroot since it will result in 'Dispose' of the IGFSerializable
to be called which is not what is desired when this object is destroyed. Normally this
managed object may be created by the user and will be handled automatically by the GC.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.ptr">
            <summary>
Returns the wrapped managed object reference.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
            <summary>
Copy the string form of a key into a char* buffer for logging purposes.
implementations should only generate a string as long as maxLength chars,
and return the number of chars written. buffer is expected to be large 
enough to hold at least maxLength chars.
The default implementation renders the classname and instance address.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.hashcode">
            <summary>
return the hashcode for this key.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.op_Equality(gemfire.ManagedCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other ManagedCacheableKey
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
return true if this key matches other CacheableKey
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.toString">
            <summary>
Display this object as 'string', which depends on the implementation in
the managed class
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.DSFID">
            <summary>
return the Data Serialization Fixed ID type.
This is used to determine what instance type to create
and deserialize into.

Note that this should not be overridden by custom implementations
and is reserved only for builtin types.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.typeId">
            <summary>
return the typeId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.classId">
            <summary>
return the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.objectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
serialize this object
</summary>
        </member>
        <member name="M:gemfire.ManagedCacheableKey.#ctor(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Constructor to initialize with the provided managed object.
</summary>
            <param name="managedptr">
The managed object.
</param>
        </member>
        <member name="T:gemfire.ManagedCacheableKey">
            <summary>
Wraps the managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" />
object and implements the native <c>gemfire::CacheableKey</c> interface.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CharArray">
            <summary>
An immutable wrapper for array of 16-bit characters that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.BooleanArray">
            <summary>
An immutable wrapper for array of booleans that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableInt64Array">
            <summary>
An immutable wrapper for array of 64-bit integers that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableInt32Array">
            <summary>
An immutable wrapper for array of 32-bit integers that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableInt16Array">
            <summary>
An immutable wrapper for array of 16-bit integers that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableFloatArray">
            <summary>
An immutable wrapper for array of floats that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableDoubleArray">
            <summary>
An immutable wrapper for array of doubles that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableBytes">
            <summary>
An immutable wrapper for byte arrays that can serve
as a distributable object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableInt64">
            <summary>
An immutable wrapper for 64-bit integers that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableInt32">
            <summary>
An immutable wrapper for 32-bit integers that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableInt16">
            <summary>
An immutable wrapper for 16-bit integers that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableFloat">
            <summary>
An immutable wrapper for floats that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableDouble">
            <summary>
An immutable wrapper for doubles that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableCharacter">
            <summary>
An immutable wrapper for 16-bit characters that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableByte">
            <summary>
An immutable wrapper for bytes that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableBoolean">
            <summary>
An immutable wrapper for booleans that can serve
as a distributable key object for caching.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.#ctor(gemfire.DataOutput*,System.Boolean)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.DataOutput.NativeIntPtr">
            <summary>
Get the underlying native unmanaged pointer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.Reset">
            <summary>
Reset the cursor to the start of the buffer.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.DataOutput.BufferLength">
            <summary>
Get the length of current data in the buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.GetBuffer">
            <summary>
Get a copy of the current buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.RewindCursor(System.UInt32)">
            <summary>
Rewind the buffer cursor by the given offset.
</summary>
            <param name="offset">
The offset by which to rewind the cursor.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.AdvanceCursor(System.UInt32)">
            <summary>
Advance the buffer cursor by the given offset.
</summary>
            <param name="offset">
The offset by which to advance the cursor.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteObject(GemStone.GemFire.Cache.Serializable)">
            <summary>
Write a <c>Serializable</c> object to the <c>DataOutput</c>.
This is provided to conveniently pass primitive types (like string)
that shall be implicitly converted to corresponding
<c>IGFSerializable</c> wrapper types.
</summary>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteObject(GemStone.GemFire.Cache.IGFSerializable)">
            <summary>
Write an <c>IGFSerializable</c> object to the <c>DataOutput</c>.
</summary>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteASCIIHuge(System.String)">
            <summary>
Write a string(only ASCII char) to
<c>DataOutput</c>.
Length should be more than 2^16 -1.
</summary>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteUTFHuge(System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>DataOutput</c>.
Length should be more than 2^16 -1. 
</summary>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteUTF(System.String)">
            <summary>
Write a string using java-modified UTF-8 encoding to
<c>DataOutput</c>.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
            <param name="value">The UTF encoded string to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteDouble(System.Double)">
            <summary>
Write a double precision real number to the <c>DataOutput</c>.
</summary>
            <param name="value">
The double precision real number to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteFloat(System.Single)">
            <summary>
Write a float to the DataOutput.
</summary>
            <param name="value">The float value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteInt64(System.Int64)">
            <summary>
Write a 64-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteInt32(System.Int32)">
            <summary>
Write a 32-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteInt16(System.Int16)">
            <summary>
Write a 16-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteUInt64(System.UInt64)">
            <summary>
Write an unsigned 64-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The unsigned 64-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteUInt32(System.UInt32)">
            <summary>
Write an unsigned 32-bit integer to the <c>DataOutput</c>.
</summary>
            <param name="value">The unsigned 32-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteUInt16(System.UInt16)">
            <summary>
Write an unsigned short integer (int16_t) to the <c>DataOutput</c>.
</summary>
            <param name="value">The unsigned 16-bit integer to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteSBytesOnly(System.SByte[])">
            <summary>
Write an array of signed bytes without its length
to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of signed bytes to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteSBytesOnly(System.SByte[],System.UInt32)">
            <summary>
Write a given length of signed bytes without its length
to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of signed bytes to write.</param>
            <param name="len">
The number of bytes from the start of array to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteBytesOnly(System.Byte[])">
            <summary>
Write an array of bytes without its length to the
<c>DataOutput</c>.
</summary>
            <param name="bytes">The array of bytes to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteBytesOnly(System.Byte[],System.UInt32)">
            <summary>
Write a given length of bytes without its length to the
<c>DataOutput</c>.
</summary>
            <param name="bytes">The array of bytes to write.</param>
            <param name="len">
The number of bytes from the start of array to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteSBytes(System.SByte[])">
            <summary>
Write an array of signed bytes to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of signed bytes to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteSBytes(System.SByte[],System.Int32)">
            <summary>
Write a given length of signed bytes to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of signed bytes to write.</param>
            <param name="len">
The number of bytes from the start of array to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteBytes(System.Byte[])">
            <summary>
Write an array of bytes to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of bytes to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteBytes(System.Byte[],System.Int32)">
            <summary>
Write a given length of bytes to the <c>DataOutput</c>.
</summary>
            <param name="bytes">The array of bytes to write.</param>
            <param name="len">
The number of bytes from the start of array to write.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteBoolean(System.Boolean)">
            <summary>
Write a boolean value to the <c>DataOutput</c>.
</summary>
            <param name="value">The boolean value to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteSByte(System.SByte)">
            <summary>
Write a signed byte to the <c>DataOutput</c>.
</summary>
            <param name="value">The signed byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteByte(System.Byte)">
            <summary>
Write a byte to the <c>DataOutput</c>.
</summary>
            <param name="value">The byte to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.WriteArrayLen(System.Int32)">
            <summary>
Write length of the array to the <c>DataOutput</c>.
</summary>
            <param name="len">Array len to write.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataOutput.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.DataOutput">
            <summary>
Provides operations for writing primitive data values, and
user-defined objects implementing IGFSerializable, to a byte stream.
This class is intentionally not thread safe.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableStack.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableStack.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.Create(System.Int32)">
            <summary>
Static function to create a new instance with given initial size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.Create(System.Collections.Generic.IEnumerable`1{GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Static function to create a new instance copying from the
given collection.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the vector.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.#ctor(System.Collections.Generic.IEnumerable`1{GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Allocates a new instance copying from the given collection.
</summary>
            <param name="collection">
The collection whose elements are copied to this list.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableStack.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableStack">
            <summary>
A mutable <c>IGFSerializable</c> vector wrapper that can serve as
a distributable object for caching.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableArrayList.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableArrayList.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableArrayList.Create(System.Int32)">
            <summary>
Static function to create a new instance with given initial size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableArrayList.Create(System.Collections.Generic.IEnumerable`1{GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Static function to create a new instance copying from the
given collection.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableArrayList.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableArrayList.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the vector.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableArrayList.#ctor(System.Collections.Generic.IEnumerable`1{GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Allocates a new instance copying from the given collection.
</summary>
            <param name="collection">
The collection whose elements are copied to this list.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableArrayList.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableArrayList">
            <summary>
A mutable <c>IGFSerializable</c> vector wrapper that can serve as
a distributable object for caching. This class extends .NET generic
<c>List</c> class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableVector.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableVector.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.Create(System.Int32)">
            <summary>
Static function to create a new instance with given initial size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.Create(System.Collections.Generic.IEnumerable`1{GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Static function to create a new instance copying from the
given collection.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.Create">
            <summary>
Static function to create a new empty instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.#ctor(System.Int32)">
            <summary>
Allocates a new empty instance with given initial size.
</summary>
            <param name="capacity">
The initial capacity of the vector.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.#ctor(System.Collections.Generic.IEnumerable`1{GemStone.GemFire.Cache.IGFSerializable^})">
            <summary>
Allocates a new instance copying from the given collection.
</summary>
            <param name="collection">
The collection whose elements are copied to this list.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableVector.#ctor">
            <summary>
Allocates a new empty instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableVector">
            <summary>
A mutable <c>IGFSerializable</c> vector wrapper that can serve as
a distributable object for caching. This class extends .NET generic
<c>List</c> class.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.#ctor(gemfire.Serializable*)">
            <summary>
Private constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.#ctor(System.Char[],System.Boolean)">
            <summary>
Private constructor to create a CacheableString without checking
for arguments.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.#ctor(System.String,System.Boolean)">
            <summary>
Private constructor to create a CacheableString without checking
for arguments.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.GetString(gemfire.CacheableString*)">
            <summary>
Get the <c>System.String</c> from the given
<c>gemfire::CacheableString</c></summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.GetCacheableString(System.Char[],gemfire.SharedPtr&lt;gemfire.CacheableString&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Internal function to create a <c>gemfire::CacheableString</c>
from the given managed array of characters.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.GetCacheableString(System.String,gemfire.SharedPtr&lt;gemfire.CacheableString&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Internal function to create a <c>gemfire::CacheableString</c>
from the given managed string.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.Create(gemfire.Serializable*)">
            <summary>
Factory function to register wrapper
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableString.IsWideString">
            <summary>
True when the underlying C string is a wide-character string.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableString.Length">
            <summary>
Gets the length of the underlying C string.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.op_Implicit(GemStone.GemFire.Cache.CacheableString)~System.String">
            <summary>
Implicit conversion operator to underlying <c>System.String</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.IsNullOrEmpty(GemStone.GemFire.Cache.CacheableString)">
            <summary>
Static function to check whether IsNullOrEmpty.
</summary>
            <remarks>
This is similar to the C# string.IsNullOrEmpty method.
</remarks>
            <param name="value">the CacheableString value to check</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableString.Value">
            <summary>
Gets the string value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.GetHashCode">
            <summary>
Return the hashcode for this key.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.Equals(System.Object)">
            <summary>
Return true if this key matches other object.
It invokes the '==' operator of the underlying
<c>gemfire::CacheableString</c> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.Equals(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Return true if this key matches other object.
It invokes the '==' operator of the underlying
<c>gemfire::CacheableString</c> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.ToString">
            <summary>
Return a string representation of the object.
This returns the same string as <c>Value</c> property.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.Create(System.Char[])">
            <summary>
Static function to create a new instance copying from
the given character array.
</summary>
            <remarks>
Providing a null or zero size character array will return a null
<c>CacheableString</c> object.
</remarks>
            <param name="value">
the character array value of the new instance
</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableString.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserializes the managed object -- returns an instance of the
<c>IGFSerializable</c> class.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this managed object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.Create(System.String)">
            <summary>
Static function to create a new instance copying from
the given string.
</summary>
            <remarks>
Providing a null or zero size string will return a null
<c>CacheableString</c> object.
</remarks>
            <param name="value">the string value of the new instance</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.#ctor(System.Char[])">
            <summary>
Allocates a new instance copying from the given character array.
</summary>
            <param name="value">
the character array value of the new instance
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the provided array is null or has zero length
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableString.#ctor(System.String)">
            <summary>
Allocates a new instance copying from the given string.
</summary>
            <param name="value">the string value of the new instance</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the provided string is null or has zero length
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableString">
            <summary>
An immutable string wrapper that can serve as a distributable
key object for caching as well as being a string value.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.DataInput.m_buffer">
            <summary>
Internal buffer managed by the class.
This is freed in the disposer/destructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.#ctor(gemfire.DataInput*,System.Boolean)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.DataInput.BytesReadInternally">
            <summary>
Get the count of bytes that have been read from the stream, for internale use only.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.DataInput.NativeIntPtr">
            <summary>
Get the underlying native unmanaged pointer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.Reset">
            <summary>
Reset the cursor to the start of buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.RewindCursor(System.Int32)">
            <summary>
Rewind the cursor of the buffer by the given offset.
</summary>
            <param name="offset">
The offset(number of bytes) by which to rewind the cursor.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.AdvanceCursor(System.Int32)">
            <summary>
Advance the cursor of the buffer by the given offset.
</summary>
            <param name="offset">
The offset(number of bytes) by which to advance the cursor.
</param>
        </member>
        <member name="P:GemStone.GemFire.Cache.DataInput.BytesRemaining">
            <summary>
Get the count of bytes that are remaining in the buffer.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.DataInput.BytesRead">
            <summary>
Get the count of bytes that have been read from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadObject">
            <summary>
Read a serializable object from the data. Null objects are handled.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadASCIIHuge">
            <summary>
Read a ASCII string from the stream. Where size is more than 2^16-1 
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadUTFHuge">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadUTF">
            <summary>
Read a string after java-modified UTF-8 decoding from the stream.
The maximum length supported is 2^16-1 beyond which the string
shall be truncated.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadDouble">
            <summary>
Read a double precision number from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadFloat">
            <summary>
Read a floating point number from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadInt64">
            <summary>
Read a 64-bit integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadInt32">
            <summary>
Read a 32-bit integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadInt16">
            <summary>
Read a 16-bit integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadUInt64">
            <summary>
Read a 64-bit unsigned integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadArrayLen">
            <summary>
Read a array len based on array size.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadUInt32">
            <summary>
Read a 32-bit unsigned integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadUInt16">
            <summary>
Read a 16-bit unsigned integer from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadSBytesOnly(System.UInt32)">
            <summary>
Read the given number of signed bytes from the stream.
</summary>
            <param name="len">Number of signed bytes to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadBytesOnly(System.UInt32)">
            <summary>
Read the given number of bytes from the stream.
</summary>
            <param name="len">Number of bytes to read.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadSBytes">
            <summary>
Read an array of signed bytes from the stream reading the length
from the stream first.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadBytes">
            <summary>
Read an array of bytes from the stream reading the length
from the stream first.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadBoolean">
            <summary>
Read a boolean value from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadSByte">
            <summary>
Read a signed byte from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.ReadByte">
            <summary>
Read a byte from the stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.Finalize">
            <summary>
Finalizer: frees the internal buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.Dispose">
            <summary>
Dispose: frees the internal buffer.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.#ctor(System.Byte[],System.Int32)">
            <summary>
Construct <c>DataInput</c> using a given length of an array of
bytes.
</summary>
            <param name="buffer">
The buffer to use for reading data values.
</param>
            <param name="len">
The number of bytes from the start of the buffer to use.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the buffer is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.DataInput.#ctor(System.Byte[])">
            <summary>
Construct <c>DataInput</c> using an given array of bytes.
</summary>
            <param name="buffer">
The buffer to use for reading data values.
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the buffer is null
</exception>
        </member>
        <member name="T:GemStone.GemFire.Cache.DataInput">
            <summary>
Provides operations for reading primitive data values, byte arrays,
strings, <c>IGFSerializable</c> objects from a byte stream.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.CreateDeserializable">
            <summary>
Factory function to register this class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.CacheableDate.EpochTime">
            <summary>
                <c>DataTime</c> value since 1/1/1970
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableDate.Value">
            <summary>
Gets the <c>System.DateTime</c> value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.Equals(System.Object)">
            <summary>
Return true if this key matches other object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.Equals(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Return true if this key matches other object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.GetHashCode">
            <summary>
Return the hashcode for this key.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.ToString">
            <summary>
Return a string representation of the object.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableDate.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.CacheableDate.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.Create(System.DateTime)">
            <summary>
Static function that returns a new instance initialized to the
given <c>System.DateTime</c> value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.Create">
            <summary>
Static function that returns a new default instance.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.#ctor(System.DateTime)">
            <summary>
Initializes a new instance of the <c>CacheableDate</c> to the
given <c>System.DateTime</c> value.
</summary>
            <param name="dateTime">
A <c>System.DateTime</c> value to initialize this instance.
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableDate.#ctor">
            <summary>
Allocates a new default instance.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableDate">
            <summary>
An immutable date wrapper that can serve as a distributable
key object for caching as well as being a string value.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.#ctor(gemfire.Serializable*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.String)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a string
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.Int64)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a 64-bit integer
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.Int32)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a 32-bit integer
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.Char)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a character
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.Int16)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a 16-bit integer
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.Single)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a float
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.Double)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a double
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.Byte)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a byte
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.op_Implicit(System.Boolean)~GemStone.GemFire.Cache.CacheableKey">
            <summary>
Implicit conversion operator from a boolean
to a <c>CacheableKey</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.Equals(System.Object)">
            <summary>
Return true if this key matches other object.
It invokes the '==' operator if the underlying object is a
<c>gemfire::CacheableKey</c>, else returns
<c>System.Object.Equals()</c></summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.Equals(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Return true if this key matches other object. It invokes the '=='
operator of the underlying <c>gemfire::CacheableKey</c> object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.CacheableKey.GetHashCode">
            <summary>
Return the hashcode for this key.
It gets the hash code by calling the <c>hashcode()</c> function
of the underlying <c>gemfire::CacheableKey</c> object.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheableKey">
            <summary>
This class wraps the native C++ <c>gemfire::Serializable</c> objects
as managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" /> objects.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.GetWrapper(System.Byte)">
            <summary>
Static method to lookup the wrapper delegate for a given typeId.
</summary>
            <param name="typeId">
The typeId of the native <c>gemfire::Serializable</c> type.
</param>
            <returns>
If a managed wrapper is registered for the given typeId then the
wrapper delegate is returned, else this returns null.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.UnregisterNatives">
            <summary>
Internal static method to remove managed artifacts created by
RegisterType and RegisterWrapper methods when
<see cref="M:GemStone.GemFire.Cache.DistributedSystem.Disconnect" /> is called.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.RegisterWrapper(GemStone.GemFire.Cache.WrapperDelegate,System.Byte)">
            <summary>
Static method to register a managed wrapper for a native
<c>gemfire::Serializable</c> type.
</summary>
            <param name="wrapperMethod">
A factory delegate of the managed wrapper class that returns the
managed object given the native object.
</param>
            <param name="typeId">The typeId of the native type.</param>
            <seealso cref="F:GemStone.GemFire.Cache.Serializable.NativeWrappers" />
        </member>
        <member name="F:GemStone.GemFire.Cache.Serializable.NativeWrappers">
            <summary>
Static array of managed <c>WrapperDelegate</c> delegates that
maintains a mapping of built-in native typeIds to their corresponding
wrapper type delegates.
</summary>
            <remarks>
This is as an array to make lookup as fast as possible, taking
advantage of the fact that the range of wrapped built-in typeIds is
small. <b>IMPORTANT:</b> If the built-in native typeIds encompass a
greater range then change <c>WrapperEnd</c> in this accordingly
or move to using a Dictionary instead.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.GetManagedDelegate(System.Int64)">
            <summary>
This is to get manged delegates.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Serializable.ManagedDelegates">
            <summary>
Static map of <c>TypeFactoryMethod</c> delegates created
for managed <c>TypeFactoryMethod</c> delegates.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Serializable.BuiltInDelegates">
            <summary>
Static map of <c>TypeFactoryNativeMethod</c> delegates created
for builtin managed <c>TypeFactoryMethod</c> delegates.
This is so that the underlying managed objects do not get GCed.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Serializable.DelegateMap">
            <summary>
Static map of <c>TypeFactoryMethod</c> delegates created
from registered managed <c>TypeFactoryMethod</c> delegates.
This is for cross AppDomain object creations.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.Serializable.NativeDelegates">
            <summary>
Static list of <c>TypeFactoryNativeMethod</c> delegates created
from registered managed <c>TypeFactoryMethod</c> delegates.
This is so that the underlying managed objects do not get GCed.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.SetSP(gemfire.Serializable*)">
            <summary>
Used to assign the native Serializable pointer to a new object.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.AssignSP(gemfire.Serializable*)">
            <summary>
Used to assign the native Serializable pointer to a new object.
</summary>
            <remarks>
Note the order of preserveSB() and releaseSB(). This handles the
corner case when <c>m_nativeptr</c> is same as <c>nativeptr</c>.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.UnregisterType(System.Byte)">
            <summary>
Unregister the type with the given typeId
</summary>
            <param name="typeId">typeId of the type to unregister.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.RegisterType(System.Byte,GemStone.GemFire.Cache.TypeFactoryMethod)">
            <summary>
Register an instance factory method for a given type and typeId.
This should be used when registering types that implement
IGFSerializable.
</summary>
            <param name="typeId">typeId of the type being registered.</param>
            <param name="creationMethod">
the creation function to register
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the method is null
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.#ctor(gemfire.Serializable*)">
            <summary>
Internal constructor to wrap a native object pointer
</summary>
            <param name="nativeptr">The native object pointer</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.RegisterType(GemStone.GemFire.Cache.TypeFactoryMethod)">
            <summary>
Register an instance factory method for a given type.
This should be used when registering types that implement
IGFSerializable.
</summary>
            <param name="creationMethod">
the creation function to register
</param>
            <exception cref="T:GemStone.GemFire.Cache.IllegalArgumentException">
if the method is null
</exception>
            <exception cref="T:GemStone.GemFire.Cache.IllegalStateException">
if the typeId has already been registered, or there is an error
in registering the type; check <c>Utils::LastError</c> for more
information in the latter case.
</exception>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.String[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a string array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.String)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a string
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Int64[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a 64-bit integer array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Int64)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a 64-bit integer
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Int32[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a 32-bit integer array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Int32)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a 32-bit integer
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Int16[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a 16-bit integer array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Char[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a character array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Char)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a character
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Int16)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a 16-bit integer
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Single[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a float array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Single)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a float
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Double[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a double array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Double)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a double
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Boolean[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from an boolean array
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Byte[])~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from an array of bytes
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Byte)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a byte
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.op_Implicit(System.Boolean)~GemStone.GemFire.Cache.Serializable">
            <summary>
Implicit conversion operator from a boolean
to a <c>Serializable</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.ToString">
            <summary>
Return a string representation of the object.
It simply returns the string representation of the underlying
native object by calling its <c>toString()</c> function.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.Serializable.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.Serializable.ObjectSize">
            <summary>
return the size of this object in bytes
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserializes the native (C++) object -- returns an instance of the
<c>Serializable</c> class with the native object wrapped inside.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.Serializable.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this native (C++) object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Serializable">
            <summary>
This class wraps the native C++ <c>gemfire::Serializable</c> objects
as managed <see cref="T:GemStone.GemFire.Cache.IGFSerializable" /> objects.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.WrapperDelegate">
            <summary>
Delegate to wrap a native <c>gemfire::Serializable</c> type.
</summary>
            <remarks>
This delegate should return an object of type <c>IGFSerializable</c>
given a native object.
</remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.TypeFactoryMethod">
            <summary>
Signature of function delegates passed to
<see cref="M:GemStone.GemFire.Cache.Serializable.RegisterType(GemStone.GemFire.Cache.TypeFactoryMethod)" />. Such functions should
return an empty instance of the type they represent.
The delegate shall be stored in the internal <c>DelegateWrapper</c>
class and an instance will be initialized in the
<c>DelegateWrapper.NativeDelegate</c> method by a call to
<see cref="M:GemStone.GemFire.Cache.IGFSerializable.FromData(GemStone.GemFire.Cache.DataInput)" />.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.TypeFactoryNativeMethod">
            <summary>
Signature of native function delegates passed to native
<c>gemfire::Serializable::registerType</c>.
Such functions should return an empty instance of the type they
represent. The instance will typically be initialized immediately
after creation by a call to native
<c>gemfire::Serializable::fromData</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Debug(System.String,System.Object[])">
            <summary>
Debug level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Finest(System.String,System.Object[])">
            <summary>
Finest level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Finer(System.String,System.Object[])">
            <summary>
Finer level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Fine(System.String,System.Object[])">
            <summary>
Fine level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Config(System.String,System.Object[])">
            <summary>
Config level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Info(System.String,System.Object[])">
            <summary>
Info level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Warning(System.String,System.Object[])">
            <summary>
Warning level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Error(System.String,System.Object[])">
            <summary>
Error level logging with variable number of arguments using
format as in <c>System.String.Format</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.LogCatch(GemStone.GemFire.Cache.LogLevel,System.String,System.Exception)">
            <summary>
Logs both a message and a caught exception.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.LogThrow(GemStone.GemFire.Cache.LogLevel,System.String,System.Exception)">
            <summary>
Logs both a message and a thrown exception.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Write(GemStone.GemFire.Cache.LogLevel,System.String)">
            <summary>
Logs a message at the given level.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Enabled(GemStone.GemFire.Cache.LogLevel)">
            <summary>
True if log messages at the given level are enabled.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.LogFileName">
            <summary>
Returns the name of the current log file.
NOTE: This function is for debugging only, as it is not completely
thread-safe!
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.SetLevel(GemStone.GemFire.Cache.LogLevel)">
            <summary>
Sets the current log level.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Level">
            <summary>
Returns the current log level.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Close">
            <summary>
Closes logging facility (until next init).
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Init(GemStone.GemFire.Cache.LogLevel,System.String,System.Int32)">
            <summary>
Initializes logging facility with given level, filename, and file size limit.
</summary>
            <param name="level">the logging level</param>
            <param name="logFileName">the log file name</param>
            <param name="logFileLimit">maximum allowable size of the log file, in bytes, 
       or 0 for the default (1 Gbyte)</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.Log.Init(GemStone.GemFire.Cache.LogLevel,System.String)">
            <summary>
Initializes the logging facility with the given level and filename.
</summary>
            <param name="level">the logging level</param>
            <param name="logFileName">the log file name</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.Log">
            <summary>
Defines methods available to clients that want to write a log message
to their GemFire system's shared log file.
</summary>
            <remarks>
Any attempt to use an instance after its connection is disconnected
will throw a <c>NotConnectedException</c>.
<para>
For any logged message the log file will contain:
<ul><li> The message's log level.</li><li> The time the message was logged.</li><li> The ID of the connection and thread that logged the message.</li><li> The message itself, perhaps with
an exception including the exception's stack trace.</li></ul></para><para>
A message always has a level.
Logging levels are ordered. Enabling logging at a given level also
enables logging at higher levels. The higher the level the more
important and urgent the message.
</para><para>
The levels, in descending order of severity, are:
<ul><li><c>Error</c> (highest severity) is a message level
indicating a serious failure.  In general <c>error</c>
messages should describe events that are of considerable
importance and which will prevent normal program execution. They
should be reasonably intelligible to end users and to system
administrators.</li><li><c>Warning</c> is a message level indicating a
potential problem.  In general <c>warning</c> messages
should describe events that will be of interest to end users or
system managers, or which indicate potential problems.</li><li><c>Info</c> is a message level for informational
messages.  Typically <c>info</c> messages should be
reasonably significant and should make sense to end users and
system administrators.</li><li><c>Config</c> is a message level for static
configuration messages.  <c>config</c> messages are intended
to provide a variety of static configuration information, to
assist in debugging problems that may be associated with
particular configurations.</li><li><c>Fine</c> is a message level providing tracing
information.  In general the <c>fine</c> level should be
used for information that will be broadly interesting to
developers. This level is for the lowest volume, and most
important, tracing messages.</li><li><c>Finer</c> indicates a moderately detailed tracing
message.  This is an intermediate level between <c>fine</c>
and <c>finest</c>.</li><li><c>Finest</c> indicates a very detailed tracing
message.  Logging calls for entering, returning, or throwing an
exception are traced at the <c>finest</c> level.</li><li><c>Debug</c> (lowest severity) indicates a highly
detailed tracing message.  In general the <c>debug</c> level
should be used for the most voluminous detailed tracing messages.</li></ul></para></remarks>
        </member>
        <member name="T:GemStone.GemFire.Cache.LogLevel">
            <summary>
Logging levels.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.All">
            <summary>
All the log messages.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Debug">
            <summary>
For highly detailed tracing information.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Finest">
            <summary>
For very detailed tracing information.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Finer">
            <summary>
For moderately detailed tracing information.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Fine">
            <summary>
For tracing information.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Config">
            <summary>
For Static configuration messages.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Default">
            <summary>
The default logging level.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Info">
            <summary>
For informational purpose.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Warning">
            <summary>
Indicates potential problem.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Error">
            <summary>
Indicates serious failure.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.LogLevel.Null">
            <summary>
No log.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IGFDelta.HasDelta">
            <summary>
                <c>HasDelta( )</c> is invoked by GemFire during <c>Region.Put( ICacheableKey, IGFSerializable )</c> to determine if the object contains a delta.
If <c>HasDelta( )</c> returns true, the delta in the object is serialized by invoking <c>ToDelta( DataOutput )</c>.
If <c>HasDelta( )</c> returns false, the object is serialized by invoking <c>IGFSerializable.ToData( DataOutput )</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.IGFDelta.FromDelta(GemStone.GemFire.Cache.DataInput)">
            <summary>
Reads in delta information to this object in a user-defined format. This is
invoked on an existing application object after GemFire determines the
presence of delta in <c>DataInput</c> instance.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.InvalidDeltaException">
if the delta in the <c>DataInput</c> instance cannot be applied
to this instance (possible causes may include mismatch of Delta version or logic error).
</exception>
            <exception cref="T:GemStone.GemFire.Cache.GemFireIOException" />
        </member>
        <member name="M:GemStone.GemFire.Cache.IGFDelta.ToDelta(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Writes out delta information to out in a user-defined format. This is
invoked on an application object after GemFire determines the presence
of delta in it by calling <c>HasDelta()</c> on the object.
</summary>
            <exception cref="T:GemStone.GemFire.Cache.GemFireIOException" />
        </member>
        <member name="T:GemStone.GemFire.Cache.IGFDelta">
            <summary>
This interface is used for delta propagation.
To use delta propagation, an application class must implement interfaces <c>IGFDelta</c> as well as <c>IGFSerializable</c>.
The <c>IGFDelta</c> interface methods <c>HasDelta( ), ToDelta( )</c> and <c>FromDelta( )</c> must be implemented by the class, as these methods are used by GemFire
to detect the presence of delta in an object, to serialize the delta, and to apply a serialized delta to an existing object
of the class.
If a customized cloning method is required, the class must also implement the interface <c>System.ICloneable</c>.
To use cloning in delta propagation for a region, the region attribute for cloning must be enabled.
</summary>
        </member>
        <member name="T:gemfire.CacheableLinkedHashSet">
A mutable <code>CacheableKey</code> hash set wrapper that can serve as
a distributable object for caching. This is provided for compability
with java side, though is functionally identical to
<code>CacheableHashSet</code> i.e. does not provide the predictable
iteration semantics of java <code>LinkedHashSet</code>.

</member>
        <member name="T:gemfire.CacheableIdentityHashMap">
A mutable <code>CacheableKey</code> to <code>Serializable</code>
hash map that can serve as a distributable object for caching. This is
provided for compability with java side, though is functionally identical
to <code>CacheableHashMap</code> i.e. does not provide the semantics of
java <code>IdentityHashMap</code>.

</member>
        <member name="T:gemfire.CacheableHashTable">
A mutable <code>CacheableKey</code> to <code>Serializable</code>
hash map that can serve as a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableStack">
A mutable <code>Cacheable</code> stack wrapper that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableArrayList">
A mutable <code>Cacheable</code> array list wrapper that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableHashSet">
A mutable <code>CacheableKey</code> hash set wrapper that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableHashMap">
A mutable <code>CacheableKey</code> to <code>Serializable</code>
hash map that can serve as a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableVector">
A mutable <code>Cacheable</code> vector wrapper that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableStringArray">
An immutable wrapper for array of strings that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableInt64Array">
An immutable wrapper for array of 64-bit integers that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableInt32Array">
An immutable wrapper for array of 32-bit integers that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableInt16Array">
An immutable wrapper for array of 16-bit integers that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableFloatArray">
An immutable wrapper for array of floats that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableDoubleArray">
An immutable wrapper for array of doubles that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableBytes">
An immutable wrapper for byte arrays that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CharArray">
An immutable wrapper for array of wide-characters that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableWideChar">
An immutable wrapper for wide-characters that can serve as
a distributable key object for caching.

</member>
        <member name="T:gemfire.CacheableInt64">
An immutable wrapper for 64-bit integers that can serve as
a distributable key object for caching.

</member>
        <member name="T:gemfire.CacheableInt32">
An immutable wrapper for 32-bit integers that can serve as
a distributable key object for caching.

</member>
        <member name="T:gemfire.CacheableInt16">
An immutable wrapper for 16-bit integers that can serve as
a distributable key object for caching.

</member>
        <member name="T:gemfire.CacheableFloat">
An immutable wrapper for floats that can serve as
a distributable key object for caching.

</member>
        <member name="T:gemfire.CacheableDouble">
An immutable wrapper for doubles that can serve as
a distributable key object for caching.

</member>
        <member name="T:gemfire.CacheableByte">
An immutable wrapper for bytes that can serve as
a distributable key object for caching.

</member>
        <member name="T:gemfire.BooleanArray">
An immutable wrapper for array of booleans that can serve as
a distributable object for caching.

</member>
        <member name="T:gemfire.CacheableBoolean">
An immutable wrapper for booleans that can serve as
a distributable key object for caching.

</member>
        <member name="M:gemfire.gf_snprintf(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
snprintf implementation. 
</member>
        <member name="M:gemfire.gf_sprintf(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
sprintf implementation. 
</member>
        <member name="M:gemfire.HashSetOfCacheableKey.#ctor(gemfire.HashSetOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:gemfire.HashSetOfCacheableKey.#ctor(System.Int32)">
Creates an empty hash set with at least n buckets. 
</member>
        <member name="M:gemfire.HashSetOfCacheableKey.#ctor">
Create an empty HashSet. 
</member>
        <member name="D:gemfire.HashSetOfCacheableKey.Iterator">
Iterator class for the hash set. 
</member>
        <member name="T:gemfire.HashSetOfCacheableKey">
A hash set of <code>CacheableKey</code> objects that also extends
<code>SharedBase</code> for smart pointers.

</member>
        <member name="M:gemfire.HashSetOfSharedBase.Dispose">
Destructor, sets all SharedPtr elements to NULLPTR. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.#ctor(gemfire.HashSetOfSharedBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.#ctor(System.Int32,=FUNC:System.Int32(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced),=FUNC:System.Boolean(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced))">
Creates an empty hash_set with at least n buckets,
       * using h as the hash function and k as the key equal function.

</member>
        <member name="M:gemfire.HashSetOfSharedBase.#ctor(=FUNC:System.Int32(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced),=FUNC:System.Boolean(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced))">
Creates an empty hash_set using h as the hash function
       * and k as the key equal function.

</member>
        <member name="M:gemfire.HashSetOfSharedBase.op_Assign(gemfire.HashSetOfSharedBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.end">
Get an iterator pointing to the end of hash_set. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.begin">
Get an iterator pointing to the start of hash_set. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.count(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Counts the number of elements whose key is k. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.contains(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check if a given key k exists in the hash_set. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.clear">
Erases all of the elements. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.erase(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Erases the element whose key is k. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.insert(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Inserts the key k into the hash_set. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.swap(gemfire.HashSetOfSharedBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Swaps the contents of two hash_sets. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.resize(System.Int32)">
Increases the bucket count to at least n. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.bucket_count">
Returns the number of buckets used by the hash_set. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.empty">
true if the hash_set's size is 0. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.max_size">
Returns the largest possible size of the hash_set. 
</member>
        <member name="M:gemfire.HashSetOfSharedBase.size">
Returns the size of the hash_set. 
</member>
        <member name="T:gemfire.HashSetOfSharedBase.Iterator">
Interface of an iterator for <code>HashSetOfSharedBase</code>.
</member>
        <member name="T:gemfire.HashSetOfSharedBase">
Represents a HashSet of <code>SharedBase</code></member>
        <member name="M:gemfire.HashMapOfException.#ctor(gemfire.HashMapOfException!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:gemfire.HashMapOfException.#ctor(System.Int32)">
Creates an empty hash map with at least n buckets. 
</member>
        <member name="M:gemfire.HashMapOfException.#ctor">
Creates an empty hash map. 
</member>
        <member name="D:gemfire.HashMapOfException.Iterator">
Iterator class for the hash map. 
</member>
        <member name="T:gemfire.HashMapOfException">
A map of <code>CacheableKey</code> objects to <code>Exception</code>
that also extends <code>SharedBase</code> for smart pointers.

</member>
        <member name="M:gemfire.HashMapOfCacheable.#ctor(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:gemfire.HashMapOfCacheable.#ctor(System.Int32)">
Creates an empty hash map with at least n buckets. 
</member>
        <member name="M:gemfire.HashMapOfCacheable.#ctor">
Creates an empty hash map. 
</member>
        <member name="D:gemfire.HashMapOfCacheable.Iterator">
Iterator class for the hash map. 
</member>
        <member name="T:gemfire.HashMapOfCacheable">
A map of <code>CacheableKey</code> objects to <code>Cacheable</code>
that also extends <code>SharedBase</code> for smart pointers.

</member>
        <member name="M:gemfire.HashMapOfSharedBase.Dispose">
Destructor, sets all SharedPtr elements to NULLPTR. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.#ctor(gemfire.HashMapOfSharedBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.#ctor(System.Int32,=FUNC:System.Int32(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced),=FUNC:System.Boolean(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced))">
Creates an empty hash_map with at least n buckets,
       * using h as the hash function and k as the key equal function.

</member>
        <member name="M:gemfire.HashMapOfSharedBase.#ctor(=FUNC:System.Int32(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced),=FUNC:System.Boolean(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced))">
Creates an empty hash_map using h as the hash function
       * and k as the key equal function.

</member>
        <member name="M:gemfire.HashMapOfSharedBase.op_Assign(gemfire.HashMapOfSharedBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.end">
Get an iterator pointing to the end of hash_map. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.begin">
Get an iterator pointing to the start of hash_map. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.op_Subscript(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a reference to the object that is associated
       * with a particular key.

</member>
        <member name="M:gemfire.HashMapOfSharedBase.count(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Counts the number of elements whose key is k. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.find(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Finds an element whose key is k. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.contains(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Check if a given key k exists in the hash_map. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.clear">
Erases all of the elements. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.erase(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Erases the element whose key is k. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.swap(gemfire.HashMapOfSharedBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Swaps the contents of two hash_maps. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.resize(System.Int32)">
Increases the bucket count to at least n. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.bucket_count">
Returns the number of buckets used by the hash_map. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.empty">
true if the hash_map's size is 0. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.max_size">
Returns the largest possible size of the hash_map. 
</member>
        <member name="M:gemfire.HashMapOfSharedBase.size">
Returns the size of the hash_map. 
</member>
        <member name="T:gemfire.HashMapOfSharedBase.Iterator">
Interface of an iterator for <code>HashMapOfSharedBase</code>.
</member>
        <member name="T:gemfire.HashMapOfSharedBase">
Represents a HashMap of <code>SharedBase</code></member>
        <member name="D:gemfire.EqualTo">
typedef for the hashing key equality function. 
</member>
        <member name="D:gemfire.Hasher">
typedef for the hash function used by the hashing schemes. 
</member>
        <member name="M:gemfire.VectorOfCacheableKey.#ctor(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor 
</member>
        <member name="M:gemfire.VectorOfCacheableKey.#ctor(System.Int32,gemfire.SharedPtr&lt;gemfire.CacheableKey&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a vector with n copies of t 
</member>
        <member name="M:gemfire.VectorOfCacheableKey.#ctor(System.Int32)">
Create a vector with n elements allocated 
</member>
        <member name="M:gemfire.VectorOfCacheableKey.#ctor">
Create an empty vector. 
</member>
        <member name="D:gemfire.VectorOfCacheableKey.Iterator">
Iterator class for the vector. 
</member>
        <member name="T:gemfire.VectorOfCacheableKey">
A vector of <code>CacheableKey</code> objects that also extends
<code>SharedBase</code> for smart pointers.

</member>
        <member name="M:gemfire.VectorOfCacheable.#ctor(gemfire.VectorOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:gemfire.VectorOfCacheable.#ctor(System.Int32,gemfire.SharedPtr&lt;gemfire.Serializable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a vector with n copies of t. 
</member>
        <member name="M:gemfire.VectorOfCacheable.#ctor(System.Int32)">
Create a vector with n elements allocated. 
</member>
        <member name="M:gemfire.VectorOfCacheable.#ctor">
Create an empty vector. 
</member>
        <member name="D:gemfire.VectorOfCacheable.Iterator">
Iterator class for the vector. 
</member>
        <member name="T:gemfire.VectorOfCacheable">
A vector of <code>Cacheable</code> objects that also extends
<code>SharedBase</code> for smart pointers.

</member>
        <member name="M:gemfire.VectorOfSharedBase.erase(System.Int32)">
removes the object at the specified index from a vector

</member>
        <member name="M:gemfire.VectorOfSharedBase.insert(System.Int32,gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
insert object at the given index. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.resize(System.Int32,gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inserts or erases elements at the end such that size becomes n.
     *  Not to be confused with reserve which simply allocates the space,
     *  resize fills the space with active elements. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.clear">
erases all elements. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.swap(gemfire.VectorOfSharedBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
swaps the contents of two vectors. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.pop_back">
removes the last element. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.push_back(gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
insert a new element at the end. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.back">
returns the last element. 

returns the last element. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.front">
returns the first element. 

returns the first element. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.reserve(System.Int32)">
reallocate a vector to hold n elements. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.op_Assign(gemfire.VectorOfSharedBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
assignment operator 
</member>
        <member name="M:gemfire.VectorOfSharedBase.Dispose">
destructor, sets all SharedPtr elements to NULLPTR 
</member>
        <member name="M:gemfire.VectorOfSharedBase.#ctor(gemfire.VectorOfSharedBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
copy constructor 
</member>
        <member name="M:gemfire.VectorOfSharedBase.#ctor(System.Int32,gemfire.SharedPtr&lt;gemfire.SharedBase&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a vector with n copies of t 
</member>
        <member name="M:gemfire.VectorOfSharedBase.#ctor(System.Int32)">
Create a vector with n elements allocated 
</member>
        <member name="M:gemfire.VectorOfSharedBase.#ctor">
Create an empty vector. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.end">
Get an iterator pointing to the end of vector. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.begin">
Get an iterator pointing to the start of vector. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.at(System.Int32)">
Return the n'th element with bounds checking. 

Return the n'th element with bounds checking. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.op_Subscript(System.Int32)">
Return the n'th element 

Return the n'th element 
</member>
        <member name="M:gemfire.VectorOfSharedBase.empty">
return true if the vector's size is 0. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.capacity">
return the number of elements allocated for this vector. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.max_size">
return the largest possible size of the vector. 
</member>
        <member name="M:gemfire.VectorOfSharedBase.size">
return the size of the vector. 
</member>
        <member name="T:gemfire.VectorOfSharedBase.Iterator">
Interface of an iterator for <code>VectorOfSharedBase</code>.
</member>
        <member name="T:gemfire.VectorOfSharedBase">
Represents a vector of <code>gemfire::SharedBasePtr</code></member>
        <member name="M:gemfire.DataInput.reset">
reset the cursor to the start of buffer 
</member>
        <member name="M:gemfire.DataInput.rewindCursor(System.Int32)">
rewind the cursor by given offset 
</member>
        <member name="M:gemfire.DataInput.advanceCursor(System.Int32)">
advance the cursor by given offset 
</member>
        <member name="M:gemfire.DataInput.getBytesRemaining">
get the number of bytes remaining to be read in the buffer 
</member>
        <member name="M:gemfire.DataInput.getBytesRead">
get the number of bytes read in the buffer 
</member>
        <member name="M:gemfire.DataInput.currentBufferPosition">
Get the pointer to current buffer position. This should be treated
as readonly and modification of contents using this internal pointer
has undefined behavior.

</member>
        <member name="M:gemfire.DataInput.Dispose">
destructor 
</member>
        <member name="M:gemfire.DataInput.#ctor(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
constructor given a pre-allocated byte array with size 
</member>
        <member name="M:gemfire.DataInput.getDecodedLength(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
 Get the length required to represent a given UTF-8 encoded string
 (created using {@link DataOutput::writeUTF} or
 <code>java.io.DataOutput.writeUTF</code>) in wide-character format.

 @param value The UTF-8 encoded stream.
 @param length The length of the stream to be read.
 @return The length of the decoded string.
 @see DataOutput::getEncodedLength

</member>
        <member name="M:gemfire.DataInput.readObject(gemfire.SharedPtr&lt;gemfire.Serializable&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Read a <code>Serializable</code> object from the <code>DataInput</code>.
Null objects are handled.

</member>
        <member name="M:gemfire.DataInput.readUTFHuge(System.Char**,System.UInt32*)">
 Allocates a wide-character string buffer, and reads a java
 modified UTF-8 encoded string from <code>DataInput</code> into it.
 @remarks Sets integer at length to hold the strlen of the string. Value
   is modified to point to the new allocation. The chars are allocated as
   an array, so the caller must use <code>freeUTFMemory</code> when done.
   Use this instead of <code>readUTF</code> when reading a string of length
   greater than 64K.

 @param value output wide-character string to hold the read characters;
   it is allocated by this method
 @param len output parameter to hold the number of characters read from
   stream; not set if NULL

</member>
        <member name="M:gemfire.DataInput.readUTF(System.Char**,System.UInt16*)">
 Allocates a wide-character string buffer, and reads a java
 modified UTF-8 encoded string having maximum encoded length of 64K from
 <code>DataInput</code> into it.
 @remarks Sets integer at length to hold the strlen of the string. Value
   is modified to point to the new allocation. The chars are allocated as
   an array, so the caller must use <code>freeUTFMemory</code> when done.
   Like <code>DataOutput::writeUTF</code> the maximum length supported by
   this method is 64K; use <code>readAUTFHuge</code> to read strings of
   length larger than this.

 @param value output wide-character string to hold the read characters;
   it is allocated by this method
 @param len output parameter to hold the number of characters read from
   stream; not set if NULL

</member>
        <member name="M:gemfire.DataInput.readUTFHuge(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.UInt32*)">
 Allocates a c string buffer, and reads a java modified UTF-8
 encoded string from <code>DataInput</code> into it.
 @remarks Sets integer at length to hold the strlen of the string. Value
   is modified to point to the new allocation. The chars are allocated as
   an array, so the caller must use <code>freeUTFMemory</code> when done.
   Use this instead of <code>readUTF</code> when reading a string of length
   greater than 64K.

 @param value output C string to hold the read characters; it is allocated
   by this method
 @param len output parameter to hold the number of characters read from
   stream; not set if NULL

</member>
        <member name="M:gemfire.DataInput.readUTFNoLen(System.Char**,System.UInt16)">
Reads a java modified UTF-8 encoded string having maximum encoded length
of 64K without reading the length which must be passed as a parameter.
Allocates a c string buffer, and deserializes into it. Sets integer at
length to hold the length of the string. Value is modified to point to the
new allocation. The chars are allocated as an array, so the caller must
use freeUTFMemory when done.
If len == NULL, then the decoded string length is not set.

</member>
        <member name="M:gemfire.DataInput.readUTF(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.UInt16*)">
 Allocates a c string buffer, and reads a java modified UTF-8
 encoded string having maximum encoded length of 64K from
 <code>DataInput</code> into it.
 @remarks Sets integer at length to hold the strlen of the string. Value
   is modified to point to the new allocation. The chars are allocated as
   an array, so the caller must use <code>freeUTFMemory</code> when done.
   Like <code>DataOutput::writeUTF</code> the maximum length supported by
   this method is 64K; use <code>readAUTFHuge</code> to read strings of
   length larger than this.

 @param value output C string to hold the read characters; it is allocated
   by this method
 @param len output parameter to hold the number of characters read from
   stream; not set if NULL

</member>
        <member name="M:gemfire.DataInput.readASCIIHuge(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.UInt32*)">
 Allocates a c string buffer, and reads an ASCII string
 from <code>DataInput</code> into it.
 @remarks Sets integer at length to hold the strlen of the string. Value
   is modified to point to the new allocation. The chars are allocated as
   an array, so the caller must use <code>freeUTFMemory</code> when done.
   Use this instead of <code>readUTF</code> when reading a string of length
   greater than 64K.

 @param value output C string to hold the read characters; it is allocated
   by this method
 @param len output parameter to hold the number of characters read from
   stream; not set if NULL

</member>
        <member name="M:gemfire.DataInput.readASCII(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.UInt16*)">
 Allocates a c string buffer, and reads an ASCII string
 having maximum length of 64K from <code>DataInput</code> into it.
 @remarks Sets integer at length to hold the strlen of the string. Value
   is modified to point to the new allocation. The chars are allocated as
   an array, so the caller must use <code>freeUTFMemory</code> when done.
   Like <code>DataOutput::writeASCII</code> the maximum length supported by
   this method is 64K; use <code>readASCIIHuge</code> or
   <code>readBytes</code> to read strings of length larger than this.

 @param value output C string to hold the read characters; it is allocated
   by this method
 @param len output parameter to hold the number of characters read from
   stream; not set if NULL

</member>
        <member name="M:gemfire.DataInput.freeUTFMemory(System.Char*)">
free the wide-characted string allocated by <code>readASCII</code>,
<code>readASCIIHuge</code>, <code>readUTF</code>,
<code>readUTFHuge</code> methods

</member>
        <member name="M:gemfire.DataInput.freeUTFMemory(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
free the C string allocated by <code>readASCII</code>,
<code>readASCIIHuge</code>, <code>readUTF</code>,
<code>readUTFHuge</code> methods

</member>
        <member name="M:gemfire.DataInput.readDouble(System.Double*)">
 Read a double precision number from the <code>DataInput</code>.

 @param value output parameter to hold the double precision number
   read from stream

</member>
        <member name="M:gemfire.DataInput.readFloat(System.Single*)">
 Read a float from the <code>DataInput</code>.

 @param value output parameter to hold the float read from stream

</member>
        <member name="M:gemfire.DataInput.readArrayLen(System.Int32*)">
 Read a 32-bit signed integer array length value from the
 <code>DataInput</code> in a manner compatible with java server's
 <code>DataSerializer.readArrayLength</code>.

 @param len output parameter to hold the 32-bit signed length
   read from stream

</member>
        <member name="M:gemfire.DataInput.readInt(System.Int64*)">
 Read a 64-bit signed integer from the <code>DataInput</code>.

 @param value output parameter to hold the 64-bit signed integer
   read from stream

</member>
        <member name="M:gemfire.DataInput.readInt(System.Int32*)">
 Read a 32-bit signed integer from the <code>DataInput</code>.

 @param value output parameter to hold the 32-bit signed integer
   read from stream

</member>
        <member name="M:gemfire.DataInput.readInt(System.Int16*)">
 Read a 16-bit signed integer from the <code>DataInput</code>.

 @param value output parameter to hold the 16-bit signed integer
   read from stream

</member>
        <member name="M:gemfire.DataInput.readInt(System.UInt64*)">
 Read a 64-bit unsigned integer from the <code>DataInput</code>.

 @param value output parameter to hold the 64-bit unsigned integer
   read from stream

</member>
        <member name="M:gemfire.DataInput.readInt(System.UInt32*)">
 Read a 32-bit unsigned integer from the <code>DataInput</code>.

 @param value output parameter to hold the 32-bit unsigned integer
   read from stream

</member>
        <member name="M:gemfire.DataInput.readInt(System.UInt16*)">
 Read a 16-bit unsigned integer from the <code>DataInput</code>.

 @param value output parameter to hold the 16-bit unsigned integer
   read from stream

</member>
        <member name="M:gemfire.DataInput.readBytes(System.SByte**,System.Int32*)">
 Read an array of signed bytes from the <code>DataInput</code>
 expecting to find the length of array in the stream at the start.
 @remarks This method is complimentary to
   <code>DataOutput::writeBytes</code>.

 @param bytes output array to hold the bytes read from stream; the array
   is allocated by this method
 @param len output parameter to hold the length of array read from stream

</member>
        <member name="M:gemfire.DataInput.readBytes(System.Byte**,System.Int32*)">
 Read an array of unsigned bytes from the <code>DataInput</code>
 expecting to find the length of array in the stream at the start.
 @remarks This method is complimentary to
   <code>DataOutput::writeBytes</code>.

 @param bytes output array to hold the bytes read from stream; the array
   is allocated by this method
 @param len output parameter to hold the length of array read from stream

</member>
        <member name="M:gemfire.DataInput.readBytesOnly(System.SByte*,System.UInt32)">
 Read the given number of signed bytes from the <code>DataInput</code>.
 @remarks This method is complimentary to
   <code>DataOutput::writeBytesOnly</code> and, unlike
   <code>readBytes</code>, does not expect the length of array
   in the stream.

 @param buffer array to hold the bytes read from stream
 @param len number of signed bytes to be read

</member>
        <member name="M:gemfire.DataInput.readBytesOnly(System.Byte*,System.UInt32)">
 Read the given number of unsigned bytes from the <code>DataInput</code>.
 @remarks This method is complimentary to
   <code>DataOutput::writeBytesOnly</code> and, unlike
   <code>readBytes</code>, does not expect the length of array
   in the stream.

 @param buffer array to hold the bytes read from stream
 @param len number of unsigned bytes to be read

</member>
        <member name="M:gemfire.DataInput.readBoolean(System.Boolean*)">
 Read a boolean value from the <code>DataInput</code>.

 @param value output parameter to hold the boolean read from stream

</member>
        <member name="M:gemfire.DataInput.read(System.SByte*)">
 Read a signed byte from the <code>DataInput</code>.

 @param value output parameter to hold the signed byte read from stream

</member>
        <member name="M:gemfire.DataInput.read(System.Byte*)">
 Read an unsigned byte from the <code>DataInput</code>.

 @param value output parameter to hold the unsigned byte read from stream

</member>
        <member name="T:gemfire.DataInput">
Provide operations for reading primitive data values, byte arrays,
strings, <code>Serializable</code> objects from a byte stream.
This class is intentionally not thread safe.
@remarks None of the output parameters in the methods below can be NULL
  unless otherwise noted.

</member>
        <member name="M:gemfire.DataOutput.reset">
Reset the internal cursor to the start of the buffer.

</member>
        <member name="M:gemfire.DataOutput.getBufferLength">
Get the length of current data in the internal buffer of
<code>DataOutput</code>.

</member>
        <member name="M:gemfire.DataOutput.getBuffer(System.UInt32*)">
 Get a pointer to the internal buffer of <code>DataOutput</code>.

 @param rsize the size of buffer is filled in this output parameter;
   should not be NULL

</member>
        <member name="M:gemfire.DataOutput.getRemainingBufferLength">
Get a pointer to the internal buffer of <code>DataOutput</code>.

</member>
        <member name="M:gemfire.DataOutput.getBuffer">
Get a pointer to the internal buffer of <code>DataOutput</code>.

</member>
        <member name="M:gemfire.DataOutput.Dispose">
destructor 
</member>
        <member name="M:gemfire.DataOutput.rewindCursor(System.UInt32)">
 Rewind the buffer cursor by the given offset.

 @param offset the offset by which to rewind the cursor

</member>
        <member name="M:gemfire.DataOutput.advanceCursor(System.UInt32)">
 Advance the buffer cursor by the given offset.

 @param offset the offset by which to advance the cursor

</member>
        <member name="M:gemfire.DataOutput.getCursor">
Get an internal pointer to the current location in the
<code>DataOutput</code> byte array.

</member>
        <member name="M:gemfire.DataOutput.writeObject(gemfire.Serializable!System.Runtime.CompilerServices.IsConst*)">
 Write a <code>Serializable</code> object to the <code>DataOutput</code>.

 @param objptr pointer to the <code>Serializable</code> object
   to be written

</member>
        <member name="M:gemfire.DataOutput.getEncodedLength(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32*)">
 Get the length required to represent a given wide-character string in
 java modified UTF-8 format.

 @param value The wide-character string.
 @param length The length of the string.
 @return The length required for representation in java modified
         UTF-8 format.
 @see DataInput::getDecodedLength

</member>
        <member name="M:gemfire.DataOutput.getEncodedLength(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32*)">
 Get the length required to represent a given wide-character string in
 java modified UTF-8 format.

 @param value The C string.
 @param length The length of the string; or zero to use the full string.
 @return The length required for representation in java modified
         UTF-8 format.
 @see DataInput::getDecodedLength

</member>
        <member name="M:gemfire.DataOutput.writeUTFHuge(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Writes the given string using java modified UTF-8 encoding.
 @remarks Use this to write large strings. The other
   <code>writeUTF</code> method will truncate strings greater than
   64K in size.

 @param value the wide-character string to be written
 @param length the number of characters from start of string to be
   written; the default value of 0 implies the complete string

</member>
        <member name="M:gemfire.DataOutput.writeUTF(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Writes the given given string using java modified UTF-8 encoding
 supporting maximum encoded length of 64K (i.e. unsigned 16-bit integer).
 @remarks The string will be truncated if greater than the maximum
   permissible length of 64K. Use <code>writeUTFHuge</code> to write
   strings of length larger than this.

 @param value the wide-character string to be written
 @param length the number of characters from start of string to be
   written; the default value of 0 implies the complete string

</member>
        <member name="M:gemfire.DataOutput.writeUTFHuge(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Writes the given string using java modified UTF-8 encoding.
 @remarks Use this to write large strings. The other
   <code>writeUTF</code> method will truncate strings greater than
   64K in size.

 @param value the C string to be written
 @param length the number of characters from start of string to be
   written; the default value of 0 implies the complete string
   assuming a null terminated string; do not use this unless sure
   that the UTF string does not contain any null characters

</member>
        <member name="M:gemfire.DataOutput.writeUTF(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Writes the given given string using java modified UTF-8 encoding
 supporting maximum encoded length of 64K (i.e. unsigned 16-bit integer).
 @remarks The string will be truncated if greater than the maximum
   permissible length of 64K. Use <code>writeUTFHuge</code> to write
   strings of length larger than this.

 @param value the C string to be written
 @param length the number of characters from start of string to be
   written; the default value of 0 implies the complete string

</member>
        <member name="M:gemfire.DataOutput.writeASCIIHuge(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Writes the given ASCII string supporting upto maximum 32-bit
 integer value.
 @remarks Use this to write large ASCII strings. The other
   <code>writeASCII</code> method will truncate strings greater than
   64K in size.

 @param value the wide-character string to be written
 @param length the number of characters from start of string to be
   written; the default value of 0 implies the complete string

</member>
        <member name="M:gemfire.DataOutput.writeASCII(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Writes the given ASCII string supporting maximum length of 64K
 (i.e. unsigned 16-bit integer).
 @remarks The string will be truncated if greater than the maximum
   permissible length of 64K. Use <code>writeBytes</code> or
   <code>writeASCIIHuge</code> to write ASCII strings of length larger
   than this.

 @param value the C string to be written
 @param length the number of characters from start of string to be
   written; the default value of 0 implies the complete string

</member>
        <member name="M:gemfire.DataOutput.writeDouble(System.Double)">
 Write a double precision real number to the <code>DataOutput</code>.

 @param value the double precision real number to be written

</member>
        <member name="M:gemfire.DataOutput.writeFloat(System.Single)">
 Write a float value to the <code>DataOutput</code>.

 @param value the float value to be written

</member>
        <member name="M:gemfire.DataOutput.writeArrayLen(System.Int32)">
 Write a 32-bit signed integer array length value to the
 <code>DataOutput</code> in a manner compatible with java server's
 <code>DataSerializer.writeArrayLength</code>.

 @param value the 32-bit signed integer array length to be written

</member>
        <member name="M:gemfire.DataOutput.writeInt(System.Int64)">
 Write a 64-bit signed integer value to the <code>DataOutput</code>.

 @param value the 64-bit signed integer value to be written

</member>
        <member name="M:gemfire.DataOutput.writeInt(System.Int32)">
 Write a 32-bit signed integer value to the <code>DataOutput</code>.

 @param value the 32-bit signed integer value to be written

</member>
        <member name="M:gemfire.DataOutput.writeInt(System.Int16)">
 Write a 16-bit signed integer value to the <code>DataOutput</code>.

 @param value the 16-bit signed integer value to be written

</member>
        <member name="M:gemfire.DataOutput.writeInt(System.UInt64)">
 Write a 64-bit unsigned integer value to the <code>DataOutput</code>.

 @param value the 64-bit unsigned integer value to be written

</member>
        <member name="M:gemfire.DataOutput.writeInt(System.UInt32)">
 Write a 32-bit unsigned integer value to the <code>DataOutput</code>.

 @param value the 32-bit unsigned integer value to be written

</member>
        <member name="M:gemfire.DataOutput.writeInt(System.UInt16)">
 Write a 16-bit unsigned integer value to the <code>DataOutput</code>.

 @param value the 16-bit unsigned integer value to be written

</member>
        <member name="M:gemfire.DataOutput.writeBytesOnly(System.SByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Write an array of signed bytes without its length to the
 <code>DataOutput</code>.
 @remarks The difference between this and <code>writeBytes</code> is that
   this does write the length of bytes so the corresponding
   <code>DataInput::readBytesOnly</code> (unlike
   <code>DataInput::readBytes</code>) needs the length argument explicitly.

 @param value the array of signed bytes to be written
 @param len the number of bytes from the start of array to be written

</member>
        <member name="M:gemfire.DataOutput.writeBytesOnly(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
 Write an array of unsigned bytes without its length to the
 <code>DataOutput</code>.
 @remarks The difference between this and <code>writeBytes</code> is that
   this does write the length of bytes so the corresponding
   <code>DataInput::readBytesOnly</code> (unlike
   <code>DataInput::readBytes</code>) needs the length argument explicitly.

 @param value the array of unsigned bytes to be written
 @param len the number of bytes from the start of array to be written

</member>
        <member name="M:gemfire.DataOutput.writeBytes(System.SByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
 Write an array of signed bytes to the <code>DataOutput</code>.

 @param value the array of signed bytes to be written
 @param len the number of bytes from the start of array to be written

</member>
        <member name="M:gemfire.DataOutput.writeBytes(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
 Write an array of unsigned bytes to the <code>DataOutput</code>.

 @param value the array of unsigned bytes to be written
 @param len the number of bytes from the start of array to be written

</member>
        <member name="M:gemfire.DataOutput.writeBoolean(System.Boolean)">
 Write a boolean value to the <code>DataOutput</code>.

 @param value the boolean value to be written

</member>
        <member name="M:gemfire.DataOutput.write(System.SByte)">
 Write a signed byte to the <code>DataOutput</code>.

 @param value the signed byte to be written

</member>
        <member name="M:gemfire.DataOutput.write(System.Byte)">
 Write an unsigned byte to the <code>DataOutput</code>.

 @param value the unsigned byte to be written

</member>
        <member name="M:gemfire.DataOutput.#ctor">
Construct a new DataOutput with an optional parameter to indicate whether
the buffer created should be released in DataOutput destructor.

</member>
        <member name="T:gemfire.DataOutput">
C style memory allocation that throws OutOfMemoryException
if it fails

C style memory re-allocation that throws OutOfMemoryException
if it fails

Provide operations for writing primitive data values, byte arrays,
strings, <code>Serializable</code> objects to a byte stream.
This class is intentionally not thread safe.

</member>
        <member name="M:gemfire.createValueArr(System.Char!System.Runtime.CompilerServices.IsConst*)">
overload of gemfire::createValueArr to pass wchar_t* 
</member>
        <member name="M:gemfire.createValueArr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
overload of gemfire::createValueArr to pass char* 
</member>
        <member name="M:gemfire.createKeyArr(System.Char!System.Runtime.CompilerServices.IsConst*)">
overload of gemfire::createKeyArr to pass wchar_t* 
</member>
        <member name="M:gemfire.createKeyArr(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
overload of gemfire::createKeyArr to pass char* 
</member>
        <member name="M:gemfire.CacheableString.#ctor(System.SByte)">
Default constructor. 
</member>
        <member name="M:gemfire.CacheableString.getASCIIString(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Private method to get ASCII string for wide-string if possible. 
</member>
        <member name="M:gemfire.CacheableString.initStringNoCopy(System.Char*,System.Int32)">
Initialize the string without making a copy, given a wide-char string
and length.

</member>
        <member name="M:gemfire.CacheableString.initString(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
initialize the string, given a wide-char string and length. 
</member>
        <member name="M:gemfire.CacheableString.initStringNoCopy(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
Initialize the string without making a copy, given a C string
and length.

</member>
        <member name="M:gemfire.CacheableString.initString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
initialize the string, given a value and length. 
</member>
        <member name="M:gemfire.CacheableString.copyString(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Private method to populate the <code>CacheableString</code>. 
</member>
        <member name="M:gemfire.CacheableString.copyString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Private method to populate the <code>CacheableString</code>. 
</member>
        <member name="M:gemfire.CacheableString.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
used to render as a string for logging. 
</member>
        <member name="M:gemfire.CacheableString.Dispose">
Destructor 
</member>
        <member name="M:gemfire.CacheableString.className">
get the name of the class of this object for logging purpose 
</member>
        <member name="M:gemfire.CacheableString.toString">
Display this object as c string. In this case, it returns the same
value as asChar() when underlying type is a char* and returns the same
value as asWChar() cast to char* when the underlying type is a wchar_t*.
To handle this correctly the user should find the actual type by calling
typeId() or isWideString() and cast to the correct type accordingly.
Note: this is a debugging API, not intended for getting the exact value
of the CacheableString. In a future release this may return a more
summary representation. This is historical. It is preferred that the
user call logString or asChar/asWChar, depending on the need.

</member>
        <member name="M:gemfire.CacheableString.length">
Return the length of the contained string. 
</member>
        <member name="M:gemfire.CacheableString.asWChar">
 Return the string that backs this CacheableString as a wchar_t *. This
 shall throw an exception if the underlying string is a char* --
 the caller should use <code>typeId</code> to determine the actual type,
 or <code>isWideString</code> to find whether this is indeed a
 wide-character string.

 @throws IllegalStateException if the underlying string is a char *

</member>
        <member name="M:gemfire.CacheableString.asChar">
 Return the string that backs this CacheableString as a char *. This
 shall throw an exception if the underlying string is a wchar_t* --
 the caller should use <code>typeId</code> to determine the actual type,
 or <code>isWideString</code> to find whether this is a wide-character
 string.

 @throws IllegalStateException if the underlying string is a wchar_t *

</member>
        <member name="M:gemfire.CacheableString.isWideString">
Returns true if the underlying string is a wide-character string. 
</member>
        <member name="M:gemfire.CacheableString.isCString">
Returns true if the underlying string is a normal C string. 
</member>
        <member name="M:gemfire.CacheableString.createNoCopy(System.Char*,System.Int32)">
 Factory method for creating an instance of CacheableString from a
 wide-character C string of given length by taking ownership of the
 string without making a copy. The string should have been allocated
 using the standard C++ new operator.

 This should be used for non-ASCII strings.

 CAUTION: use this only when you really know what you are doing.

</member>
        <member name="M:gemfire.CacheableString.create(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
 Factory method for creating an instance of CacheableString from a
 wide-character null terminated C string optionally giving the length.

 This should be used for non-ASCII strings.

</member>
        <member name="M:gemfire.CacheableString.createNoCopy(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
 Factory method for creating an instance of CacheableString from
 a C string of given length by taking ownership of the string without
 making a copy. The string should have been allocated using
 the standard C++ new operator.

 This should be used only for ASCII strings.

 CAUTION: use this only when you really know what you are doing.

</member>
        <member name="M:gemfire.CacheableString.create(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
 Factory method for creating an instance of CacheableString from
 a null terminated C string optionally giving the length.

 This should be used only for ASCII strings.

</member>
        <member name="M:gemfire.CacheableString.hashcode">
return the hashcode for this key. 
</member>
        <member name="M:gemfire.CacheableString.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
return true if this key matches other. 
</member>
        <member name="M:gemfire.CacheableString.typeId">
 Return the typeId byte of the instance being serialized.
 This is used by deserialization to determine what instance
 type to create and deserialize into.

 For a <code>CacheableString</code> this shall return
 <code>GemfireTypeIds::CacheableNullString</code> if the underlying
 string is null, <code>GemfireTypeIds::CacheableASCIIString</code>
 if the underlying string is a char*, and
 <code>GemfireTypeIds::CacheableString</code> if it is a wchar_t*.
 For strings larger than 64K it will return
 <code>GemfireTypeIds::CacheableASCIIStringHuge</code> and
 <code>GemfireTypeIds::CacheableStringHuge</code> for char* and wchar_t*
 respectively.

</member>
        <member name="M:gemfire.CacheableString.classId">
@brief Return the classId of the instance being serialized.
 This is used by deserialization to determine what instance
 type to create and deserialize into.

</member>
        <member name="M:gemfire.CacheableString.createUTFDeserializableHuge">
creation function for wide strings &gt; 64K length in UTF8 encoding 
</member>
        <member name="M:gemfire.CacheableString.createUTFDeserializable">
creation function for wide strings 
</member>
        <member name="M:gemfire.CacheableString.createDeserializableHuge">
creation function for strings &gt; 64K length 
</member>
        <member name="M:gemfire.CacheableString.createDeserializable">
creation function for strings 
</member>
        <member name="M:gemfire.CacheableString.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief deserialize this object
 Throw IllegalArgumentException if the packed CacheableString is not less
 than 64K bytes.

</member>
        <member name="M:gemfire.CacheableString.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief serialize this object

</member>
        <member name="T:gemfire.CacheableString">
Implement a immutable C string wrapper that can serve as a distributable
key object for caching as well as being a string value.

</member>
        <member name="M:gemfire.CacheableKey.logString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
Copy the string form of a key into a char* buffer for logging purposes.
   *
   * Implementations should only generate a string as long as maxLength chars,
   * and return the number of chars written. buffer is expected to be large
   * enough to hold at least maxLength chars.
   *
   * The default implementation renders the classname and instance address.

</member>
        <member name="M:gemfire.CacheableKey.hashcode">
return the hashcode for this key. 
</member>
        <member name="M:gemfire.CacheableKey.op_Equality(gemfire.CacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
return true if this key matches other. 
</member>
        <member name="M:gemfire.CacheableKey.Dispose">
Destructor 
</member>
        <member name="M:gemfire.CacheableKey.#ctor">
Constructor 
</member>
        <member name="T:gemfire.CacheableKey">
Represents a cacheable key 
</member>
        <member name="M:gemfire.Serializable.#ctor">
@brief constructors

</member>
        <member name="M:gemfire.Serializable.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.Serializable.toString">
 Display this object as 'string', which depends on the implementation in
 the subclasses.
 The default implementation renders the classname.

 The return value may be a temporary, so the caller has to ensure that
 the SharedPtr count does not go down to zero by storing the result
 in a variable or otherwise.

</member>
        <member name="M:gemfire.Serializable.registerType(=FUNC:gemfire.Serializable*(System.Void))">
@brief register an instance factory method for a given type.
During registration the factory will be invoked to extract the typeId
to associate with this function.
@throws IllegalStateException if the typeId has already been registered,
        or there is an error in registering the type; check errno for
        more information in the latter case.

</member>
        <member name="M:gemfire.Serializable.objectSize">
@brief return the size in bytes of the instance being serialized.
 This is used to determine whether the cache is using up more
 physical memory than it has been configured to use. The method can
 return zero if the user does not require the ability to control
 cache memory utilization.
 Note that you must implement this only if you use the HeapLRU feature.

</member>
        <member name="M:gemfire.Serializable.DSFID">
 @brief return the Data Serialization Fixed ID type.
 This is used to determine what instance type to create and deserialize into.

 Note that this should not be overridden by custom implementations
 and is reserved only for builtin types.

</member>
        <member name="M:gemfire.Serializable.typeId">
@brief return the typeId byte of the instance being serialized.
 This is used by deserialization to determine what instance
 type to create and deserialize into.

 Note that this should not be overridden by custom implementations
 and is reserved only for builtin types.

</member>
        <member name="M:gemfire.Serializable.classId">
@brief Return the classId of the instance being serialized.
 This is used by deserialization to determine what instance
 type to create and deserialize into.

 The classId must be unique within an application suite.
 Using a negative value may result in undefined behavior.

</member>
        <member name="M:gemfire.Serializable.fromData(gemfire.DataInput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief deserialize this object, typical implementation should return
 the 'this' pointer.

</member>
        <member name="M:gemfire.Serializable.toData(gemfire.DataOutput*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief serialize this object

</member>
        <member name="T:gemfire.Serializable">
@class Serializable Serializable.hpp
This abstract base class is the superclass of all user objects 
in the cache that can be serialized.

</member>
        <member name="D:gemfire.TypeFactoryMethod">
@brief signature of functions passed to registerType. Such functions
 * should return an empty instance of the type they represent. The instance 
 * will typically be initialized immediately after creation by a call to fromData().

</member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableManagedObjectXml">
            <summary>
ClassId of <c>CacheableObjectXml</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableManagedObject">
            <summary>
ClassId of <c>CacheableObject</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableASCIIStringHuge">
            <summary>
ClassId of <c>CacheableString</c> class for huge ASCII strings
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableASCIIString">
            <summary>
ClassId of <c>CacheableString</c> class for ASCII strings
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableNullString">
            <summary>
ClassId of <c>CacheableString</c> class for null strings
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableTimeUnit">
            <summary>
Not used.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableIdentityHashMap">
            <summary>
ClassId of <c>CacheableIdentityHashMap</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableHashTable">
            <summary>
ClassId of <c>CacheableHashTable</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableHashMap">
            <summary>
ClassId of <c>CacheableHashMap</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableLinkedHashSet">
            <summary>
ClassId of <c>CacheableLinkedHashSet</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableHashSet">
            <summary>
ClassId of <c>CacheableHashSet</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableArrayList">
            <summary>
ClassId of <c>CacheableArrayList</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableStack">
            <summary>
ClassId of <c>CacheableStack</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableVector">
            <summary>
ClassId of <c>CacheableVector</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableStringArray">
            <summary>
ClassId of <c>CacheableStringArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableFileName">
            <summary>
ClassId of <c>CacheableFileName</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableDate">
            <summary>
ClassId of <c>CacheableDate</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableDouble">
            <summary>
ClassId of <c>CacheableDouble</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableFloat">
            <summary>
ClassId of <c>CacheableFloat</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableInt64">
            <summary>
ClassId of <c>CacheableInt64</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableInt32">
            <summary>
ClassId of <c>CacheableInt32</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableInt16">
            <summary>
ClassId of <c>CacheableInt16</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableByte">
            <summary>
ClassId of <c>CacheableByte</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableCharacter">
            <summary>
ClassId of <c>CacheableInt16</c> class for wide-characters
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableBoolean">
            <summary>
ClassId of <c>CacheableBoolean</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableObjectArray">
            <summary>
ClassId of <c>CacheableVector</c> class for object arrays
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableDoubleArray">
            <summary>
ClassId of <c>CacheableDoubleArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableFloatArray">
            <summary>
ClassId of <c>CacheableFloatArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableInt64Array">
            <summary>
ClassId of <c>CacheableInt64Array</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableInt32Array">
            <summary>
ClassId of <c>CacheableInt32Array</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableInt16Array">
            <summary>
ClassId of <c>CacheableInt16Array</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableBytes">
            <summary>
ClassId of <c>CacheableBytes</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableStringHuge">
            <summary>
ClassId of <c>CacheableString</c> class for huge strings
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableString">
            <summary>
ClassId of <c>CacheableString</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.Struct">
            <summary>
ClassId of <c>Struct</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CacheableUndefined">
            <summary>
ClassId of <c>CacheableUndefined</c> class
Implementation note: this has DSFID of FixedIDByte hence a
different increment.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.RegionAttributes">
            <summary>
ClassId of <c>RegionAttributes</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.BooleanArray">
            <summary>
ClassId of <c>BooleanArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.CharArray">
            <summary>        
ClassId of <c>CharArray</c> class
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireClassIds.Properties">
            <summary>
ClassId of <c>Properties</c> class
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.GemFireClassIds">
            <summary>
Static class containing the classIds of the built-in cacheable types.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheableKey.Equals(GemStone.GemFire.Cache.ICacheableKey)">
            <summary>
Returns true if this <c>ICacheableKey</c> matches the other.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.ICacheableKey.GetHashCode">
            <summary>
Get the hash code for this object. This is used in the internal
hash tables and so must have a nice distribution pattern.
</summary>
            <returns>
The hashcode for this object.
</returns>
        </member>
        <member name="T:GemStone.GemFire.Cache.ICacheableKey">
            <summary>
This interface class is the superclass of all user objects 
in the cache that can be used as a key.
</summary>
            <remarks>
If an implementation is required to act as a key in the cache, then
it must implement this interface and preferably override
<c>System.Object.ToString</c> to obtain proper string representation.
Note that this interface requires that the class overrides
<c>Object.GetHashCode</c>. Though this is not enforced, the default
implementation in <c>System.Object</c> is almost certainly incorrect
and will not work correctly.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.IGFSerializable.ToString">
            <summary>
Return a string representation of the object.
</summary>
        </member>
        <member name="P:GemStone.GemFire.Cache.IGFSerializable.ClassId">
            <summary>
Returns the classId of the instance being serialized.
This is used by deserialization to determine what instance
type to create and deserialize into.
</summary>
            <remarks>
The classId must be unique within an application suite
and in the range 0 to ((2^31)-1) both inclusive. An application can
thus define upto 2^31 custom <c>IGFSerializable</c> classes.
Returning a value greater than ((2^31)-1) may result in undefined
behaviour.
</remarks>
            <returns>the classId</returns>
        </member>
        <member name="P:GemStone.GemFire.Cache.IGFSerializable.ObjectSize">
            <summary>
Get the size of this object in bytes.
This is only needed if you use the HeapLRU feature.
</summary>
            <remarks>
Note that you can simply return zero if you are not using the HeapLRU feature.
</remarks>
            <returns>the size of this object in bytes.</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.IGFSerializable.FromData(GemStone.GemFire.Cache.DataInput)">
            <summary>
Deserialize this object, typical implementation should return
the 'this' pointer.
</summary>
            <param name="input">
the DataInput stream to use for reading the object data
</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.IGFSerializable.ToData(GemStone.GemFire.Cache.DataOutput)">
            <summary>
Serializes this object.
</summary>
            <param name="output">
the DataOutput object to use for serializing the object
</param>
        </member>
        <member name="T:GemStone.GemFire.Cache.IGFSerializable">
            <summary>
This interface class is the superclass of all user objects 
in the cache that can be serialized.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.TransactionDataRebalancedException">
            <summary>
Thrown if commit rebalance happens during a transaction.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.TransactionDataNodeHasDepartedException">
            <summary>
Thrown if transaction delegate went down.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CommitConflictException">
            <summary>
Thrown if commit fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.KeyNotFoundException">
            <summary>
Thrown if a Key is not present in the region.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqExistsException">
            <summary>
Thrown if a Cq by this name already exists on this client
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqQueryException">
            <summary>
Thrown if the Cq Query failed
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqClosedException">
            <summary>
Thrown if the Cq on which the operaion performed is closed
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqException">
            <summary>
Thrown during continuous query execution time.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.FunctionExecutionException">
            <summary>
Thrown when function execution failed
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CqInvalidException">
            <summary>
Thrown when cq is invalid
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.AllConnectionsInUseException">
            <summary>
Thrown when all connections in a pool are in use..
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.NoAvailableLocatorsException">
            <summary>
Thrown when a client is unable to contact any locators.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.DuplicateDurableClientException">
            <summary>
Thrown when a duplicate durable client id is provided to the server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.AuthenticationRequiredException">
            <summary>
Thrown when credentials are not provided to a server which expects them.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.AuthenticationFailedException">
            <summary>
Thrown when authentication to the server fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.NotAuthorizedException">
            <summary>
Thrown when a client operation is not authorized on the server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.MessageException">
            <summary>
Thrown when an unknown message is received from the server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.QueryException">
            <summary>
Thrown when query exception occurs at the server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.OutOfRangeException">
            <summary>
Thrown when bound of array/vector etc. is exceeded.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.RedundancyException">
            <summary>
Thrown when redundancy level is not satisfied.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheServerException">
            <summary>
Thrown when an exception occurs on the cache server.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.ShutdownFailedException">
            <summary>
Thrown when persistence manager fails to close properly.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.InitFailedException">
            <summary>
Thrown when persistence manager fails to initialize.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.DiskCorruptException">
            <summary>
Thrown by the persistence manager when the data
to be read from disk is corrupt.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.DiskFailureException">
            <summary>
Thrown by the persistence manager when a write
fails due to disk failure.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.FatalInternalException">
            <summary>
Thrown when there is a fatal internal exception in GemFire.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.RegionCreationFailedException">
            <summary>
Thrown when a region creation operation fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.BufferSizeExceededException">
            <summary>
Thrown when the internal buffer size is exceeded.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.WrongRegionScopeException">
            <summary>
Thrown when a region is created in an incorrect scope.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.NotOwnerException">
            <summary>
Thrown when an attempt is made to release a lock not
owned by the thread.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.OutOfMemoryException">
            <summary>
Thrown when the system cannot allocate any more memory.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheProxyException">
            <summary>
Thrown when there is an error in the cache proxy.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.NotConnectedException">
            <summary>
Thrown when an operation is attempted before connecting
to the distributed system.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.EntryExistsException">
            <summary>
Thrown when attempt is made to create an existing entry.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.NullPointerException">
            <summary>
Thrown when a null argument is provided to a method
where it is expected to be non-null.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.GemFireConfigException">
            <summary>
Thrown when gemfire configuration file is incorrect.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.GemFireIOException">
            <summary>
Thrown when there is an input/output error.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.EntryNotFoundException">
            <summary>
Thrown when an operation is attempted on a non-existent entry.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.ClassCastException">
            <summary>
Thrown when a cast operation fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.UnknownException">
            <summary>
An unknown exception occurred.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.ConcurrentModificationException">
            <summary>
Thrown when a concurrent operation fails.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.StatisticsDisabledException">
            <summary>
Thrown when statistics are invoked for a region where
they are disabled.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.UnsupportedOperationException">
            <summary>
Thrown when an operation unsupported by the
current configuration is attempted.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.InterruptedException">
            <summary>
Thrown when an operation is interrupted.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.FileNotFoundException">
            <summary>
Thrown when a non-existing file is accessed.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.AlreadyConnectedException">
            <summary>
Thrown when an attempt is made to connect to
DistributedSystem second time.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.NoSystemException">
            <summary>
Thrown when the connecting target is not running.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.EntryDestroyedException">
            <summary>
Thrown when an operation is attempted on a destroyed entry.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.RegionDestroyedException">
            <summary>
Thrown when an operation is attempted on a destroyed region.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheLoaderException">
            <summary>
Thrown when the cache loader aborts the operation.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.LeaseExpiredException">
            <summary>
Thrown when lease of cache proxy has expired.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheClosedException">
            <summary>
Thrown when an operation is attempted on a closed cache.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.RegionExistsException">
            <summary>
Thrown when an attempt is made to create an existing region.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheListenerException">
            <summary>
Thrown when the cache listener throws an exception.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheWriterException">
            <summary>
Thrown when the cache writer aborts the operation.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.TimeoutException">
            <summary>
Thrown when a timout occurs.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheXmlException">
            <summary>
Thrown when the cache xml is incorrect.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CacheExistsException">
            <summary>
Thrown when an attempt is made to create an existing cache.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.IllegalStateException">
            <summary>
Thrown when the state of cache is manipulated to be illegal.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.IllegalArgumentException">
            <summary>
Thrown when an argument to a method is illegal.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.AssertionException">
Handle gemfire exceptions from native layer and convert to managed
exceptions. Also handle fatal exceptions to generate mini dumps if
stack trace dumping is enabled
Creates a class <c>x</c> named for each exception <c>y</c>.
Creates a class named for each exception <c>x</c>.
<summary>
A gemfire assertion exception.
</summary></member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
Initializes a new instance of the <c>GemFireException</c> class with
serialized data.
This allows deserialization of this exception in .NET remoting.
</summary>
            <param name="info">
holds the serialized object data about
the exception being thrown
</param>
            <param name="context">
contains contextual information about
the source or destination
</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.GenerateMiniDump(System.Int32,System.IntPtr)">
            <summary>
Generate a minidump of the current process in the directory
specified for log files using "log-file" property.
This is equivalent to the ".dump /ma" command of windbg.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.GenerateMiniDump">
            <summary>
Generate a minidump of the current process in the directory
specified for log files using "log-file" property.
This is equivalent to the ".dump /ma" command of windbg.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.#ctor(System.String,System.Exception)">
            <summary>
Constructor to create an exception object with the given message
and with the given inner exception.
</summary>
            <param name="message">The exception message.</param>
            <param name="innerException">The inner exception object.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.#ctor(System.String)">
            <summary>
Constructor to create an exception object with the given message.
</summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.#ctor">
            <summary>
Default constructor.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.ThrowNative">
            <summary>
Throws the C++ native exception object for this managed
<c>GemFireException</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.ThrowNative(System.Exception)">
            <summary>
Throws the C++ native exception object for the given .NET exception.
</summary>
            <remarks>
This method is to handle conversion of managed exceptions to
C++ exception for those thrown by managed callbacks.
For non-Gemfire .NET exceptions we wrap it inside the generic
<c>GemfireException</c> with a special prefix in message.
While converting the exception back from C++ to .NET if the
prefix is found in the message, then it tries to construct
the original exception by reflection on the name of exception
contained in the message. Note that in this process the
original stacktrace is appended to the message of the exception.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.GetNative">
            <summary>
Gets the C++ native exception object for this managed
<c>GemFireException</c>.
</summary>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.GetNative(System.Exception)">
            <summary>
Gets the C++ native exception object for a given managed exception.
</summary>
            <remarks>
This method is to handle conversion of managed exceptions to
C++ exception for those thrown by managed callbacks.
For non-Gemfire .NET exceptions we wrap it inside the generic
<c>GemfireException</c> with a special prefix in message.
While converting the exception back from C++ to .NET if the
prefix is found in the message, then it tries to construct
the original exception by reflection on the name of exception
contained in the message. Note that in this process the
original stacktrace is appended to the message of the exception.
</remarks>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.GetStackTrace(gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Get the stack trace for the given native exception.
</summary>
            <param name="nativeEx">The native GemFire exception object</param>
            <returns>The stack trace of the native exception.</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.Get(gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create the managed GemFire exception for a given native GemFire exception.
As a special case normal system exceptions are also created when the
native exception is a wrapper of a managed system exception.
</summary>
            <remarks>
Wherever the native GemFire C++ code raises a <c>gemfire::Exception</c>,
the CLI wrapper code should have a catch-all for those and use
this function to create the corresponding managed GemFire exception.
If no managed GemFire exception has been defined (or has not been
added using _GF_MG_EXCEPTION_ADD in ExceptionTypesM.cpp) then a
generic <c>GemFireException</c> exception is returned.
</remarks>
            <param name="nativeEx">The native GemFire exception object</param>
            <returns>
The managed GemFire exception object corresponding to the provided
native GemFire exception object.
</returns>
        </member>
        <member name="M:GemStone.GemFire.Cache.GemFireException.Init">
            <summary>
Static method to associate the native exception names with
the corresponding managed exception factory delegates.
</summary>
            <remarks>
This method is not thread-safe and should be called in a single thread.
</remarks>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireException.NameDelegatePair.m_delegate">
            <summary>
The factory delegate of the managed GemFire exception class
corresponding to <c>m_name</c></summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireException.NameDelegatePair.m_name">
            <summary>
The name of the native GemFire exception class.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.GemFireException.NameDelegatePair">
            <summary>
Name and delegate pair class. The Native2ManagedExMap dictionary
is populated from a static array of this class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireException.Native2ManagedExMap">
            <summary>
This contains a mapping of the native GemFire exception class
name to the factory delegate of the corresponding managed GemFire
exception class.
</summary>
        </member>
        <member name="F:GemStone.GemFire.Cache.GemFireException.MgSysExPrefix">
            <summary>
Prefix for distiguishing managed system exceptions
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.GemFireException">
            <summary>
The base exception class of all managed GemFire exceptions.
</summary>
        </member>
        <member name="T:GemStone.GemFire.Cache.CreateException">
            <summary>
Factory delegate to create a managed GemFire exception.
</summary>
            <remarks>
For each managed exception class, its factory delegate is registered
and maintained in a static dictionary mapped to its corresponding
native GemFire C++ exception name.
</remarks>
        </member>
        <member name="M:gemfire.Exception.#ctor(gemfire.SharedPtr&lt;gemfire.CacheableString&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.StackTrace&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr&lt;gemfire.Exception&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
internal constructor used to clone this exception 
</member>
        <member name="M:gemfire.Exception.raise">
Throw polymorphically; this allows storing an exception object
pointer and throwing it later.

</member>
        <member name="M:gemfire.Exception.getName">
Return the name of this exception type. 
</member>
        <member name="M:gemfire.Exception.getStackTrace(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)">
On some platforms, get a stacktrace string from the location the
      * exception was created.

</member>
        <member name="M:gemfire.Exception.printStackTrace">
On some platforms, print a stacktrace from the location the exception
      * was created.

</member>
        <member name="M:gemfire.Exception.showMessage">
Show the message pointer
     *

</member>
        <member name="M:gemfire.Exception.getMessage">
Returns the message pointer
     *
     * @return  message pointer

</member>
        <member name="M:gemfire.Exception.Dispose">
@brief destructor

</member>
        <member name="M:gemfire.Exception.clone">
Create a clone of this exception. 
</member>
        <member name="M:gemfire.Exception.#ctor(gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates an exception as a copy of the given other exception.
     * @param  other the original exception.
     *
     *
</member>
        <member name="M:gemfire.Exception.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,gemfire.SharedPtr&lt;gemfire.Exception&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief public methods

Creates an exception.
     * @param  msg1 message pointer, this is copied into the exception.
     * @param  msg2 optional extra message pointer, appended to msg1.
     * @param  forceTrace enables a stacktrace for this exception regardless of
     * stacktrace-enabled system property.
     * @param  cause optional cause of the exception which can be later
     *               retrieved using <code>getCause</code>
     *
</member>
        <member name="T:gemfire.Exception">
@class Exception Exception.hpp
A description of an exception that occurred during a cache operation.

</member>
        <member name="T:gemfire.SPEHelper">
Helper class for SharedPtr exceptions

</member>
        <member name="T:__type_info_node">
@brief Macro to unwrap the type <code>T</code> inside SharedPtr. 
@brief Macro to determine if the type <code>T</code> is derived from
       <code>Serializable</code>.

@brief Macro that returns <code>yes_type</code> if the type <code>T</code> is
       derived from <code>Serializable</code> and <code>no_type</code>
       otherwise. Useful for overloaded template functions.

</member>
        <member name="T:gemfire.NullSharedBase">
Class encapsulating a NULL SharedBase smart pointer. This is for passing
NULL pointers implicitly to copy constructor of <code>SharedPtr</code>
class.

</member>
        <member name="M:gemfire.SharedBase.refCount">
@return the reference count 
</member>
        <member name="M:gemfire.SharedBase.releaseSB">
Atomically decrement reference count, the SharedBase object is
automatically deleted when its reference count goes to zero

</member>
        <member name="M:gemfire.SharedBase.preserveSB">
Atomically increment reference count 
</member>
        <member name="M:gemfire.SharedBase.#ctor">
Constructor. 
</member>
        <member name="T:gemfire.SharedBase">
 @class SharedBase SharedBase.hpp

 This abstract base class is the base class of all user objects
 that have the shared capability of reference counting.

</member>
        <member name="M:gemfire.Assert.throwAssertion(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Throws the given assertion.

</member>
        <member name="M:gemfire.Assert.assertTrue(System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
If the given expression is true, does nothing, otherwise calls
    * @ref throwAssertion .

</member>
        <member name="T:gemfire.Assert">
 @class Assert Assert.hpp

 Declares debugging assertion reporting functions.

</member>
        <member name="T:gemfire.LogVarargs">
These functions are added to facilitate logging in printf format.

</member>
        <member name="M:gemfire.Log.debugCatch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes both a message and caught exception.
The message level is "debug".

</member>
        <member name="M:gemfire.Log.debugThrow(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.
The message level is "debug".

</member>
        <member name="M:gemfire.Log.debug(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message.
The message level is "debug".

</member>
        <member name="M:gemfire.Log.debugEnabled">
Returns whether "debug" log messages are enabled.

</member>
        <member name="M:gemfire.Log.finestCatch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes both a message and caught exception.
The message level is "finest".

</member>
        <member name="M:gemfire.Log.finestThrow(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.
The message level is "finest".

</member>
        <member name="M:gemfire.Log.finest(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message.
The message level is "finest".

</member>
        <member name="M:gemfire.Log.finestEnabled">
Returns whether "finest" log messages are enabled.

</member>
        <member name="M:gemfire.Log.finerCatch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes both a message and caught exception.
The message level is "finer".

</member>
        <member name="M:gemfire.Log.finerThrow(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.
The message level is "finer".

</member>
        <member name="M:gemfire.Log.finer(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message.
The message level is "finer".

</member>
        <member name="M:gemfire.Log.finerEnabled">
Returns whether "finer" log messages are enabled.

</member>
        <member name="M:gemfire.Log.fineCatch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes both a message and caught exception.
The message level is "fine".

</member>
        <member name="M:gemfire.Log.fineThrow(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.
The message level is "fine".

</member>
        <member name="M:gemfire.Log.fine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message.
The message level is "fine".

</member>
        <member name="M:gemfire.Log.fineEnabled">
Returns whether "fine" log messages are enabled.

</member>
        <member name="M:gemfire.Log.configCatch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes both a message and caught exception.
The message level is "config".

</member>
        <member name="M:gemfire.Log.configThrow(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.
The message level is "config".

</member>
        <member name="M:gemfire.Log.config(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message.
The message level is "config".

</member>
        <member name="M:gemfire.Log.configEnabled">
Returns whether "config" log messages are enabled.

</member>
        <member name="M:gemfire.Log.infoCatch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes both a message and caught exception.
The message level is "info".

</member>
        <member name="M:gemfire.Log.infoThrow(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.
The message level is "info".

</member>
        <member name="M:gemfire.Log.info(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message.
The message level is "info".

</member>
        <member name="M:gemfire.Log.infoEnabled">
Returns whether "info" log messages are enabled.

</member>
        <member name="M:gemfire.Log.warningCatch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes both a message and caught exception.
The message level is "warning".

</member>
        <member name="M:gemfire.Log.warningThrow(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.
The message level is "warning".

</member>
        <member name="M:gemfire.Log.warning(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message.
The message level is "warning".

</member>
        <member name="M:gemfire.Log.warningEnabled">
Returns whether "warning" log messages are enabled.

</member>
        <member name="M:gemfire.Log.errorCatch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Writes both a message and caught exception.
The message level is "error".

</member>
        <member name="M:gemfire.Log.errorThrow(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.
The message level is "error".

</member>
        <member name="M:gemfire.Log.error(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message.
The message level is "error".

</member>
        <member name="M:gemfire.Log.errorEnabled">
Returns whether "error" log messages are enabled.

</member>
        <member name="M:gemfire.Log.logCatch(gemfire.Log.LogLevel,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and caught exception.

</member>
        <member name="M:gemfire.Log.logThrow(gemfire.Log.LogLevel,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,gemfire.Exception!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Logs both a message and thrown exception.

</member>
        <member name="M:gemfire.Log.log(gemfire.Log.LogLevel,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Logs a message at given level.

</member>
        <member name="M:gemfire.Log.enabled(gemfire.Log.LogLevel)">
Returns whether log messages at given level are enabled.

</member>
        <member name="M:gemfire.Log.charsToLevel(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
returns log level specified by "chars", or throws
IllegalArgumentException.  Allowed values are identical to the
enum declaration above for LogLevel, but with character case ignored.

</member>
        <member name="M:gemfire.Log.levelToChars(gemfire.Log.LogLevel)">
returns character string for given log level. The string will be
identical to the enum declaration above, except it will be all
lower case. Out of range values will throw
IllegalArgumentException.

</member>
        <member name="M:gemfire.Log.close">
closes logging facility (until next init).

</member>
        <member name="M:gemfire.Log.init(gemfire.Log.LogLevel,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int64)">
Initializes logging facility with given level and filenames.
This method is called automatically within @ref DistributedSystem::connect
with the log-file, log-level, and log-file-size system properties used as
arguments

</member>
        <member name="M:gemfire.Log.logFileName">
@return the name of the current log file.
NOTE: This function is for debugging only, as it is not completely
thread-safe!

</member>
        <member name="M:gemfire.Log.setLogLevel(gemfire.Log.LogLevel)">
Set the current log level.

</member>
        <member name="M:gemfire.Log.logLevel">
Returns the current log level.

</member>
        <member name="M:__iob_func">
 The interface of the Log class

 @author Neeraj Kumar


Throws the given assertion. 
Change this to 1 to use assertion functions. 
Throws the given assertion if GF_DEBUG_ASSERTS is true. 
Throws the given assertion if GF_DEVEL_ASSERTS is true. 
</member>
        <member name="F:GF_CACHE_ENTRY_UPDATED">
local entry was updated while a remote modification operation was
in progress

</member>
        <member name="D:int8">
@mainpage vFabric GemFire Native Client .NET Reference
@image html gemFireDotNETLogo.gif
@file gf_defs.hpp
API documentation helper file for the Doxygen source-comment-extraction tool.
@namespace GemStone::GemFire
This namespace contains all the GemFire .NET classes and utility classes.
@namespace GemStone::GemFire::Cache
This namespace contains all the GemFire .NET API classes and enumerations.
@namespace GemStone::GemFire::Cache::Generic
This namespace contains all the GemFire .NET Generics API classes and enumerations.
@namespace GemStone::GemFire::Cache::Internal
This namespace contains internal GemFire non-public .NET classes.
@namespace GemStone::GemFire::Cache::Template
This namespace contains internal GemFire .NET template classes.
@file gf_includes.hpp
Provides a commonly-used set of include directives.
@file AttributesFactoryM.hpp
Declares the AttributesFactory class.
@file AttributesMutatorM.hpp
Declares the AttributesMutator class.
@file CacheAttributesM.hpp
Declares the CacheAttributes class.
@file CacheAttributesFactoryM.hpp
Declares the CacheAttributesFactory class.
@file CacheableBuiltinsM.hpp
Declares the CacheableBuiltinKey and CacheableBuiltinArray
template classes and their instantiations for CacheableBoolean,
CacheableByte, CacheableDouble, CacheableFloat, CacheableInt16,
CacheableInt32, CacheableInt64, CacheableBytes, CacheableDoubleArray,
CacheableFloatArray, CacheableInt16Array, CacheableInt32Array, 
CacheableInt64Array, BooleanArray and CharArray
@file CacheableBuiltinsMN.hpp
Declared the built-in GemFire serializable types.
@file CacheableDateM.hpp
Declares the CacheableDate class.
@file CacheableFileNameM.hpp
Declares the CacheableFileName class.
@file CacheableHashMapM.hpp
Declares the CacheableHashMap class.
@file CacheableHashSetM.hpp
Declares the CacheableHashSet class.
@file CacheableKeyM.hpp
Declares the CacheableKey class.
@file CacheableObject.hpp
Declares the CacheableObject class.
@file CacheableObjectXml.hpp
Declares the CacheableObjectXml class.
@file CacheableStringM.hpp
Declares the CacheableString class.
@file CacheableStringArrayM.hpp
Declares the CacheableStringArray class.
@file CacheableUndefinedM.hpp
Declares the CacheableUndefined class.
@file CacheableVectorM.hpp
Declares the CacheableVector class.
@file CacheFactoryM.hpp
Declares the CacheFactory class.
@file CacheM.hpp
Declares the Cache class.
@file CacheStatisticsM.hpp
Declares the CacheStatistics class.
@file CacheStatisticsMN.hpp
Declares the CacheStatistics class.
@file DataInputM.hpp
Declares the DataInput class.
@file DataOutputM.hpp
Declares the DataOutput class.
@file DiskPolicyTypeM.hpp
Declares the DiskPolicyType enumeration and DiskPolicy class.
@file DistributedSystemM.hpp
Declares the DistributedSystem class.
@file EntryEventM.hpp
Declares the EntryEvent class.
@file ExceptionTypesM.hpp
Declares the GemFire exception type classes.
@file ExpirationActionM.hpp
Declares the ExpirationAction enumeration and Expiration class.
@file GemFireClassIdsM.hpp
Declares the GemFireClassIds class.
@file IRegionService.hpp
Declares the IRegionService interface.
@file IRegionServiceN.hpp
Declares the IRegionService interface.
@file IGemFireCache.hpp
Declares the IGemFireCache interface.
@file IGemFireCacheN.hpp
Declares the IGemFireCache interface.
@file ICacheableKey.hpp
Declares the ICacheableKey interface.
@file ICacheListener.hpp
Declares the ICacheListener interface.
@file ICacheListenerN.hpp
Declares the ICacheListener interface.
@file IPartitionResolver.hpp
Declares the IPartitionResolver interface.
@file IFixedPartitionResolver.hpp
Declares the IFixedPartitionResolver interface.
@file IPartitionResolverN.hpp
Declares the IPartitionResolver interface.
@file IFixedPartitionResolverN.hpp
Declares the IFixedPartitionResolver interface.
@file ICacheLoader.hpp
Declares the ICacheLoader interface.
@file ICacheWriter.hpp
Declares the ICacheWriter interface.
@file ICacheLoaderN.hpp
Declares the ICacheLoader interface.
@file ICacheWriterN.hpp
Declares the ICacheWriter interface.
@file IGFSerializable.hpp
Declares the IGFSerializable interface.
@file ISelectResults.hpp
Declares the ISelectResults interface.
@file LogM.hpp
Declares the Log class.
@file LogMN.hpp
Declares the Log class.
@file PropertiesM.hpp
Declares the Properties class.
@file RegionShortcutM.hpp
Declares the RegionShortcut enum class.
@file QueryM.hpp
Declares the Query class.
@file QueryServiceM.hpp
Declares the QueryService class.
@file RegionM.hpp
Declares the Region class.
@file RegionM.hpp
Declares the Region class.
@file RegionMN.hpp
Declares the Region class.
@file RegionAttributesM.hpp
Declares the RegionAttributes class.
@file RegionEntryM.hpp
Declares the RegionEntry class.
@file RegionEntryMN.hpp
Declares the RegionEntry class.
@file RegionEventM.hpp
Declares the RegionEvent class.
@file ResultSetM.hpp
Declares the ResultSet class.
@file ScopeTypeM.hpp
Declares the ScopeType enumeration and Scope class.
@file SelectResultsIteratorM.hpp
Declares the SelectResultsIterator class.
@file SerializableM.hpp
Declares the Serializable class.
@file StructSetM.hpp
Declares the StructSet class.
@file StructM.hpp
Declares the Struct class.
@file SystemPropertiesM.hpp
Declares the SystemProperties class.
@file SystemPropertiesMN.hpp
Declares the SystemProperties class.
@file Utils.hpp
Declares the Utils class.
@file

Library Export 
Library Implementation 
Library Call 
Library Export a type 
Defines a GemFire C extern 
Defines a GemFire CPPCACHE export 
Define GF_TEMPLATE_EXPORT 

@file

Library Export 
Library Implementation 
Library Call 
Library Export a type 
Defines a GemFire C extern 
Defines a GemFire CPPCACHE export 
Define GF_TEMPLATE_EXPORT 

@file

@file

Library Export 
Library Implementation 
Library Call 
Library Export a type 
Defines a GemFire C extern 
Defines a GemFire CPPCACHE export 
Define GF_TEMPLATE_EXPORT 
</member>
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListener.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedFixedPartitionResolver.getPartitionName(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.CacheableHashSet>)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IFixedPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Cache.CreateRegion``2(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Cache.CreateRegion``2(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.ResultCollector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Execution.execute(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.UInt32,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.FunctionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.FunctionService`1.OnRegion``2(GemStone.GemFire.Cache.Generic.IRegion`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.RegionFactory.Create``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.GetRegion``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListenerGeneric.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Cache.CreateRegion``2(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.RegionFactory.Create``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.GetRegion``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListener.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedFixedPartitionResolverGeneric.getPartitionName(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.CacheableHashSet>)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.ResultCollector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Execution.execute(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.UInt32,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onRegion(gemfire.SharedPtr<gemfire.Region>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onServer(gemfire.SharedPtr<gemfire.Pool>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onServer(gemfire.SharedPtr<gemfire.RegionService>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.RegionFactory.Create(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Cache.CreateRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.FunctionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.FunctionService.OnRegion(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.AuthenticatedCache.GetRegion(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Query.Execute(GemStone.GemFire.Cache.IGFSerializable[],System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CqAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCqListener.close'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.CacheFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.CacheFactory.SetPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Cache.CreateRegion``2(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsType'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedFixedPartitionResolver.getPartitionName(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.CacheableHashSet>)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IFixedPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListener.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.CacheFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.RegionFactory.Create(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Cache.CreateRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Query`1.Execute(System.Object[],System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCqListenerGeneric.close'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCqListenerGeneric.close'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Query.Execute(GemStone.GemFire.Cache.IGFSerializable[],System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isAtomic'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isShared'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int64)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int64)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.RegionFactory.Create(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Cache.CreateRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.ResultCollector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Execution.execute(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.UInt32,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onRegion(gemfire.SharedPtr<gemfire.Region>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onServer(gemfire.SharedPtr<gemfire.Pool>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onServer(gemfire.SharedPtr<gemfire.RegionService>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.FunctionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.FunctionService.OnRegion(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.AuthenticatedCache.GetRegion(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.ResultCollector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Execution.execute(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.UInt32,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.RegionFactory.Create``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListenerGeneric.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedFixedPartitionResolverGeneric.getPartitionName(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.CacheableHashSet>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Query`1.Execute(System.Object[],System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.CacheFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_EXCEPTION_DISPOSITION'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_HANDLE'. -->
        <!-- Discarding badly formed XML document comment for member 'D:wctrans_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write_upgrade'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Adaptive_Lock'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_timer_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:clock_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_beginthread(=FUNC:System.Void(System.Void*),System.UInt32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_OVERLAPPED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_clearfp'. -->
        <!-- Discarding badly formed XML document comment for member 'D:sig_atomic_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ucontext_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:rusage'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_RANDR_TYPE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Time_Value.max_time'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.msec'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.op_MultiplicationAssignment(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThan(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThanOrEqual(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_Service_Object_Exterminator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Assign(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Equality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Inequality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0_ace_thread_adapter(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS_Thread_Descriptor.flags_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Base_Thread_Adapter.thr_desc_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:sembuf'. -->
        <!-- Discarding badly formed XML document comment for member 'T:semid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:semun.array'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_align_binary(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_COMPARE_FUNC'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS.exit_hook_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.object_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.param_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.starting_up'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.shutting_down'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.default_mask'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.thread_hook(ACE_5_6_0.ACE_Thread_Hook*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.at_exit(=FUNC:System.Void(System.Void))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.memchr(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_lfind_s(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.UInt32,=FUNC:System.Int32(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:siginfo_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_TSS_Ref'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_lock(ACE_5_6_0.ACE_mutex_t*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_trylock(ACE_5_6_0.ACE_mutex_t*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.priority_control(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.set_scheduling_params(ACE_5_6_0.ACE_Sched_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.unique_name(System.Void!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_diskfree_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.read_n(System.Void*,System.Void*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.write_n(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_clearerr_helper(_iobuf*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:passwd'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Mutex'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.acquire'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.tryacquire'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_RW_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Log_Msg.log(ACE_5_6_0.ACE_Log_Priority,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Log_Msg.errnum_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:__JUMP_BUFFER'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.handle_timeout(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.handle_close(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.read_adapter(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.register_stdin_handler(ACE_5_6_0.ACE_Event_Handler*,ACE_5_6_0.ACE_Reactor*,ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.remove_stdin_handler(ACE_5_6_0.ACE_Reactor*,ACE_5_6_0.ACE_Thread_Manager*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Notification_Buffer'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ace_yytokentype'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_SHLIB_HANDLE'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_DLL.get_handle(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.calloc(System.UInt32,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.free(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.protect(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Allocator.delete_allocator_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_log2_helper(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.ldname(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.strsplit_r(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE.init_fini_count_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:iovec'. -->
        <!-- Discarding badly formed XML document comment for member 'T:msghdr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ip_mreq'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ace_isalnum(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:strrecvfd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_QoS*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_QoS_Params.#ctor(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Accept_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Accept_QoS_Params.#ctor(=FUNC:System.Int32(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,iovec*,iovec*,System.UInt32*,System.UInt32!System.Runtime.CompilerServices.IsLong),System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Accept_QoS_Params.qos_condition_callback_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*,ACE_5_6_0.ACE_Accept_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr!System.Runtime.CompilerServices.IsConst*,System.Int32,ACE_5_6_0.ACE_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.socket(System.Int32,System.Int32,System.Int32,_WSAPROTOCOL_INFOA*,System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.op_Subscript(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.op_Subscript(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.c_str'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.rfind(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.compare(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.delimiter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.delimiter_replace(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.preserve_designators(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.is_delimiter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.is_preserve_designator(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Auto_String_Free'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Recursive_Thread_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Repository'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Repository.fini'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Repository.delete_svc_rep_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Repository_Iterator.next(ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Adapter.invoke'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void**,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn_n(System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void**,System.UInt32*,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn_n(System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void**,System.UInt32*,System.Void**,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Object_Manager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.at_exit(ACE_5_6_0.ACE_Cleanup*,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.at_exit(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Null_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Recursive_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_RW_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.instance'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.open(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.parse_args(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.close'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.suspend(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.init_svc_conf_file_queue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Gestalt.is_opened_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Object'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Type.fini'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Type.fini_already_called_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Object_Ptr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Object_Ptr.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Control'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.#ctor(ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.insert(ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.thr_mgr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.thr_mgr(ACE_5_6_0.ACE_Thread_Manager*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Exit'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Condition_Thread_Mutex.wait(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Condition_Thread_Mutex.wait(ACE_5_6_0.ACE_Thread_Mutex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Condition_Thread_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Descriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Manager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.close'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void**,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn_n(System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,ACE_5_6_0.ACE_Task_Base*,System.Void**,System.Void**,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn_n(System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void**,System.UInt32*,System.Void**,ACE_5_6_0.ACE_Task_Base*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.join(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.thr_self'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testsuspend(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testresume(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testcancel(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testterminate(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.cancel_task(ACE_5_6_0.ACE_Task_Base*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.hthread_list(ACE_5_6_0.ACE_Task_Base*,System.Void**,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.thread_grp_list(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.hthread_grp_list(System.Int32,System.Void**,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.count_threads'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.at_exit(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_thread(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_hthread(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_task(ACE_5_6_0.ACE_Task_Base*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.check_state(System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_task(ACE_5_6_0.ACE_Task_Base*, ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_grp(System.Int32, ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_all( ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.join_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.resume_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.suspend_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.kill_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.cancel_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.register_as_terminated(ACE_5_6_0.ACE_Thread_Descriptor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Manager.lock_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Manager.delete_thr_mgr_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.init(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.init(System.UInt32,System.Int32,ACE_5_6_0.ACE_Message_Block*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Lock*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Allocator*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.set_self_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.duplicate(ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.release'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.release(ACE_5_6_0.ACE_Message_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.crunch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.wr_ptr(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_length'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_size'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_size_and_length(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.size'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.size(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_capacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.capacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.space'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.data_block(ACE_5_6_0.ACE_Data_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.replace_data_block(ACE_5_6_0.ACE_Data_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Data_Block'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.mark'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.release(ACE_5_6_0.ACE_Lock*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.set_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.clr_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Message_Block'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Data_Block.reference_count_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.peek_dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.enqueue_tail(ACE_5_6_0.ACE_Message_Block*,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.notification_strategy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.notification_strategy(ACE_5_6_0.ACE_Notification_Strategy*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Message_Queue_Base.state_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Message_Queue_NT'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.enqueue_tail(ACE_5_6_0.ACE_Message_Block*,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.deactivated'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_wassert(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:dirent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_READER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_WRITER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_NONE'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isAtomic'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isShared'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Connector.receive(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_SCANDIR_COMPARATOR'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_HOSTENT_DATA'. -->
        <!-- Discarding badly formed XML document comment for member 'T:msqid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'T:shmid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'T:t_call'. -->
        <!-- Discarding badly formed XML document comment for member 'T:__timeb32'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int64)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int64)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheImpl'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Handle_Set'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set.sync(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set.op_Implicit~fd_set*'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set.fdset'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set.set_max(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set_Iterator.op_FunctionCall'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Handle_Set_Iterator.handles_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Handle_Set_Iterator.handle_index_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isAtomic'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isShared'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.ResultCollector'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.CacheFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.RegionFactory.Create(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Cache.CreateRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Query`1.Execute(System.Object[],System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCqListener.close'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.CacheFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.CacheFactory.SetPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_EXCEPTION_DISPOSITION'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_HANDLE'. -->
        <!-- Discarding badly formed XML document comment for member 'D:wctrans_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_timer_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_beginthread(=FUNC:System.Void(System.Void*),System.UInt32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_OVERLAPPED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_clearfp'. -->
        <!-- Discarding badly formed XML document comment for member 'D:sig_atomic_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ucontext_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:rusage'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_RANDR_TYPE'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_log2_helper(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_Service_Object_Exterminator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Assign(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Equality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Inequality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_diskfree_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.ldname(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.strsplit_r(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE.init_fini_count_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:iovec'. -->
        <!-- Discarding badly formed XML document comment for member 'T:msghdr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ip_mreq'. -->
        <!-- Discarding badly formed XML document comment for member 'D:clock_t'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Time_Value.max_time'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.msec'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.op_MultiplicationAssignment(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThan(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThanOrEqual(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.read_n(System.Void*,System.Void*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.write_n(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.memchr(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_align_binary(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_COMPARE_FUNC'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS.exit_hook_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.object_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.param_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.starting_up'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.shutting_down'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.default_mask'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.thread_hook(ACE_5_6_0.ACE_Thread_Hook*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.at_exit(=FUNC:System.Void(System.Void))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_lfind_s(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.UInt32,=FUNC:System.Int32(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0_ace_thread_adapter(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS_Thread_Descriptor.flags_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Base_Thread_Adapter.thr_desc_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:sembuf'. -->
        <!-- Discarding badly formed XML document comment for member 'T:semid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:semun.array'. -->
        <!-- Discarding badly formed XML document comment for member 'T:siginfo_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_TSS_Ref'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_lock(ACE_5_6_0.ACE_mutex_t*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_trylock(ACE_5_6_0.ACE_mutex_t*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.priority_control(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.set_scheduling_params(ACE_5_6_0.ACE_Sched_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.unique_name(System.Void!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_clearerr_helper(_iobuf*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:passwd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ace_isalnum(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:strrecvfd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_QoS*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_QoS_Params.#ctor(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Accept_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Accept_QoS_Params.#ctor(=FUNC:System.Int32(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,iovec*,iovec*,System.UInt32*,System.UInt32!System.Runtime.CompilerServices.IsLong),System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Accept_QoS_Params.qos_condition_callback_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*,ACE_5_6_0.ACE_Accept_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr!System.Runtime.CompilerServices.IsConst*,System.Int32,ACE_5_6_0.ACE_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.socket(System.Int32,System.Int32,System.Int32,_WSAPROTOCOL_INFOA*,System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.calloc(System.UInt32,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.free(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.protect(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Allocator.delete_allocator_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Log_Msg.log(ACE_5_6_0.ACE_Log_Priority,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Log_Msg.errnum_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write_upgrade'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Adaptive_Lock'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.acquire'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.tryacquire'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_RW_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ace_yytokentype'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Mutex'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:__JUMP_BUFFER'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.handle_timeout(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.handle_close(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.read_adapter(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.register_stdin_handler(ACE_5_6_0.ACE_Event_Handler*,ACE_5_6_0.ACE_Reactor*,ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.remove_stdin_handler(ACE_5_6_0.ACE_Reactor*,ACE_5_6_0.ACE_Thread_Manager*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Notification_Buffer'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_SHLIB_HANDLE'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_DLL.get_handle(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.op_Subscript(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.op_Subscript(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.c_str'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.rfind(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.compare(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.delimiter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.delimiter_replace(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.preserve_designators(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.is_delimiter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.is_preserve_designator(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Auto_String_Free'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Repository'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Repository.fini'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Repository.delete_svc_rep_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Repository_Iterator.next(ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Adapter.invoke'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void**,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn_n(System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void**,System.UInt32*,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn_n(System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void**,System.UInt32*,System.Void**,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Object_Manager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.at_exit(ACE_5_6_0.ACE_Cleanup*,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.at_exit(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Null_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Recursive_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_RW_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.instance'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.open(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.parse_args(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.close'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.suspend(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.init_svc_conf_file_queue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Gestalt.is_opened_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Object'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Type.fini'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Type.fini_already_called_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Object_Ptr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Object_Ptr.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Control'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.#ctor(ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.insert(ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.thr_mgr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.thr_mgr(ACE_5_6_0.ACE_Thread_Manager*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Exit'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Condition_Thread_Mutex.wait(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Condition_Thread_Mutex.wait(ACE_5_6_0.ACE_Thread_Mutex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Condition_Thread_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Descriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Manager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.close'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void**,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn_n(System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,ACE_5_6_0.ACE_Task_Base*,System.Void**,System.Void**,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn_n(System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void**,System.UInt32*,System.Void**,ACE_5_6_0.ACE_Task_Base*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.join(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.thr_self'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testsuspend(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testresume(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testcancel(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testterminate(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.cancel_task(ACE_5_6_0.ACE_Task_Base*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.hthread_list(ACE_5_6_0.ACE_Task_Base*,System.Void**,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.thread_grp_list(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.hthread_grp_list(System.Int32,System.Void**,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.count_threads'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.at_exit(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_thread(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_hthread(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_task(ACE_5_6_0.ACE_Task_Base*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.check_state(System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_task(ACE_5_6_0.ACE_Task_Base*, ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_grp(System.Int32, ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_all( ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.join_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.resume_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.suspend_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.kill_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.cancel_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.register_as_terminated(ACE_5_6_0.ACE_Thread_Descriptor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Manager.lock_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Manager.delete_thr_mgr_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.init(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.init(System.UInt32,System.Int32,ACE_5_6_0.ACE_Message_Block*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Lock*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Allocator*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.set_self_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.duplicate(ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.release'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.release(ACE_5_6_0.ACE_Message_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.crunch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.wr_ptr(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_length'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_size'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_size_and_length(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.size'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.size(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_capacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.capacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.space'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.data_block(ACE_5_6_0.ACE_Data_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.replace_data_block(ACE_5_6_0.ACE_Data_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Data_Block'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.mark'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.release(ACE_5_6_0.ACE_Lock*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.set_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.clr_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Message_Block'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Data_Block.reference_count_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.peek_dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.enqueue_tail(ACE_5_6_0.ACE_Message_Block*,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.notification_strategy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.notification_strategy(ACE_5_6_0.ACE_Notification_Strategy*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Message_Queue_Base.state_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Message_Queue_NT'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.enqueue_tail(ACE_5_6_0.ACE_Message_Block*,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.deactivated'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_wassert(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:dirent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_READER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_WRITER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_NONE'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isAtomic'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isShared'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Connector.receive(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_SCANDIR_COMPARATOR'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_HOSTENT_DATA'. -->
        <!-- Discarding badly formed XML document comment for member 'T:msqid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'T:shmid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'T:t_call'. -->
        <!-- Discarding badly formed XML document comment for member 'T:__timeb32'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int64)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.StatisticsFactory.createAtomicStatistics(gemfire_statistics.StatisticsType*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int64)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Handle_Set'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set.sync(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set.op_Implicit~fd_set*'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set.fdset'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set.set_max(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Handle_Set_Iterator.op_FunctionCall'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Handle_Set_Iterator.handles_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Handle_Set_Iterator.handle_index_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCqListenerGeneric.close'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedFixedPartitionResolver.getPartitionName(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.CacheableHashSet>)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IFixedPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.RegionFactory.Create(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListener.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedFixedPartitionResolver.getPartitionName(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.CacheableHashSet>)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IFixedPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListenerGeneric.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedFixedPartitionResolverGeneric.getPartitionName(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.CacheableHashSet>)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_EXCEPTION_DISPOSITION'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_HANDLE'. -->
        <!-- Discarding badly formed XML document comment for member 'D:_Mbstatet'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_timer_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_beginthread(=FUNC:System.Void(System.Void*),System.UInt32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_OVERLAPPED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_clearfp'. -->
        <!-- Discarding badly formed XML document comment for member 'D:sig_atomic_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ucontext_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:rusage'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_RANDR_TYPE'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_exception'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_log2_helper(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_Service_Object_Exterminator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Assign(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Equality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Inequality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_diskfree_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.ldname(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.strsplit_r(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE.init_fini_count_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:iovec'. -->
        <!-- Discarding badly formed XML document comment for member 'T:msghdr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ip_mreq'. -->
        <!-- Discarding badly formed XML document comment for member 'D:clock_t'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Time_Value.max_time'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.msec'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.op_MultiplicationAssignment(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThan(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThanOrEqual(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.read_n(System.Void*,System.Void*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.write_n(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.memchr(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_align_binary(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_COMPARE_FUNC'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS.exit_hook_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.object_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.param_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.starting_up'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.shutting_down'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.default_mask'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.thread_hook(ACE_5_6_0.ACE_Thread_Hook*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.at_exit(=FUNC:System.Void(System.Void))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_lfind_s(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.UInt32,=FUNC:System.Int32(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0_ace_thread_adapter(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS_Thread_Descriptor.flags_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Base_Thread_Adapter.thr_desc_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:sembuf'. -->
        <!-- Discarding badly formed XML document comment for member 'T:semid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:semun.array'. -->
        <!-- Discarding badly formed XML document comment for member 'T:siginfo_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_TSS_Ref'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_lock(ACE_5_6_0.ACE_mutex_t*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_trylock(ACE_5_6_0.ACE_mutex_t*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.priority_control(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.set_scheduling_params(ACE_5_6_0.ACE_Sched_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.unique_name(System.Void!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_clearerr_helper(_iobuf*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:passwd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ace_isalnum(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:strrecvfd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_QoS*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_QoS_Params.#ctor(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Accept_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Accept_QoS_Params.#ctor(=FUNC:System.Int32(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,iovec*,iovec*,System.UInt32*,System.UInt32!System.Runtime.CompilerServices.IsLong),System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Accept_QoS_Params.qos_condition_callback_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*,ACE_5_6_0.ACE_Accept_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr!System.Runtime.CompilerServices.IsConst*,System.Int32,ACE_5_6_0.ACE_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.socket(System.Int32,System.Int32,System.Int32,_WSAPROTOCOL_INFOA*,System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.calloc(System.UInt32,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.free(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.protect(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Allocator.delete_allocator_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Log_Msg.log(ACE_5_6_0.ACE_Log_Priority,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Log_Msg.errnum_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write_upgrade'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Adaptive_Lock'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.acquire'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.tryacquire'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_RW_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.RegionFactory.Create(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Cache.CreateRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.AuthenticatedCache.GetRegion(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.RegionFactory.Create(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Cache.CreateRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListenerGeneric.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListenerGeneric.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedFixedPartitionResolverGeneric.getPartitionName(gemfire.EntryEvent!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.CacheableHashSet>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCqListener.close'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Cache.CreateRegion``2(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.RegionFactory.Create``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.GetRegion``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListenerGeneric.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCqListener.close'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Query.Execute(GemStone.GemFire.Cache.IGFSerializable[],System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isAtomic'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isShared'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Cache.CreateRegion``2(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCacheListener.afterRegionDisconnected(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.ResultCollector'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.ICacheListener.AfterRegionDisconnected(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IPartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.RegionFactory.Create(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Cache.CreateRegion(System.String,GemStone.GemFire.Cache.RegionAttributes)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.ResultCollector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Execution.execute(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.UInt32,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onRegion(gemfire.SharedPtr<gemfire.Region>)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onServer(gemfire.SharedPtr<gemfire.Pool>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.FunctionService.onServer(gemfire.SharedPtr<gemfire.RegionService>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.FunctionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.FunctionService.OnRegion(GemStone.GemFire.Cache.Region)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.CacheFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.AuthenticatedCache.GetRegion(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.PoolFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.ManagedCqListenerGeneric.close'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Internal.PdxLocalWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolManager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolManager.getAll'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.PoolFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticDescriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire_statistics.StatisticsType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isAtomic'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire_statistics.Statistics.isShared'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.PoolFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Cache.CreateRegion``2(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.CacheFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.CacheFactory.SetPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.RegionFactory.Create``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.GetRegion``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Cache'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.IGFSerializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.ICacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Region.Remove(GemStone.GemFire.Cache.CacheableKey,GemStone.GemFire.Cache.Serializable,GemStone.GemFire.Cache.IGFSerializable)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_EXCEPTION_DISPOSITION'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_HANDLE'. -->
        <!-- Discarding badly formed XML document comment for member 'D:wctrans_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write_upgrade'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Adaptive_Lock'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_timer_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:clock_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_beginthread(=FUNC:System.Void(System.Void*),System.UInt32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_OVERLAPPED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_clearfp'. -->
        <!-- Discarding badly formed XML document comment for member 'D:sig_atomic_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ucontext_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:rusage'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_RANDR_TYPE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Time_Value.max_time'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.msec'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.op_MultiplicationAssignment(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThan(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThanOrEqual(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_Service_Object_Exterminator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Assign(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Equality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Inequality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0_ace_thread_adapter(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS_Thread_Descriptor.flags_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Base_Thread_Adapter.thr_desc_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:sembuf'. -->
        <!-- Discarding badly formed XML document comment for member 'T:semid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:semun.array'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_align_binary(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_COMPARE_FUNC'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS.exit_hook_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.object_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.param_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.starting_up'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.shutting_down'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.default_mask'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.thread_hook(ACE_5_6_0.ACE_Thread_Hook*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.at_exit(=FUNC:System.Void(System.Void))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.memchr(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_lfind_s(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.UInt32,=FUNC:System.Int32(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:siginfo_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_TSS_Ref'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_lock(ACE_5_6_0.ACE_mutex_t*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_trylock(ACE_5_6_0.ACE_mutex_t*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.priority_control(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.set_scheduling_params(ACE_5_6_0.ACE_Sched_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.unique_name(System.Void!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_diskfree_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.read_n(System.Void*,System.Void*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.write_n(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_clearerr_helper(_iobuf*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:passwd'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Mutex'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Mutex.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.acquire'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.tryacquire'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_RW_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Log_Msg.log(ACE_5_6_0.ACE_Log_Priority,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Log_Msg.errnum_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:__JUMP_BUFFER'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.handle_timeout(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.handle_close(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.read_adapter(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.register_stdin_handler(ACE_5_6_0.ACE_Event_Handler*,ACE_5_6_0.ACE_Reactor*,ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Event_Handler.remove_stdin_handler(ACE_5_6_0.ACE_Reactor*,ACE_5_6_0.ACE_Thread_Manager*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Notification_Buffer'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ace_yytokentype'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_SHLIB_HANDLE'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_DLL.get_handle(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.calloc(System.UInt32,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.free(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.protect(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Allocator.delete_allocator_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_log2_helper(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.ldname(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.strsplit_r(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE.init_fini_count_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:iovec'. -->
        <!-- Discarding badly formed XML document comment for member 'T:msghdr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ip_mreq'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ace_isalnum(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:strrecvfd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_QoS*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_QoS_Params.#ctor(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Accept_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Accept_QoS_Params.#ctor(=FUNC:System.Int32(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,iovec*,iovec*,System.UInt32*,System.UInt32!System.Runtime.CompilerServices.IsLong),System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Accept_QoS_Params.qos_condition_callback_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*,ACE_5_6_0.ACE_Accept_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr!System.Runtime.CompilerServices.IsConst*,System.Int32,ACE_5_6_0.ACE_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.socket(System.Int32,System.Int32,System.Int32,_WSAPROTOCOL_INFOA*,System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.op_Subscript(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.op_Subscript(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.c_str'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.rfind(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_SString.compare(ACE_5_6_0.ACE_SString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.delimiter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.delimiter_replace(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.preserve_designators(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.is_delimiter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Tokenizer.is_preserve_designator(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Auto_String_Free'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.acquire(ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Recursive_Thread_Mutex.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Recursive_Thread_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Repository'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Repository.fini'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Repository.delete_svc_rep_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Repository_Iterator.next(ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Adapter.invoke'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void**,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn_n(System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void**,System.UInt32*,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread.spawn_n(System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Void**,System.UInt32*,System.Void**,ACE_5_6_0.ACE_Thread_Adapter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Object_Manager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.at_exit(ACE_5_6_0.ACE_Cleanup*,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.at_exit(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Null_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_Recursive_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.get_singleton_lock(ACE_5_6_0.ACE_RW_Thread_Mutex**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Object_Manager.instance'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.open(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.find(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Service_Type!System.Runtime.CompilerServices.IsConst**,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.parse_args(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.close'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.suspend(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Gestalt.init_svc_conf_file_queue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Gestalt.is_opened_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Object'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Type.fini'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Service_Type.fini_already_called_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Service_Object_Ptr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Service_Object_Ptr.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Control'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.#ctor(ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.insert(ACE_5_6_0.ACE_Thread_Manager*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.thr_mgr'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Control.thr_mgr(ACE_5_6_0.ACE_Thread_Manager*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Exit'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Condition_Thread_Mutex.wait(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Condition_Thread_Mutex.wait(ACE_5_6_0.ACE_Thread_Mutex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Condition_Thread_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Descriptor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Thread_Manager'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.close'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn(=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void**,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn_n(System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,ACE_5_6_0.ACE_Task_Base*,System.Void**,System.Void**,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.spawn_n(System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32,=FUNC:System.UInt32!System.Runtime.CompilerServices.IsLong(System.Void*),System.Void*,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void**,System.UInt32*,System.Void**,ACE_5_6_0.ACE_Task_Base*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.join(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.thr_self'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testsuspend(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testresume(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testcancel(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.testterminate(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.cancel_task(ACE_5_6_0.ACE_Task_Base*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.hthread_list(ACE_5_6_0.ACE_Task_Base*,System.Void**,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.thread_grp_list(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.hthread_grp_list(System.Int32,System.Void**,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.count_threads'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.at_exit(System.Void*,=FUNC:System.Void(System.Void*,System.Void*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_thread(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_hthread(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.find_task(ACE_5_6_0.ACE_Task_Base*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.check_state(System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_task(ACE_5_6_0.ACE_Task_Base*, ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_grp(System.Int32, ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.apply_all( ACE_5_6_0.ACE_Thread_Manager::*(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32),System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.join_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.resume_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.suspend_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.kill_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.cancel_thr(ACE_5_6_0.ACE_Thread_Descriptor*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Thread_Manager.register_as_terminated(ACE_5_6_0.ACE_Thread_Descriptor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Manager.lock_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Thread_Manager.delete_thr_mgr_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.init(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.init(System.UInt32,System.Int32,ACE_5_6_0.ACE_Message_Block*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Lock*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Allocator*,ACE_5_6_0.ACE_Allocator*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.set_self_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.duplicate(ACE_5_6_0.ACE_Message_Block!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.release'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.release(ACE_5_6_0.ACE_Message_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.crunch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.wr_ptr(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_length'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_size'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_size_and_length(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.size'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.size(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.total_capacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.capacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.space'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.data_block(ACE_5_6_0.ACE_Data_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Block.replace_data_block(ACE_5_6_0.ACE_Data_Block*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Data_Block'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.mark'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.release(ACE_5_6_0.ACE_Lock*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.set_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Data_Block.clr_flags(System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Message_Block'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Data_Block.reference_count_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.peek_dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.enqueue_tail(ACE_5_6_0.ACE_Message_Block*,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.notification_strategy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_Base.notification_strategy(ACE_5_6_0.ACE_Notification_Strategy*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Message_Queue_Base.state_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Message_Queue_NT'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.enqueue_tail(ACE_5_6_0.ACE_Message_Block*,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.dequeue_head(ACE_5_6_0.ACE_Message_Block**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Message_Queue_NT.deactivated'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_wassert(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:dirent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_READER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_WRITER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:M_DELETE_NONE'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.PdxIdentityFieldAttribute'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ReflectionBasedAutoSerializer'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.ResultCollector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Execution.execute(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.UInt32,System.Boolean,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.RegionShortcut'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.ICacheListener`2.AfterRegionDisconnected(GemStone.GemFire.Cache.Generic.IRegion`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.Cache.CreateRegion``2(System.String,GemStone.GemFire.Cache.Generic.RegionAttributes`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.FunctionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.FunctionService`1.OnRegion``2(GemStone.GemFire.Cache.Generic.IRegion`2{``0,``1})'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IFixedPartitionResolver`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.RegionFactory.Create``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.AuthenticatedCache.GetRegion``2(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_EXCEPTION_DISPOSITION'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_HANDLE'. -->
        <!-- Discarding badly formed XML document comment for member 'D:wctrans_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_timer_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_beginthread(=FUNC:System.Void(System.Void*),System.UInt32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_OVERLAPPED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_clearfp'. -->
        <!-- Discarding badly formed XML document comment for member 'D:sig_atomic_t'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ucontext_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:rusage'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_RANDR_TYPE'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_log2_helper(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_Service_Object_Exterminator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.#ctor(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Assign(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Equality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Errno_Guard.op_Inequality(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:_diskfree_t'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.ldname(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE.strsplit_r(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE.init_fini_count_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:iovec'. -->
        <!-- Discarding badly formed XML document comment for member 'T:msghdr'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ip_mreq'. -->
        <!-- Discarding badly formed XML document comment for member 'D:clock_t'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Time_Value.max_time'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.msec'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Time_Value.op_MultiplicationAssignment(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThan(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.op_LessThanOrEqual(ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.read_n(System.Void*,System.Void*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.write_n(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.memchr(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_align_binary(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'D:ACE_COMPARE_FUNC'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS.exit_hook_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.object_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Cleanup_Info.param_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.starting_up'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.shutting_down'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.default_mask'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.thread_hook(ACE_5_6_0.ACE_Thread_Hook*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS_Object_Manager.at_exit(=FUNC:System.Void(System.Void))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:_lfind_s(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.UInt32,=FUNC:System.Int32(System.Void*,System.Void!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*),System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0_ace_thread_adapter(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_OS_Thread_Descriptor.flags_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Base_Thread_Adapter.thr_desc_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:sembuf'. -->
        <!-- Discarding badly formed XML document comment for member 'T:semid_ds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:semun.array'. -->
        <!-- Discarding badly formed XML document comment for member 'T:siginfo_t'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_TSS_Ref'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_lock(ACE_5_6_0.ACE_mutex_t*,ACE_5_6_0.ACE_Time_Value!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.mutex_trylock(ACE_5_6_0.ACE_mutex_t*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.priority_control(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.set_scheduling_params(ACE_5_6_0.ACE_Sched_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.unique_name(System.Void!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ace_clearerr_helper(_iobuf*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:passwd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ace_isalnum(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:strrecvfd'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.Int32,System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong*,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.ioctl(System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,ACE_5_6_0.ACE_QoS*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Void*,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,=FUNC:System.Void(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32!System.Runtime.CompilerServices.IsLong,_OVERLAPPED*,System.UInt32!System.Runtime.CompilerServices.IsLong))'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_QoS_Params.#ctor(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Accept_QoS_Params'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Accept_QoS_Params.#ctor(=FUNC:System.Int32(iovec*,iovec*,ACE_5_6_0.ACE_QoS*,ACE_5_6_0.ACE_QoS*,iovec*,iovec*,System.UInt32*,System.UInt32!System.Runtime.CompilerServices.IsLong),System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Accept_QoS_Params.qos_condition_callback_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.accept(System.Void*,sockaddr*,System.Int32*,ACE_5_6_0.ACE_Accept_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.connect(System.Void*,sockaddr!System.Runtime.CompilerServices.IsConst*,System.Int32,ACE_5_6_0.ACE_QoS_Params!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_OS.socket(System.Int32,System.Int32,System.Int32,_WSAPROTOCOL_INFOA*,System.UInt32,System.UInt32!System.Runtime.CompilerServices.IsLong)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.calloc(System.UInt32,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.free(System.Void*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Allocator.protect(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Allocator.delete_allocator_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Log_Msg.log(ACE_5_6_0.ACE_Log_Priority,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_Log_Msg.errnum_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.acquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_read'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Lock.tryacquire_write_upgrade'. -->
        <!-- Discarding badly formed XML document comment for member 'T:ACE_5_6_0.ACE_Adaptive_Lock'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_Adaptive_Lock.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.acquire'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ACE_5_6_0.ACE_RW_Mutex.tryacquire'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ACE_5_6_0.ACE_RW_Mutex.removed_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Log'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Log.formatLogLine(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,gemfire.Log.LogLevel)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionService'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.GemFireCache'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastModifiedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheStatistics.getLastAccessedTime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.HashMapOfSharedBase.insert(gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.SharedBase>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.RegionEntry'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.RegionEntry.isDestroyed'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheListener.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PartitionResolver'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheWriter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheWriter.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheLoader.close(gemfire.SharedPtr<gemfire.Region>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesMutator'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheAttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.PoolFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_FREE_CONNECTION_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_LOAD_CONDITIONING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SOCKET_BUFFER_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_READ_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MIN_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MAX_CONNECTIONS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_IDLE_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_RETRY_ATTEMPTS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PING_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_STATISTIC_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_REDUNDANCY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_MESSAGE_TRACKING_TIMEOUT'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SUBSCRIPTION_ACK_INTERVAL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_SERVER_GROUP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_THREAD_LOCAL_CONN'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_MULTIUSER_SECURE_MODE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:gemfire.PoolFactory.DEFAULT_PR_SINGLE_HOP_ENABLED'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.PoolFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.CacheFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setLoadConditioningInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setThreadLocalConnections(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setStatisticInterval(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.CacheFactory.setPdxIgnoreUnreadFields(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.Pool'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Pool.getLocators'. -->
        <!-- Discarding badly formed XML document comment for member 'T:gemfire.AttributesFactory'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.get(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.put(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.putAll(gemfire.HashMapOfCacheable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localPut(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.create(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localCreate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.invalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localInvalidate(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.destroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localDestroy(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.remove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.removeEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemove(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.localRemoveEx(gemfire.SharedPtr<gemfire.CacheableKey>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.Serializable>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:gemfire.Region.getAll(gemfire.VectorOfCacheableKey!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,gemfire.SharedPtr<gemfire.HashMapOfCacheable>,gemfire.SharedPtr<gemfire.HashMapOfException>,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.ISubscriptionService`1'. -->
        <!-- Discarding badly formed XML document comment for member 'T:GemStone.GemFire.Cache.Generic.IRegion`2'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumerator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEnumeratorOld'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Add(System.Collections.Generic.KeyValuePair`2{`0,`1})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Clear'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Count'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.IRegion`2.Values'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Invalidate(`0,System.Object)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntry(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetEntries(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ContainsValueForKey(`0)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetSubscriptionService'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.GetLocalView'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.Query``1(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.ExistsValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IRegion`2.SelectValue(System.String,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.Servers'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.Pool.MultiuserAuthentication'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.PoolFactory.SetPRSingleHopEnabled(System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:GemStone.GemFire.Cache.Generic.CacheableString.ClassId'. -->
        <!-- Discarding badly formed XML document comment for member 'M:GemStone.GemFire.Cache.Generic.IPdxWriter.WriteField(System.String,System.Object,System.Type)'. -->
    </members>
</doc>
