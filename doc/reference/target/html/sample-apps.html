<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;3.&nbsp;Sample Applications</title><link rel="stylesheet" href="styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_8103"><link rel="home" href="index.html" title="Spring AMQP - Reference Documentation"><link rel="up" href="pt02.html" title="Part&nbsp;II.&nbsp;Reference"><link rel="prev" href="erlang.html" title="Chapter&nbsp;2.&nbsp;Erlang integration"><link rel="next" href="resources.html" title="Part&nbsp;III.&nbsp;Other Resources"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.net/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></img></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/S2-banner-rhs.png"></img></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="sample-apps"></a>Chapter&nbsp;3.&nbsp;Sample Applications</h2></div></div></div>
  

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e237"></a>3.1.&nbsp;Introduction</h2></div></div></div>
    

    <p>The Spring AMQP project includes two sample applications. The first
    is a simple "Hello World" example that demonstrates both synchronous and
    asynchronous message reception. It provides an excellent starting point
    for acquiring an understanding of the essential components. The second
    sample is based on a simplified stock-trading use case to demonstrate the
    types of interaction that would be common in real world applications. In
    this chapter, we will provide a quick walk-through of each sample so that
    you can focus on the most important components. The samples are available
    in the distribution in the main solution file.</p>
  </div>

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e240"></a>3.2.&nbsp;Hello World</h2></div></div></div>
    

    <p>The Hello World sample demonstrates both synchronous and
    asynchronous message reception.</p>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="hello-world-sync"></a>3.2.1.&nbsp;Synchronous Example</h3></div></div></div>
      

      <p>Within the HelloWorld solution folder navigate to the
      Spring.Amqp.HelloWorld.BrokerConfiguration class. Run the "Program.cs"
      main application there in order to create a new queue declartion named
      "<code class="literal">hello.world.queue</code>" on the broker.</p>

      <p>The HelloWorld/Sync solution folder has a project named
      Spring.Amqp.HelloWorldProducer. The Spring XML configuration for
      creating the RabbitTemplate instance is shown below</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;objects</span> <span style="color: #FF0000">xmlns</span>=<span style="color: #0000FF">"http://www.springframework.net"</span><span style="color: #A31515">&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Connection.SingleConnectionFactory, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
    
  <span style="color: #A31515">&lt;/object&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"RabbitTemplate"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Core.RabbitTemplate, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;constructor-arg</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ConnectionFactory"</span><span style="color: #A31515">/&gt;</span>
    <i style="color: #008000">&lt;!-- The queue will be bound to the default direct exchange unless specified otherwise --&gt;</i>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"Queue"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"hello.world.queue"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"RoutingKey"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"hello.world.queue"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>

<span style="color: #A31515">&lt;/objects&gt;</span></pre>

      <p> This is identical to the configuration of the Consumer
      application.</p>

      <p>Looking back at the "rabbitTemplate" object definition
      configuration, you will see that it has the helloWorldQueue's name set
      as its "queue" property (for receiving Messages) and for its
      "routingKey" property (for sending Messages).</p>

      <p>Now that we've explored the configuration, let's look at the code
      that actually uses these components. First, open the Program.cs file in
      the Producer project It contains a main() method where the Spring
      ApplicationContext is created.</p>

      <pre class="programlisting">        <span style="color: #0000FF">static</span> <span style="color: #0000FF">void</span> Main(<span style="color: #0000FF">string</span>[] args)
        {
            <span style="color: #0000FF">using</span> (IApplicationContext ctx = ContextRegistry.GetContext())
            {
                IAmqpTemplate amqpTemplate = (IAmqpTemplate) ctx.GetObject(<span style="color: #000000">"RabbitTemplate"</span>);
                log.Info(<span style="color: #000000">"Sending hello world message."</span>);
                amqpTemplate.ConvertAndSend(<span style="color: #000000">"Hello World"</span>);
                log.Info(<span style="color: #000000">"Hello world message sent."</span>);                
            }

            Console.WriteLine(<span style="color: #000000">"Press 'enter' to exit."</span>);
            Console.ReadLine();
        }</pre>

      <p>As you can see in the example above, an instance of the
      IAmqpTemplate interface is retrieved and used for sending a Message.
      Since the client code should rely on interfaces whenever possible, the
      type is <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IAmqpTemplate</span> rather than
      RabbitTemplate. Even though this is just a simple example, relying on
      the interface means that this code is more portable (the configuration
      can be changed independently of the code). Since the ConvertAndSend()
      method is invoked, the template will be delegating to its
      IMessageConverter instance. In this case, it's using the default
      SimpleMessageConverter, but a different implementation could be provided
      to the "rabbitTemplate" bean as defined in
      HelloWorldConfiguration.</p>

      <p>Now open the Consumer project. It actually shares the same
      configuration as the producer project. The Consumer code is basically a
      mirror image of the Producer, calling ReceiveAndConvert() rather than
      ConvertAndSend().</p>

      <pre class="programlisting">        <span style="color: #0000FF">static</span> <span style="color: #0000FF">void</span> Main(<span style="color: #0000FF">string</span>[] args)
        {
            <span style="color: #0000FF">using</span> (IApplicationContext ctx = ContextRegistry.GetContext())
            {
                IAmqpTemplate amqpTemplate = (IAmqpTemplate)ctx.GetObject(<span style="color: #000000">"RabbitTemplate"</span>);
                log.Info(<span style="color: #000000">"Synchronous pull"</span>);
                String message = (String) amqpTemplate.ReceiveAndConvert();
                <span style="color: #0000FF">if</span> (message == <span style="color: #0000FF">null</span>)
                {
                    log.Info(<span style="color: #000000">"[No message present on queue to receive.]"</span>);
                }
                <span style="color: #0000FF">else</span>
                {
                    log.Info(<span style="color: #000000">"Received: "</span> + message);
                }
            }

            Console.WriteLine(<span style="color: #000000">"Press 'enter' to exit."</span>);
            Console.ReadLine();
        }</pre>

      <p>If you run the Producer, and then run the Consumer, you should see
      the message "Received: Hello World" in the console output.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="hello-world-async"></a>3.2.2.&nbsp;Asynchronous Example</h3></div></div></div>
      

      <p>Now that we've walked through the synchronous Hello World sample,
      it's time to move on to a slightly more advanced but significantly more
      powerful option. With a few modifications, the Hello World sample can
      provide an example of asynchronous reception, a.k.a.
      <span class="emphasis"><em>Message-driven POCOs</em></span>. In fact, there is a proejct
      that provides exactly that in HelloWorld/Async solution folder.</p>

      <p>Once again, we will start with the sending side. Open the
      ProducerConfiguration class and notice that it creates a
      "connectionFactory" and "rabbitTemplate" object definition. Recall that
      messages are sent to an Exchange rather than being sent directly to a
      Queue. The AMQP default Exchange is a direct Exchange with no name. All
      Queues are bound to that default Exchange with their name as the routing
      key. That is why we only need to provide the routing key here.</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;objects</span> <span style="color: #FF0000">xmlns</span>=<span style="color: #0000FF">"http://www.springframework.net"</span><span style="color: #A31515">&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Connection.SingleConnectionFactory, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>

  <span style="color: #A31515">&lt;/object&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"RabbitTemplate"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Core.RabbitTemplate, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;constructor-arg</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ConnectionFactory"</span><span style="color: #A31515">/&gt;</span>
    <i style="color: #008000">&lt;!-- The queue will be bound to the default direct exchange unless specified otherwise --&gt;</i>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"RoutingKey"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"hello.world.queue"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>

<span style="color: #A31515">&lt;/objects&gt;</span>
</pre>

      <p>Since this sample will be demonstrating asynchronous message
      reception, the producing side is designed to continuously send messages
      (if it were a message-per-execution model like the synchronous version,
      it would not be quite so obvious that it is in fact a message-driven
      consumer).</p>

      <pre class="programlisting">    <span style="color: #0000FF">class</span> Program
    {
        <span style="color: #0000FF">private</span> <span style="color: #0000FF">static</span> <span style="color: #0000FF">readonly</span> ILog log = LogManager.GetLogger(<span style="color: #0000FF">typeof</span>(Program));

        <span style="color: #0000FF">static</span> <span style="color: #0000FF">void</span> Main(<span style="color: #0000FF">string</span>[] args)
        {
            <span style="color: #0000FF">using</span> (IApplicationContext ctx = ContextRegistry.GetContext())
            {
                IAmqpTemplate amqpTemplate = (IAmqpTemplate)ctx.GetObject(<span style="color: #000000">"RabbitTemplate"</span>);
                <span style="color: #0000FF">int</span> i = 0;
                <span style="color: #0000FF">while</span> (<span style="color: #0000FF">true</span>)
                {
                    amqpTemplate.ConvertAndSend(<span style="color: #000000">"Hello World "</span> + i++);
                    log.Info(<span style="color: #000000">"Hello world message sent."</span>);
                    Thread.Sleep(3000);
                }
            }            
        }
    }</pre>

      <p>Now, let's turn to the receiving side. To emphasize the
      Message-driven POCO behavior will start with the component that is
      reacting to the messages. The class is called HelloWorldHandler.</p>

      <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> HelloWorldHandler
    {
        <span style="color: #0000FF">public</span> <span style="color: #0000FF">void</span> HandleMessage(<span style="color: #0000FF">string</span> text)
        {
            Console.WriteLine(<span style="color: #000000">"Received: "</span> + text);
        }
    }
</pre>

      <p>Clearly, that <span class="emphasis"><em>is</em></span> a POCO. It does not extend
      any base class, it doesn't implement any interfaces, and it doesn't even
      contain any imports. It is being "adapted" to the MessageListener
      interface by the Spring AMQP MessageListenerAdapter. That adapter can
      then be configured on a SimpleMessageListenerContainer. For this sample,
      the container is created in the Application.xml configuration file. You
      can see the POCO declared there.</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;objects</span> <span style="color: #FF0000">xmlns</span>=<span style="color: #0000FF">"http://www.springframework.net"</span><span style="color: #A31515">&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Connection.SingleConnectionFactory, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>

  <span style="color: #A31515">&lt;/object&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MessageListenerContainer"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Listener.SimpleMessageListenerContainer, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ConnectionFactory"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"Queue"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"hello.world.queue"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ConcurrentConsumers"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"5"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"MessageListener"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MessageListenerAdapter"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>


  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MessageListenerAdapter"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Listener.Adapter.MessageListenerAdapter, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"HandlerObject"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"HelloWorldHandler"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"HelloWorldHandler"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Amqp.HelloWorld.Consumer.Async.HelloWorldHandler, Spring.Amqp.HelloWorld.Consumer.Async"</span><span style="color: #A31515">&gt;</span>
    
  <span style="color: #A31515">&lt;/object&gt;</span>


<span style="color: #A31515">&lt;/objects&gt;</span></pre>

      <p>You can start the Producer and Consumer in any order, and you
      should see messages being sent and received every 3 seconds.</p>

      <p>To run the application make sure that you select the properties of
      the top level solution and select "Multiple Startup Project" option.
      Pick the producer and consumer applications"</p>
    </div>
  </div>

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e273"></a>3.3.&nbsp;Stock Trading</h2></div></div></div>
    

    <p>TODO</p>
  </div>
</div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="erlang.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="resources.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Erlang integration&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource</a></span></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;III.&nbsp;Other Resources</td></tr></table></div></body></html>