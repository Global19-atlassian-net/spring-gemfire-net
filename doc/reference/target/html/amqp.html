<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;1.&nbsp;Using Spring AMQP</title><link rel="stylesheet" href="styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_8103"><link rel="home" href="index.html" title="Spring AMQP - Reference Documentation"><link rel="up" href="pt02.html" title="Part&nbsp;II.&nbsp;Reference"><link rel="prev" href="pt02.html" title="Part&nbsp;II.&nbsp;Reference"><link rel="next" href="erlang.html" title="Chapter&nbsp;2.&nbsp;Erlang integration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.net/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></img></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/S2-banner-rhs.png"></img></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="amqp"></a>Chapter&nbsp;1.&nbsp;Using Spring AMQP</h2></div></div></div>
  

  <p>In this chapter, we will explore interface and classes that are the
  essential components for developing applications with Spring AMQP.</p>

  <div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e37"></a>1.1.&nbsp;AMQP Abstractions</h2></div></div></div>
    

    <p>The Spring AMQP project consists of a few assemblies. The assembly
    <code class="literal">Spring.Messaging.Amqp</code> contains the classes that
    represent the core AMQP "model". Our intention is to provide generic
    abstractions that do not rely on any particular AMQP broker implementation
    or client library. As a result, end user code will be more portable across
    vendor implementations as it can be developed against the abstraction
    layer only. These abstractions are then used implemented by
    broker-specific modules, such as
    '<code class="literal">Spring.Messaging.Amqp.Rabbit</code>'. For the M1 release
    RabbitMQ and Apache Qpid (2 versions) have been used to vet these base
    abstractions.</p>

    <p>The overview here assumes that you are already familiar with the
    basics of the AMQP specification already. If you are not, then have a look
    at the resources listed in <a class="xref" href="resources.html" title="Part&nbsp;III.&nbsp;Other Resources">Part&nbsp;III, &#8220;Other Resources&#8221;</a></p>

    <div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e44"></a>1.1.1.&nbsp;Message</h3></div></div></div>
      

      <p>The 0-8 and 0-9-1 AMQP specifications do not define an Message
      class or interface. Instead, when performing an operation such as
      '<code class="literal">
          <code class="methodname">basicPublish</code>
        </code>', the content is passed as a byte-array argument and
      additional properties are passed in as separate arguments. Spring AMQP
      defines a Message class as part of a more general AMQP domain model
      representation. The purpose of the Message class is to simply
      encapsulate the body and properties within a single instance so that the
      rest of the API can in turn be simpler. The Message class definition is
      quite straightforward.</p>

      <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> Message 
    {
        <span style="color: #0000FF">private</span> <span style="color: #0000FF">readonly</span> IMessageProperties messageProperties;

        <span style="color: #0000FF">private</span> <span style="color: #0000FF">readonly</span> <span style="color: #0000FF">byte</span>[] body;

        <span style="color: #0000FF">public</span> Message(<span style="color: #0000FF">byte</span>[] body, IMessageProperties messageProperties)
        {
            <span style="color: #0000FF">this</span>.body = body;
            <span style="color: #0000FF">this</span>.messageProperties = messageProperties;
        }

        <span style="color: #0000FF">public</span> <span style="color: #0000FF">byte</span>[] Body
        {
            <span style="color: #0000FF">get</span> { <span style="color: #0000FF">return</span> body; }
        }

        <span style="color: #0000FF">public</span> IMessageProperties MessageProperties
        {
            <span style="color: #0000FF">get</span> { <span style="color: #0000FF">return</span> messageProperties; }           
        }

    }</pre>

      <p>The <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IMessageProperties</span> interface
      defines several common properties such as 'messageId', 'timestamp',
      'contentType', and several more. Those properties can also be extended
      with user-defined 'headers' by calling the <code class="methodname">SetHeader(string
      key, object val)</code> method.</p>
    </div>

    <div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e53"></a>1.1.2.&nbsp;Exchange</h3></div></div></div>
      

      <p>The <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IExchange</span> interface represents
      an AMQP Exchange, which is what a Message Producer sends to. Each
      Exchange within a virtual host of a broker will have a unique name as
      well as a few other properties:</p>

      <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IExchange
    {
        <span style="color: #0000FF">string</span> Name { <span style="color: #0000FF">get</span>; }

        ExchangeType ExchangeType { <span style="color: #0000FF">get</span>; }

        <span style="color: #0000FF">bool</span> Durable { <span style="color: #0000FF">get</span>; }

        <span style="color: #0000FF">bool</span> AutoDelete { <span style="color: #0000FF">get</span>;  }

        IDictionary Arguments { <span style="color: #0000FF">get</span>;  }

    }</pre>

      <p>As you can see, an Exchange also has a 'type' represented by the
      enumeration <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">ExchangeType</span>. The basic types are:
      <code class="literal">Direct</code>, <code class="literal">Topic</code> and
      <code class="literal">Fanout</code>. In the core package you will find
      implementations of the <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IExchange</span>
      interface for each of those types. The behavior varies across these
      Exchange types in terms of how they handle bindings to Queues. A Direct
      exchange allows for a Queue to be bound by a fixed routing key (often
      the Queue's name). A Topic exchange supports bindings with routing
      patterns that may include the '*' and '#' wild cards for 'exactly-one'
      and 'zero-or-more', respectively. The Fanout exchange publishes to all
      Queues that are bound to it without taking any routing key into
      consideration. For much more information about Exchange types, check out
      <a class="xref" href="resources.html" title="Part&nbsp;III.&nbsp;Other Resources">Part&nbsp;III, &#8220;Other Resources&#8221;</a>.</p>

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>The AMQP specification also requires that any broker provide a
        "default" Direct Exchange that has no name. All Queues that are
        declared will be bound to that default Exchange with their names as
        routing keys. You will learn more about the default Exchange's usage
        within Spring AMQP in <a class="xref" href="amqp.html#amqp-template" title="1.3.&nbsp;AmqpTemplate">Section&nbsp;1.3, &#8220;AmqpTemplate&#8221;</a>.</p>
      </td></tr></table></div>
    </div>

    <div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e68"></a>1.1.3.&nbsp;Queue</h3></div></div></div>
      

      <p>The <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">Queue</span> class represents the component
      from which a Message Consumer receives Messages. Like the various
      Exchange classes, our implementation is intended to be an abstract
      representation of this core AMQP type.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> Queue  {

   <span style="color: #0000FF">private</span> <span style="color: #0000FF">readonly</span> <span style="color: #0000FF">string</span> name;

   <span style="color: #0000FF">private</span> <span style="color: #0000FF">volatile</span> <span style="color: #0000FF">bool</span> durable;

   <span style="color: #0000FF">private</span> <span style="color: #0000FF">volatile</span> <span style="color: #0000FF">bool</span> exclusive;

   <span style="color: #0000FF">private</span> <span style="color: #0000FF">volatile</span> <span style="color: #0000FF">bool</span> autoDelete;

   <span style="color: #0000FF">private</span> <span style="color: #0000FF">volatile</span> IDictionary arguments;

   <span style="color: #0000FF">public</span> Queue(<span style="color: #0000FF">string</span> name)
   {
       <span style="color: #0000FF">this</span>.name = name;
   }

   <i style="color: #008000">// Property setter and getters  omitted for brevity</i>
}
</pre>

      <p>Notice that the constructor takes the Queue name. Depending on the
      implementation, the admin template may provide methods for generating a
      uniquely named Queue. Such Queues can be useful as a "reply-to" address
      or other <span class="emphasis"><em>temporary</em></span> situations. For that reason, the
      'exclusive' and 'autoDelete' properties of an auto-generated Queue would
      both be set to 'true'.</p>
    </div>

    <div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e75"></a>1.1.4.&nbsp;Binding</h3></div></div></div>
      

      <p>Given that a producer sends to an Exchange and a consumer receives
      from a Queue, the bindings that connect Queues to Exchanges are critical
      for connecting those producers and consumers via messaging. In Spring
      AMQP, we define a <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">Binding</span> class to represent
      those connections. Let's review the basic options for binding Queues to
      Exchanges.</p>

      <p>You can bind a Queue to a DirectExchange with a fixed routing
      key.</p>

      <pre class="programlisting"><span style="color: #0000FF">new</span> Binding(someQueue, someDirectExchange, <span style="color: #000000">"foo.bar"</span>)</pre>

      <p>You can bind a Queue to a TopicExchange with a routing
      pattern.</p>

      <pre class="programlisting"><span style="color: #0000FF">new</span> Binding(someQueue, someTopicExchange, <span style="color: #000000">"foo.*"</span>)</pre>

      <p>You can bind a Queue to a FanoutExchange with no routing
      key.</p>

      <pre class="programlisting"><span style="color: #0000FF">new</span> Binding(someQueue, someFanoutExchange)</pre>

      <p>We also provide a <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">BindingBuilder</span> to
      facilitate a "fluent API" style.</p>

      <pre class="programlisting">Binding b = BindingBuilder.From(someQueue).To(someTopicExchange).With(<span style="color: #000000">"foo.*"</span>);</pre>

      <p>By itself, an instance of the Binding class is just holding the
      data about a connection. In other words, it is not an "active"
      component. However, as you will see later in <a class="xref" href="amqp.html#broker-configuration" title="1.7.&nbsp;Configuring the broker">Section&nbsp;1.7, &#8220;Configuring the broker&#8221;</a>, Binding instances can be used by the
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IAmqpAdmin</span> interface to actually trigger
      the binding actions on the broker.</p>
    </div>

    <p>The interface <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IAmqpTemplate</span> is also
    defined within the Spring.Messaging.Amqp assembly. As one of the main
    components involved in actual AMQP messaging, it is discussed in detail in
    its own section (see <a class="xref" href="amqp.html#amqp-template" title="1.3.&nbsp;AmqpTemplate">Section&nbsp;1.3, &#8220;AmqpTemplate&#8221;</a>).</p>
  </div>

  <div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e94"></a>1.2.&nbsp;Connection and Resource Management</h2></div></div></div>
    

    <p>Whereas the AMQP model we described in the previous section is
    generic and applicable to all implementations, when we get into the
    management of resources, the details are specific to the broker
    implementation. Therefore, in this section, we will be focusing on code
    that exists only within the Spring.Messaging.Amqp.Rabbit assembly since at
    this point, RabbitMQ is the only supported implementation.</p>

    <p>The central component for managing a connection to the RabbitMQ
    broker is the <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IConnectionFactory</span> interface.
    The responsibility of a <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IConnectionFactory</span>
    implementation is to provide an instance of
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">RabbitMQ.Client.Connection</span>. The simplest
    implementation we provide is
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SingleConnectionFactory</span> which establishes a single
    connection that can be shared by the application. Sharing of the
    connection is possible since the "unit of work" for messaging with AMQP is
    actually a "channel" (in some ways, this is similar to the relationship
    between a Connection and a Session in JMS). As you can imagine, the
    connection instance provides a <code class="methodname">CreateChannel</code>
    method. When creating an instance of
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SingleConnectionFactory</span>, the 'hostname' can be
    provided via the constructor. The 'username' and 'password' properties
    should be provided as well.</p>

    <pre class="programlisting">SingleConnectionFactory connectionFactory = <span style="color: #0000FF">new</span> SingleConnectionFactory(<span style="color: #000000">"somehost"</span>);
connectionFactory.UserName = <span style="color: #000000">"guest"</span>;
connectionFactory.Password = <span style="color: #000000">"guest"</span>;

IConnection connection = connectionFactory.CreateConnection();</pre>

    <p>When using XML, the configuration might look like this:</p>

    <pre class="programlisting"><span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Connection.SingleConnectionFactory, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
  <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"Username"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"guest"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"Password"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"guest"</span><span style="color: #A31515">/&gt;</span>
<span style="color: #A31515">&lt;/object&gt;</span>
</pre>

    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
         You may also discover the 

        <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">CachingConnectionFactory</span>

         implementation, but at this time, that code is considered 

        <span class="emphasis"><em>experimental</em></span>

         . We recommend sticking with 

        <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SingleConnectionFactory</span>

         for now as the caching implementation will most likely evolve. Support for fail over of connections is also planned. 
      </td></tr></table></div>
  </div>

  <div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="amqp-template"></a>1.3.&nbsp;AmqpTemplate</h2></div></div></div>
    

    <p>As with many other high-level abstractions provided by the Spring
    Framework and related projects, Spring AMQP provides a "template" that
    plays a central role. The interface that defines the main operations is
    called <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IAmqpTemplate</span>. Those operations
    cover the general behavior for sending and receiving Messages. In other
    words, they are not unique to any implementation, hence the "AMQP" in the
    name. On the other hand, there are implementations of that interface that
    are tied to implementations of the AMQP protocol. Unlike JMS, which is an
    interface-level API itself, AMQP is a wire-level protocol. The
    implementations of that protocol provide their own client libraries, so
    each implementation of the template interface will depend on a particular
    client library. Currently, there is only one complete implementation:
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">RabbitTemplate</span> but the QpidTemplate has some of its
    methods implemented in M1. In the examples that follow, you will often see
    usage of an "<code class="literal">IAmqpTemplate</code>", but when you look at the
    configuration examples, or any code excerpts where the template is
    instantiated and/or setters are invoked, you will see the implementation
    type (e.g. "RabbitTemplate").</p>

    <p>As mentioned above, the <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IAmqpTemplate</span>
    interface defines all of the basic operations for sending and receiving
    Messages. We will explore Message sending and reception, respectively, in
    the two sections that follow. The IRabbitOperations interface contains
    additional send and execute methods that rely on specific RabbitMQ AMQP
    channel classes.</p>
  </div>

  <div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e120"></a>1.4.&nbsp;Sending messages</h2></div></div></div>
    

    <p>When sending a Message, one can use any of the following
    methods:</p>

    <pre class="programlisting"><span style="color: #0000FF">void</span> Send(MessageCreatorDelegate messageCreator);

<span style="color: #0000FF">void</span> Send(<span style="color: #0000FF">string</span> routingkey, MessageCreatorDelegate messageCreator);

<span style="color: #0000FF">void</span> Send(<span style="color: #0000FF">string</span> exchange, <span style="color: #0000FF">string</span> routingKey, MessageCreatorDelegate messageCreatorDelegate);</pre>

    <p>We can begin our discussion with the last method listed above since
    it is actually the most explicit. It allows an AMQP Exchange name to be
    provided at runtime along with a routing key. The last parameter is the
    callback that is responsible for actual creating of the Message instance.
    An example of using this method to send a Message might look this
    this:</p>

    <pre class="programlisting">template.Send(<span style="color: #000000">"marketData.topic"</span>, <span style="color: #000000">"quotes.nasdaq.FOO"</span>, channel =&gt; <span style="color: #0000FF">new</span> Message(Encoding.UTF8.GetBytes(<span style="color: #000000">"12.34"</span>), someProperties) );</pre>

    <p>The "exchange" property can be set on the template itself if you
    plan to use that template instance to send to the same exchange most or
    all of the time. In such cases, the second method listed above may be used
    instead. The following example is functionally equivalent to the previous
    one:</p>

    <pre class="programlisting">amqpTemplate.Exchange = <span style="color: #000000">"marketData.topic"</span>;
amqpTemplate.Send(<span style="color: #000000">"quotes.nasdaq.FOO"</span>, channel =&gt; <span style="color: #0000FF">new</span> Message(Encoding.UTF8.GetBytes(<span style="color: #000000">"12.34"</span>), someProperties) );</pre>

    <p>If both the "exchange" and "routingKey" properties are set on the
    template, then the method accepting only the
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">MessageCreator</span> may be used:</p>

    <pre class="programlisting">amqpTemplate.Exchange = <span style="color: #000000">"marketData.topic"</span>;
amqpTemplate.RoutingKey =<span style="color: #000000">"quotes.nasdaq.FOO"</span>;
amqpTemplate.Send(channel =&gt; <span style="color: #0000FF">new</span> Message(Encoding.UTF8.GetBytes(<span style="color: #000000">"12.34"</span>), someProperties) );</pre>

    <p>A better way of thinking about the exchange and routing key
    properties is that the explicit method parameters will always override the
    template's default values. In fact, even if you do not explicitly set
    those properties on the template, there are always default values in
    place. In both cases, the default is an empty String, but that is actually
    a sensible default. As far as the routing key is concerned, it's not
    always necessary in the first place (e.g. a Fanout Exchange). Furthermore,
    a Queue may be bound to an Exchange with an empty String. Those are both
    legitimate scenarios for reliance on the default empty String value for
    the routing key property of the template. As far as the Exchange name is
    concerned, the empty String is quite commonly used because the AMQP
    specification defines the "default Exchange" as having no name. Since all
    Queues are automatically bound to that default Exchange (which is a Direct
    Exchange) using their name as the binding value, that second method above
    can be used for simple point-to-point Messaging to any Queue through the
    default Exchange. Simply provide the queue name as the "routingKey" -
    either by providing the method parameter at runtime:</p>

    <pre class="programlisting">RabbitTemplate template = <span style="color: #0000FF">new</span> RabbitTemplate(<span style="color: #0000FF">new</span> SingleConnectionFactory()); <i style="color: #008000">// using default no-name Exchange</i>
template.Send(<span style="color: #000000">"queue.helloWorld"</span>, channel =&gt; <span style="color: #0000FF">new</span> Message(<span style="color: #000000">"Hello World"</span>.getBytes(), someProperties) );</pre>

    <p>Or, if you prefer to create a template that will be used for
    publishing primarily or exclusively to a single Queue, the following is
    perfectly reasonable:</p>

    <pre class="programlisting">RabbitTemplate template = <span style="color: #0000FF">new</span> RabbitTemplate(); <i style="color: #008000">// using default no-name Exchange</i>
template.RoutingKey = <span style="color: #000000">"queue.helloWorld"</span>;       <i style="color: #008000">// but we'll always send to this Queue</i>
template.Send(channel =&gt; <span style="color: #0000FF">new</span> Message(Encoding.UTF8.GetBytes(<span style="color: #000000">"Hello World"</span>), someProperties) );</pre>
  </div>

  <div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e135"></a>1.5.&nbsp;Receiving messages</h2></div></div></div>
    

    <p>Message reception is always a bit more complicated than sending. The
    reason is that there are two ways to receive a Message. The simpler option
    is to poll for a single Message at a time with a synchronous, blocking
    method call. The more complicated yet more common approach is to register
    a listener that will receive Messages on-demand, asynchronously. We will
    look at an example of each approach in the next two sub-sections.</p>

    <div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e138"></a>1.5.1.&nbsp;Synchronous Reception</h3></div></div></div>
      

      <p>The <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IAmqpTemplate</span> itself can be
      used for synchronous Message reception. There are two 'receive' methods
      available. As with the Exchange on the sending side, there is a method
      that requires a queue property having been set directly on the template
      itself, and there is a method that accepts a queue parameter at
      runtime.</p>

      <pre class="programlisting">Message Receive();

Message Receive(<span style="color: #0000FF">string</span> queueName);</pre>
    </div>

    <div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e143"></a>1.5.2.&nbsp;Asynchronous Reception</h3></div></div></div>
       

      

       

      <p>For asynchronous Message reception, a dedicated component other
      than the <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">AmqpTemplate</span> is involved. That
      component is a container for a Message consuming callback. We will look
      at the container and its properties in just a moment, but first we
      should look at the callback since that is where your application code
      will be integrated with the messaging system. There are a few options
      for the callback. The simplest of these is to implement the
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">MessageListener</span> interface:</p>

       

      <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IMessageListener
    {
        <span style="color: #0000FF">void</span> OnMessage(Message message);
    }</pre>

       

      <p>If your callback logic depends upon the AMQP Channel instance for
      any reason, you may instead use the
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IChannelAwareMessageListener</span>. It looks
      similar but with an extra parameter:</p>

       

      <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IChannelAwareMessageListener
    {
        <span style="color: #0000FF">void</span> OnMessage(Message message, IModel model);
    }</pre>

       

      <p>If you prefer to maintain a stricter separation between your
      application logic and the messaging API, you can rely upon an adapter
      implementation that is provided by the framework. This is often referred
      to as "Message-driven POCO" support. When using the adapter, you only
      need to provide a reference to the instance that the adapter itself
      should invoke.</p>

       

      <pre class="programlisting">IMessageListener listener = <span style="color: #0000FF">new</span> MessageListenerAdapter(somePojo);</pre>

       Now that you've seen the various options for the Message-listening callback, we can turn our attention to the container. Basically, the container handles the "active" responsibilities so that the listener callback can remain passive. The container is an example of a "lifecycle" component. It provides methods for starting and stopping. When configuring the container, you are essentially bridging the gap between an AMQP Queue and the 

      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">MessageListener</span>

       instance. You must provide a reference to the 

      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">ConnectionFactory</span>

       and the queue name or Queue instance(s) from which that listener should consume Messages. Here is the most basic example using the default implementation, 

      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SimpleMessageListenerContainer</span>

       : 

      <pre class="programlisting">SimpleMessageListenerContainer container = <span style="color: #0000FF">new</span> SimpleMessageListenerContainer();
container.ConnectionFactory = rabbitConnectionFactory;
container.Queue = <span style="color: #000000">"some.queue"</span>;
container.MessageListener = someListener;</pre>

       As an "active" component, it's most common to create the listener container with a bean definition so that it can simply run in the background. This can be done via XML: 

      <pre class="programlisting">  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"MessageListenerContainer"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Listener.SimpleMessageListenerContainer, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"RabbitConnectionFactory"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"Queue"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"some.queue"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"MessageListener"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"SomeListener"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>
</pre>

       
    </div>
  </div>

  <div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e159"></a>1.6.&nbsp;Message Converters</h2></div></div></div>
    

    <p>The <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">AmqpTemplate</span> also defines several
    methods for sending and receiving Messages that will delegate to a
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">MessageConverter</span>. The
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">MessageConverter</span> itself is quite
    straightforward. It provides a single method for each direction: one for
    converting <span class="emphasis"><em>to</em></span> a Message and another for converting
    <span class="emphasis"><em>from</em></span> a Message. Notice that when converting to a
    Message, you may also provide properties in addition to the object. The
    "object" parameter typically corresponds to the Message body.</p>

    <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IMessageConverter
    {
        Message ToMessage(<span style="color: #0000FF">object</span> obj, IMessagePropertiesFactory messagePropertiesFactory);

        <span style="color: #0000FF">object</span> FromMessage(Message message);
    }</pre>

    <p>The relevant Message-sending methods on the
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">AmqpTemplate</span> are listed below. They are
    simpler than the methods we discussed previously because they do not
    require the MessageCreator callback. Instead, the MessageConverter is
    responsible for "creating" each Message by converting the provided object
    to the byte array for the Message body and then adding any provided
    MessageProperties.</p>

    <pre class="programlisting">        <span style="color: #0000FF">void</span> ConvertAndSend(<span style="color: #0000FF">object</span> message);

        <span style="color: #0000FF">void</span> ConvertAndSend(<span style="color: #0000FF">string</span> routingKey, <span style="color: #0000FF">object</span> message);

        <span style="color: #0000FF">void</span> ConvertAndSend(<span style="color: #0000FF">string</span> exchange, <span style="color: #0000FF">string</span> routingKey, <span style="color: #0000FF">object</span> message);

        <span style="color: #0000FF">void</span> ConvertAndSend(<span style="color: #0000FF">object</span> message, MessagePostProcessorDelegate messagePostProcessorDelegate);

        <span style="color: #0000FF">void</span> ConvertAndSend(<span style="color: #0000FF">string</span> routingKey, <span style="color: #0000FF">object</span> message, MessagePostProcessorDelegate messagePostProcessorDelegate);

        <span style="color: #0000FF">void</span> ConvertAndSend(<span style="color: #0000FF">string</span> exchange, <span style="color: #0000FF">string</span> routingKey, <span style="color: #0000FF">object</span> message, MessagePostProcessorDelegate messagePostProcessorDelegate);

</pre>

    <p>On the receiving side, there are only two methods: one that accepts
    the queue name and one that relies on the template's "queue" property
    having been set.</p>

    <pre class="programlisting">        <span style="color: #0000FF">object</span> ReceiveAndConvert();

        <span style="color: #0000FF">object</span> ReceiveAndConvert(<span style="color: #0000FF">string</span> queueName);
</pre>

    <div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e173"></a>1.6.1.&nbsp;SimpleMessageConverter</h3></div></div></div>
      

      <p>The default implementation of the
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IMessageConverter</span> strategy is called
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SimpleMessageConverter</span>. This is the converter
      that will be used by an instance of RabbitTemplate if you do not
      explicitly configure an alternative. It handles text-based content,
      and simple byte arrays.</p>

      <div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e178"></a>1.6.1.1.&nbsp;Converting From a Message</h4></div></div></div>
        

        <p>If the content type of the input Message begins with "text"
        (e.g. "text/plain"), it will also check for the content-encoding
        property to determine the charset to be used when converting the
        Message body byte array to a Java String. If no content-encoding
        property had been set on the input Message, it will use the "UTF-8"
        charset by default. If you need to override that default setting, you
        can configure an instance of
        <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SimpleMessageConverter</span>, set its
        "defaultCharset" property and then inject that into a
        <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">RabbitTemplate</span> instance.</p>

        <p>In the next two sections, we'll explore some
        alternatives for passing rich domain object content without relying on
        .NET (byte[])serialization.</p>

        <p>For all other content-types, the
        <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SimpleMessageConverter</span> will return the Message
        body content directly as a byte array.</p>
      </div>

      <div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e186"></a>1.6.1.2.&nbsp;Converting To a Message</h4></div></div></div>
        

        <p>When converting to a Message from an arbitrary .NET Object, the
        <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SimpleMessageConverter</span> likewise deals with byte
        arrays, Strings, and Serializable instances. It will convert each of
        these to bytes (in the case of byte arrays, there is nothing to
        convert), and it will set the content-type property accordingly. If
        the Object to be converted does not match one of those types, the
        Message body will be null.</p>
      </div>
    </div>

    <div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d4e190"></a>1.6.2.&nbsp;JsonMessageConverter</h3></div></div></div>
      

      <p>One rather common approach to object serialization that is 
      flexible and portable across different
      languages and platforms is JSON (JavaScript Object Notation). An
      implementation is available and can be configured on any
      <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">RabbitTemplate</span> instance to override its usage of
      the <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">SimpleMessageConverter</span> default.</p>

      <pre class="programlisting">  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"RabbitTemplate"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Core.RabbitTemplate, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ConnectionFactory"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"MessageConverter"</span><span style="color: #A31515">&gt;</span>
      <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Support.Converter.JsonMessageConverter, Spring.Messaging.Amqp"</span><span style="color: #A31515">&gt;</span>
        <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"TypeMapper"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"CustomTypeMapper"</span><span style="color: #A31515">/&gt;</span>
      <span style="color: #A31515">&lt;/object&gt;</span>
    <span style="color: #A31515">&lt;/property&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>
</pre>
    </div>
  </div>

  <div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="broker-configuration"></a>1.7.&nbsp;Configuring the broker</h2></div></div></div>
    

    <p>The AMQP specification describes how the protocol can be used to
    configure Queues, Exchanges and Bindings on the broker. These operations
    which are portable from the 0.8 specification and higher are present in
    the AmqpAdmin interface in the org.springframework.amqp.core package. The
    RabbitMQ implementation of that class is RabbitAdmin located in the
    org.springframework.amqp.rabbit.core package. Any many configuration and
    management functions are broker specific and not included in the AMQP
    specification, the interface RabbitBrokerOperations and its implementation
    RabbitBrokerAdmin located in the org.springframework.amqp.rabbit.admin
    package is provided to fill that gap.</p>

    <p>The AmqpAdmin interface is based on using the Spring AMQP domain
    abstractions and is shown below:</p>

    <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IAmqpAdmin
    {

        <span style="color: #0000FF">void</span> DeclareExchange(IExchange exchange);

        <span style="color: #0000FF">void</span> DeleteExchange(<span style="color: #0000FF">string</span> exchangeName);

        Queue DeclareQueue();

        <span style="color: #0000FF">void</span> DeclareQueue(Queue queue);

        <span style="color: #0000FF">void</span> DeleteQueue(<span style="color: #0000FF">string</span> queueName);

        <span style="color: #0000FF">void</span> DeleteQueue(<span style="color: #0000FF">string</span> queueName, <span style="color: #0000FF">bool</span> unused, <span style="color: #0000FF">bool</span> empty);

        <span style="color: #0000FF">void</span> PurgeQueue(<span style="color: #0000FF">string</span> queueName, <span style="color: #0000FF">bool</span> noWait);

        <span style="color: #0000FF">void</span> DeclareBinding(Binding binding);

    }</pre>

    <p>The DeclareQueue() method defined a queue on the broker whose name
    is automatically created. The additional properties of this auto-generated
    queue are exclusive=true, autoDelete=true, and durable=false.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p>Removing a binding was not introduced until the 0.9 version of
        the AMQP spec.</p>
      </td></tr></table></div>

    <p>The RabbitMQ implementation of this interface is RabbitAdmin which
    when configured using Spring XML would look lik this:</p><pre class="programlisting"><span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Connection.SingleConnectionFactory, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;constructor-arg</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"localhost"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"username"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"guest"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"password"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"guest"</span><span style="color: #A31515">/&gt;</span>
<span style="color: #A31515">&lt;/object&gt;</span>


<span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"AmqpAdmin"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Messaging.Amqp.Rabbit.Core.RabbitAdmin, Spring.Messaging.Amqp.Rabbit"</span><span style="color: #A31515">&gt;</span>
  <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ConnectionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ConnectionFactory"</span><span style="color: #A31515">/&gt;</span>
<span style="color: #A31515">&lt;/object&gt;</span></pre>

    <p>There is also a more extensive set of administration operations
    available that are specific to the RabbitMQ broker. Thesse are in the
    interface IRabbitBrokerOperations and are implemented in the class
    RabbitBrokerAdmin. The implementation uses an Erlang interopability
    library to make Erlang RPC calls to the server. The functionality mimics
    what is available in rabbitmqctl.bat. </p>

    <pre class="programlisting">    <span style="color: #0000FF">public</span> <span style="color: #0000FF">interface</span> IRabbitBrokerOperations : IAmqpAdmin
    {

        <span style="color: #0000FF">void</span> RemoveBinding(Binding binding);

        RabbitStatus Status { <span style="color: #0000FF">get</span>; }

        IList&lt;QueueInfo&gt; Queues { <span style="color: #0000FF">get</span>; }

        <i style="color: #008000">// User management</i>

        <span style="color: #0000FF">void</span> AddUser(<span style="color: #0000FF">string</span> username, <span style="color: #0000FF">string</span> password);

        <span style="color: #0000FF">void</span> DeleteUser(<span style="color: #0000FF">string</span> username);

        <span style="color: #0000FF">void</span> ChangeUserPassword(<span style="color: #0000FF">string</span> username, <span style="color: #0000FF">string</span> newPassword);

        IList&lt;<span style="color: #0000FF">string</span>&gt; ListUsers();

        <span style="color: #0000FF">void</span> StartBrokerApplication();

        <span style="color: #0000FF">void</span> StopBrokerApplication();

        <b>/// &lt;summary&gt;</b>
        <b>/// Starts the node. NOT YET IMPLEMENTED!</b>
        <b>/// &lt;/summary&gt;</b>
        <span style="color: #0000FF">void</span> StartNode();

        <span style="color: #0000FF">void</span> StopNode();
     
        <span style="color: #0000FF">void</span> ResetNode();

        <span style="color: #0000FF">void</span> ForceResetNode();

        <i style="color: #008000">// NOTE THE OPERATIONS BELOW ARE NOT YET IMPLEMENTED IN M1</i>

        <i style="color: #008000">// VHost management</i>

        <span style="color: #0000FF">int</span> AddVhost(<span style="color: #0000FF">string</span> vhostPath);

        <span style="color: #0000FF">int</span> DeleteVhost(<span style="color: #0000FF">string</span> vhostPath);

        <i style="color: #008000">// permissions</i>

        <span style="color: #0000FF">void</span> SetPermissions(<span style="color: #0000FF">string</span> username, Regex configure, Regex read, Regex write);

        <span style="color: #0000FF">void</span> SetPermissions(<span style="color: #0000FF">string</span> username, Regex configure, Regex read, Regex write, <span style="color: #0000FF">string</span> vhostPath);

        <span style="color: #0000FF">void</span> ClearPermissions(<span style="color: #0000FF">string</span> username);

        <span style="color: #0000FF">void</span> ClearPermissions(<span style="color: #0000FF">string</span> username, <span style="color: #0000FF">string</span> vhostPath);

        List&lt;<span style="color: #0000FF">string</span>&gt; ListPermissions();

        List&lt;<span style="color: #0000FF">string</span>&gt; ListPermissions(<span style="color: #0000FF">string</span> vhostPath);

        List&lt;<span style="color: #0000FF">string</span>&gt; ListUserPermissions(<span style="color: #0000FF">string</span> username);
    }</pre>

    <p>You instantiate an instance of
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">RabbitBrokerAdmin</span> by passing an Spring Rabbit
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IConnectionFactory</span> reference to its
    constructor. Please refer to the API docs for the contents of the
    <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">RabbitStatus</span> and <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">QueueInfo</span>
    classes.</p>
  </div>
</div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="erlang.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part&nbsp;II.&nbsp;Reference&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource</a></span></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;2.&nbsp;Erlang integration</td></tr></table></div></body></html>